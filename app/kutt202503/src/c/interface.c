// Code generated by mkBuiltC.

char *interface_code (void) {
  return ""
"\n"
  "// INTERFACE ----------------------------------------\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//02-built_in\n"
  "// -------------------------------------\n"
  "\n"
  "void ___built_jump (int reference) {\n"
  "Exc *exc = exc_get();\n"
  "longjmp(*((jmp_buf *)arr_pop(exc->buf)), reference);\n"
  "}\n"
  "char *___built_mpos(char *module_ln) {\n"
  "char *mpath(char *module_id) {\n"
  "char *data = file_read(path_cat(__sys_compilerRoot().s, \"index.tb\", NULL));\n"
  "Arr *tb = js_ra(data);\n"
  "EACH(tb, char, e) {\n"
  "Arr *fs = js_ra(e);\n"
  "if (!strcmp(js_rs(arr_get(fs, 1)), module_id))\n"
  "return js_rs(arr_get(fs, 0));\n"
  "}_EACH\n"
  "return str_f(\"?(%s)\", module_id);\n"
  "}\n"
  "int ix = str_cindex(module_ln, ':');\n"
  "return str_f(\"%s%s:\", mpath(str_left(module_ln, ix)), module_ln + ix);\n"
  "}\n"
  "char *___built_stack_line (char *e) {\n"
  "char *path = path_cat(__sys_compilerRoot().s, \"compilationDb\", NULL);\n"
  "int ix1 = str_last_cindex(e, ')');\n"
  "if (ix1 == -1) return \"\";\n"
  "e = str_left(e, ix1);\n"
  "ix1 = str_cindex(e, '(');\n"
  "if (ix1 == -1) return \"\";\n"
  "e = str_right(e, ix1 + 1);\n"
  "ix1 = str_cindex(e, '_');\n"
  "if (ix1 == -1) return \"\";\n"
  "ix1 = str_cindex_from(e, '_', ix1 + 1);\n"
  "if (ix1 == -1) return \"\";\n"
  "int ix2 = str_cindex_from(e, '_', ix1 + 1);\n"
  "if (ix2 == -1) {\n"
  "if (str_starts(str_right(e, ix1), \"_main+\")) ix2 = ix1 + 5;\n"
  "else return \"\";\n"
  "}\n"
  "char *mdId = str_left(e, ix1);\n"
  "char *fn = str_sub(e, ix1 + 1, ix2);\n"
  "char *mdPath = path_cat(path, str_f(\"%s.mod\", mdId), NULL);\n"
  "if (!file_exists(mdPath)) return \"\";\n"
  "Arr *tb = js_ra(file_read(mdPath));\n"
  "char *fpath = js_rs(arr_get(tb, 0));\n"
  "if (!strcmp(fn, \"main\")) return str_f(\"  %s:[main]\", fpath);\n"
  "Arr *fn_tb = js_ra(arr_get(tb, 3));\n"
  "int n = -1;\n"
  "EACH(fn_tb, char, e) {\n"
  "Arr *fields = js_ra(e);\n"
  "if (!strcmp(js_rs(arr_get(fields, 1)), fn)) {\n"
  "n = js_ri(arr_get(fields, 0));\n"
  "break;\n"
  "}\n"
  "}_EACH\n"
  "if (n != -1) return str_f(\"  %s:%d:\", fpath, n);\n"
  "return \"\";\n"
  "}\n"
  "Val ___built_divi(char *pos, Val n1, Val n2) {\n"
  "if (n2.i == 0) ___built_throw(pos, (Val)\"Division by 0\");\n"
  "return (Val) (n1.i / n2.i);\n"
  "}\n"
  "Val ___built_divf(char *pos, Val n1, Val n2) {\n"
  "if (math_eq(n2.f, 0)) ___built_throw(pos, (Val)\"Division by 0\");\n"
  "return (Val) (n1.f / n2.f);\n"
  "}\n"
  "Val ___built_eq (Val type, Val value1, Val value2) {\n"
  "char *t = __arr_get(type, (Val)0).s;\n"
  "if (*t == 'b') return (Val)(value1.b == value2.b);\n"
  "if (*t == 'i') return (Val)(value1.i == value2.i);\n"
  "if (*t == 'f') return (Val)(math_eq(value1.f, value2.f));\n"
  "if (*t == 's') return (Val)(!strcmp(value1.s, value2.s));\n"
  "if (*t == 'a') {\n"
  "if (__arr_size(value1).i != __arr_size(value2).i) return (Val)FALSE;\n"
  "Val atp = __arr_get(__arr_get(type, (Val)1), (Val)0);\n"
  "Varr *a1 = value1.a;\n"
  "Varr *a2 = value2.a;\n"
  "Val *e1 = a1->begin;\n"
  "Val *e2 = a2->begin;\n"
  "Val *end = a1->end;\n"
  "while (e1 < end) {\n"
  "if (!___built_eq(atp, *e1++, *e2++).b) return (Val)FALSE;\n"
  "}\n"
  "return (Val)TRUE;\n"
  "}\n"
  "if (*t == 'd') {\n"
  "if (__arr_size(value1).i != __arr_size(value2).i) return (Val)FALSE;\n"
  "Val dtp = __arr_get(__arr_get(type, (Val)1), (Val)0);\n"
  "Varr *a = value1.a;\n"
  "Val *e = a->begin;\n"
  "Val *end = a->end;\n"
  "while (e < end) {\n"
  "Varr *kv = (*e++).a;\n"
  "Val rs = __dic_get(value2, kv->begin[0]);\n"
  "if (\n"
  "!__arr_size(rs).i |\n"
  "!___built_eq(dtp, kv->begin[1], rs.a->begin[0]).b\n"
  ") return (Val)FALSE;\n"
  "}\n"
  "return (Val)TRUE;\n"
  "}\n"
  "if (*t == 't') {\n"
  "Varr *atp = __arr_get(type, (Val)1).a;\n"
  "Val *etp = atp->begin;\n"
  "Val *endtp = atp->end;\n"
  "Varr *a1 = value1.a;\n"
  "Varr *a2 = value2.a;\n"
  "Val *e1 = a1->begin;\n"
  "Val *e2 = a2->begin;\n"
  "while (etp < endtp) {\n"
  "if (!___built_eq(*etp++, *e1++, *e2++).b) return (Val)FALSE;\n"
  "}\n"
  "return (Val)TRUE;\n"
  "}\n"
  "return (Val)(value1.o == value2.o);\n"
  "}\n"
  "Val ___built_to_str_trace (Val type, Val value) {\n"
  "char *t = __arr_get(type, (Val)0).s;\n"
  "return (*t == 's')\n"
  "? __js_ws(value)\n"
  ": ___built_to_str(type, value)\n"
  ";\n"
  "}\n"
  "Val ___built_to_str (Val type, Val value) {\n"
  "char *t = __arr_get(type, (Val)0).s;\n"
  "if (*t == 'b') return value.b ? (Val)\"true\" : (Val)\"false\";\n"
  "if (*t == 'i') return __math_itos(value);\n"
  "if (*t == 'f') {\n"
  "char *r = math_ftos(value.f, 9);\n"
  "if (str_cindex(r, '.') == -1) r = str_f(\"%s.0\", r);\n"
  "return (Val)r;\n"
  "}\n"
  "if (*t == 's') return value;\n"
  "if (*t == 'a') {\n"
  "Val atp = __arr_get(__arr_get(type, (Val)1), (Val)0);\n"
  "Arr *bf = arr_new(); // [s.]\n"
  "Varr *a = value.a;\n"
  "Val *e = a->begin;\n"
  "Val *end = a->end;\n"
  "while (e < end) {\n"
  "arr_push(bf, ___built_to_str_trace(atp, *e++).s);\n"
  "}\n"
  "return (Val)str_f(\"[%s]\", arr_join(bf, \",\"));\n"
  "}\n"
  "if (*t == 'd') {\n"
  "Val dtp = __arr_get((__arr_get(type, (Val)1)), (Val)0);\n"
  "Arr *bf = arr_new(); // [s.]\n"
  "Varr *a = value.a;\n"
  "Val *e = a->begin;\n"
  "Val *end = a->end;\n"
  "while (e < end) {\n"
  "Varr *a2 = e++->a;\n"
  "Val *e2 = a2->begin;\n"
  "char *key = js_ws((*e2++).s);\n"
  "char *value = ___built_to_str_trace(dtp, *e2).s;\n"
  "arr_push(bf, str_f(\"%s:%s\", key, value));\n"
  "}\n"
  "return (Val)str_f(\"{%s}\", arr_join(bf, \",\"));\n"
  "}\n"
  "if (*t == 't') {\n"
  "Arr *bf = arr_new(); // [s.]\n"
  "Varr *atp = __arr_get(type, (Val)1).a;\n"
  "Val *etp = atp->begin;\n"
  "Val *endtp = atp->end;\n"
  "Varr *a = value.a;\n"
  "Val *e = a->begin;\n"
  "while (etp < endtp) {\n"
  "arr_push(bf, ___built_to_str_trace(*etp++, *e++).s);\n"
  "}\n"
  "return (Val)str_f(\"[. %s]\", arr_join(bf, \",\"));\n"
  "}\n"
  "if (*t == 'r') {\n"
  "Val atp = __arr_get(__arr_get(type, (Val)1), (Val)0);\n"
  "Arr *bf = arr_new(); // [s.]\n"
  "while (__iter_hasNext(value).b)\n"
  "arr_push(bf, ___built_to_str_trace(atp, __iter_next(value)).s);\n"
  "return (Val)str_f(\"[! %s]\", arr_join(bf, \",\"));\n"
  "}\n"
  "return (Val)str_f(\"%s(%ld)\", t, (long)value.o);\n"
  "}\n"
  "void ___built_throw (char *pos, Val msg) {\n"
  "Exc *exc = exc_get();\n"
  "void *array[30];\n"
  "size_t size;\n"
  "char **strings;\n"
  "size = backtrace(array, 30);\n"
  "strings = backtrace_symbols(array, size);\n"
  "Arr *stack = arr_new();\n"
  "RANGE0(i, size) {\n"
  "char *e = ___built_stack_line(strings[i]);\n"
  "if (*e) arr_push(stack, e);\n"
  "}_RANGE\n"
  "free(strings);\n"
  "exc->stack = stack;\n"
  "exc->msg = str_f(\"%s %s\", ___built_mpos(pos), msg.s);\n"
  "exc->type = \"\";\n"
  "longjmp(*((jmp_buf *)arr_pop(exc->buf)), 1);\n"
  "}\n"
  "void ___built_trace (Val isComplete, char *pos, Val type, Val value) {\n"
  "char *r = ___built_to_str_trace(type, value).s;\n"
  "if (!(isComplete.b)) r = arr_join(arr_take(str_runes(r), 50), \"\");\n"
  "puts(str_f(\"%s %s\", ___built_mpos(pos), r));\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//arr\n"
  "// -------------------------------------\n"
  "\n"
  "Val __arr_all (Val a, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "int r = TRUE;\n"
  "while (p < end) {\n"
  "Val v = *p++;\n"
  "r = r && (((Val (*)(Val))fn.o)(v)).b;\n"
  "}\n"
  "return (Val)r;\n"
  "}\n"
  "Val __arr_any (Val a, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "int r = FALSE;\n"
  "while (p < end) {\n"
  "Val v = *p++;\n"
  "r = r || (((Val (*)(Val))fn.o)(v)).b;\n"
  "}\n"
  "return (Val)r;\n"
  "}\n"
  "void __arr_clear (Val a) {\n"
  "a.a->end = a.a->begin;\n"
  "}\n"
  "void __arr_cat (Val a, Val a2) {\n"
  "int64_t other_size = __arr_size(a2).i;\n"
  "if (other_size) {\n"
  "int64_t this_size = __arr_size(a).i;\n"
  "int64_t this_buffer = a.a->end_bf - a.a->begin;\n"
  "if (this_size + other_size >= this_buffer){\n"
  "int64_t new_buffer = this_buffer + other_size + 15;\n"
  "a.a->begin = GC_REALLOC(a.a->begin, new_buffer * sizeof(Val));\n"
  "a.a->end = a.a->begin + this_size;\n"
  "a.a->end_bf = a.a->begin + new_buffer;\n"
  "}\n"
  "Val *s = a2.a->begin;\n"
  "Val *s_end = a2.a->end;\n"
  "Val *t = a.a->end;\n"
  "while (s < s_end) *t++ = *s++;\n"
  "a.a->end = t;\n"
  "}\n"
  "}\n"
  "Val __arr_cat2 (Val a, Val a2) {\n"
  "Val r = __arr_copy(a);\n"
  "__arr_cat(r, a2);\n"
  "return r;\n"
  "}\n"
  "Val __arr_copy (Val a) {\n"
  "Varr *this = a.a;\n"
  "int64_t size = this->end - this->begin;\n"
  "int64_t buffer = this->end_bf - this->begin;\n"
  "Varr *r = MALLOC(Varr);\n"
  "Val *begin = GC_MALLOC(buffer * sizeof(Val));\n"
  "memcpy(begin, this->begin, size * sizeof(Val));\n"
  "r->begin = begin;\n"
  "r->end = begin + size;\n"
  "r->end_bf = begin + buffer;\n"
  "return (Val)r;\n"
  "}\n"
  "Val __arr_drop (Val a, Val n) {\n"
  "if (n.i < 0) return __arr_copy(a);\n"
  "if (n.i >= __arr_size(a).i) return __arr_new();\n"
  "Val r = __arr_new();\n"
  "Val *p = a.a->begin + n.i;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) __arr_push(r, *p++);\n"
  "return r;\n"
  "}\n"
  "Val __arr_dropWhile (Val a, Val fn) {\n"
  "Val r = __arr_new();\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) {\n"
  "if (!(((Val (*)(Val))fn.o)(*p)).b) break;\n"
  "++p;\n"
  "}\n"
  "while (p < end) __arr_push(r, *p++);\n"
  "return r;\n"
  "}\n"
  "Val __arr_duplicates (Val a, Val fn) {\n"
  "Val r = __arr_new();\n"
  "Val dup = __arr_new();\n"
  "Val *ap = a.a->begin;\n"
  "Val *aend = a.a->end;\n"
  "while (ap < aend) {\n"
  "Val e = *ap++;\n"
  "Val *rp = r.a->begin;\n"
  "Val *rend = r.a->end;\n"
  "int missing = TRUE;\n"
  "while (rp < rend) {\n"
  "Val e2 = *rp++;\n"
  "if ((((Val (*)(Val,Val))fn.o)(e, e2)).b) {\n"
  "missing = FALSE;\n"
  "Val *dp = dup.a->begin;\n"
  "Val *dend = dup.a->end;\n"
  "int missing2 = TRUE;\n"
  "while (dp < dend) {\n"
  "Val e2 = *dp++;\n"
  "if ((((Val (*)(Val,Val))fn.o)(e, e2)).b) {\n"
  "missing2 = FALSE;\n"
  "break;\n"
  "}\n"
  "}\n"
  "if (missing2) __arr_push(dup, e);\n"
  "break;\n"
  "}\n"
  "}\n"
  "if (missing) __arr_push(r, e);\n"
  "}\n"
  "return __arr_new_from_carr((Val)2, (Val[]){r, dup});\n"
  "}\n"
  "void __arr_each (Val a, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) ((void (*)(Val))fn.o)(*p++);\n"
  "}\n"
  "void __arr_eachIx (Val a, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "int64_t i = 0;\n"
  "while (p < end) ((void (*)(Val,Val))fn.o)(*p++, ((Val)i++));\n"
  "}\n"
  "Val __arr_filter (Val a, Val fn) {\n"
  "Val r = __arr_new();\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) {\n"
  "Val e = *p++;\n"
  "if ((((Val (*)(Val))fn.o)(e)).b) __arr_push(r, e);\n"
  "}\n"
  "return (Val)r;\n"
  "}\n"
  "void __arr_filterIn (Val a, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "Val *new_end = p;\n"
  "while (p < end) {\n"
  "Val e = *p++;\n"
  "if ((((Val (*)(Val))fn.o)(e)).b) *new_end++ = e;\n"
  "}\n"
  "a.a->end = new_end;\n"
  "}\n"
  "Val __arr_find (Val a, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) {\n"
  "Val e = *p++;\n"
  "if ((((Val (*)(Val))fn.o)(e)).b)\n"
  "return __arr_new_from_carr((Val)1, (Val[]){e});\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __arr_fromIter (Val it) {\n"
  "Val a = __arr_new();\n"
  "while (__iter_hasNext(it).b) __arr_push(a, __iter_next(it));\n"
  "return a;\n"
  "}\n"
  "Val __arr_fromJs (Val s, Val fn) {\n"
  "return __arr_map(__js_ra(s), fn);\n"
  "}\n"
  "Val __arr_from_sarr (Arr *a) {\n"
  "Val r = __arr_new();\n"
  "EACH(a, char, el) {\n"
  "__arr_push(r, (Val)el);\n"
  "}_EACH\n"
  "return r;\n"
  "}\n"
  "Val __arr_get (Val a, Val ix) {\n"
  "return a.a->begin[ix.i];\n"
  "}\n"
  "Val __arr_get2 (char *pos, Val a, Val ix) {\n"
  "Varr *arr = a.a;\n"
  "int64_t sz = arr->end - arr->begin;\n"
  "int64_t i = ix.i;\n"
  "if (i < 0 || i >= sz)\n"
  "___built_throw(pos, (Val)str_f(\"Index %d out of [0,%d]\", i, sz - 1));\n"
  "return arr->begin[i];\n"
  "}\n"
  "Val __arr_index (Val a, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "int64_t i = 0;\n"
  "while (p < end) {\n"
  "if ((((Val (*)(Val))fn.o)(*p++)).b) return (Val)i;\n"
  "++i;\n"
  "}\n"
  "return (Val)(int64_t)-1;\n"
  "}\n"
  "void __arr_insert (char *pos, Val a, Val ix, Val e) {\n"
  "int64_t size = __arr_size(a).i;\n"
  "if (ix.i < 0 || ix.i > size)\n"
  "___built_throw(pos, (Val)str_f(\"index %d out of [0,%d]\", ix.i, size));\n"
  "__arr_push(a, e);\n"
  "Val *p = a.a->end;\n"
  "Val *pix = a.a->begin + ix.i;\n"
  "while (p > pix) {\n"
  "*p = *(p - 1);\n"
  "--p;\n"
  "}\n"
  "*p = e;\n"
  "}\n"
  "void __arr_insertArr (char *pos, Val a, Val ix, Val other) {\n"
  "__arr_insertRange(pos, a, ix, other, (Val)0, __arr_size(other));\n"
  "}\n"
  "void __arr_insertRange (char *pos, Val this, Val ix, Val other, Val begin, Val end) {\n"
  "int64_t this_len = __arr_size(this).i;\n"
  "if (ix.i < 0 || ix.i > this_len)\n"
  "___built_throw(pos, (Val)str_f(\"index %d out of [0,%d]\", ix.i, this_len));\n"
  "int64_t other_size = __arr_size(other).i;\n"
  "if (end.i < begin.i)\n"
  "___built_throw(pos, (Val)str_f(\"end(%d) < begin(%d)\", end.i, begin.i));\n"
  "if (begin.i < 0)\n"
  "___built_throw(pos, (Val)str_f(\"begin(%d) < 0\", begin.i));\n"
  "if (end.i > other_size)\n"
  "___built_throw(pos, (Val)str_f(\"end(%d) > size(%d)\", end.i, other_size));\n"
  "int64_t other_len = end.i - begin.i;\n"
  "if (!other_len) return;\n"
  "int64_t new_len = this_len + other_len;\n"
  "int64_t new_size = new_len + 15;\n"
  "Val *new_begin = GC_MALLOC(new_size * sizeof(Val));\n"
  "memcpy(new_begin, this.a->begin, sizeof(Val) * ix.i);\n"
  "memcpy(new_begin + ix.i, other.a->begin + begin.i, sizeof(Val) * other_len);\n"
  "memcpy(\n"
  "new_begin + (ix.i + other_len),\n"
  "this.a->begin + ix.i,\n"
  "sizeof(Val) * (__arr_size(this).i - ix.i)\n"
  ");\n"
  "this.a->begin = new_begin;\n"
  "this.a->end = new_begin + new_len;\n"
  "this.a->end_bf = new_begin + new_size;\n"
  "}\n"
  "Val __arr_join(Val a, Val sep) {\n"
  "Buf *bf = buf_new();\n"
  "int first = 1;\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) {\n"
  "if (first) {\n"
  "first = 0;\n"
  "} else {\n"
  "buf_add(bf, sep.s);\n"
  "}\n"
  "buf_add(bf, (*p++).s);\n"
  "}\n"
  "return (Val)str_new(buf_str(bf));\n"
  "}\n"
  "Val __arr_map(Val a, Val fn) {\n"
  "Val r = __arr_new();\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) __arr_push(r, ((Val (*)(Val))fn.o)(*p++));\n"
  "return r;\n"
  "}\n"
  "Val __arr_new (void) {\n"
  "Varr *this = MALLOC(Varr);\n"
  "this->begin = GC_MALLOC(15 * sizeof(Val));\n"
  "this->end = this->begin;\n"
  "this->end_bf = this->begin + 15;\n"
  "return (Val)this;\n"
  "}\n"
  "Val __arr_new_fill (Val el, Val n) {\n"
  "int64_t size = n.i < 0 ? 0 : n.i;\n"
  "int64_t bf_size = size + 15;\n"
  "Varr *this = MALLOC(Varr);\n"
  "this->begin = GC_MALLOC(bf_size * sizeof(Val));\n"
  "this->end = this->begin + size;\n"
  "this->end_bf = this->begin + bf_size;\n"
  "Val *p = this->begin;\n"
  "Val *end = this->end;\n"
  "while (p < end) *p++ = el;\n"
  "return (Val)this;\n"
  "}\n"
  "Val __arr_new_from_carr (Val n, Val *els) {\n"
  "Val r = __arr_new();\n"
  "REPEAT(n.i) {\n"
  "__arr_push(r, *els++);\n"
  "}_REPEAT\n"
  "return r;\n"
  "}\n"
  "Val __arr_peek (char *pos, Val a) {\n"
  "int64_t size = __arr_size(a).i;\n"
  "if (size == 0) ___built_throw(pos, (Val)\"Array is empty\");\n"
  "return *(a.a->end - 1);\n"
  "}\n"
  "Val __arr_pop (char *pos, Val a) {\n"
  "int64_t size = __arr_size(a).i;\n"
  "if (size == 0) ___built_throw(pos, (Val)\"Array is empty\");\n"
  "return *(a.a->end-- - 1);\n"
  "}\n"
  "void __arr_push (Val a, Val el) {\n"
  "Varr *this = a.a;\n"
  "if (this->end == this->end_bf) {\n"
  "int size = this->end_bf - this->begin;\n"
  "int new_size = size + size;\n"
  "this->begin = GC_REALLOC(this->begin, new_size * sizeof(Val));\n"
  "this->end = this->begin + size;\n"
  "this->end_bf = this->begin + new_size;\n"
  "}\n"
  "*this->end++ = el;\n"
  "}\n"
  "Val __arr_reduce (Val a, Val seed, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) seed = ((Val (*)(Val,Val))fn.o)(seed, *p++);\n"
  "return seed;\n"
  "}\n"
  "Val __arr_remove (char *pos, Val a, Val ix) {\n"
  "int64_t sz = __arr_size(a).i;\n"
  "int64_t i = ix.i;\n"
  "if (i < 0 || i >= sz)\n"
  "___built_throw(pos, (Val)str_f(\"index %d out of [0,%d]\", i, sz - 1));\n"
  "Val *p = a.a->begin + ix.i;\n"
  "Val r = *p;\n"
  "Val *p1 = p + 1;\n"
  "Val *end = a.a->end--;\n"
  "while (p1 < end) *p++ = *p1++;\n"
  "return r;\n"
  "}\n"
  "Val __arr_removeRange (char *pos, Val a, Val begin, Val end) {\n"
  "int64_t sz = __arr_size(a).i;\n"
  "int64_t b = begin.i;\n"
  "int64_t e = end.i;\n"
  "if (b < 0 || b >= sz)\n"
  "___built_throw(pos, (Val)str_f(\"begin index %d out of [0,%d]\", b, sz - 1));\n"
  "if (e < b || e > sz)\n"
  "___built_throw(pos, (Val)str_f(\"end index %d out of [%d,%d]\", e, b, sz));\n"
  "int64_t len = e - b;\n"
  "Val r = __arr_take(__arr_drop(a, begin), (Val)len);\n"
  "Val *p = a.a->begin + b;\n"
  "Val *p1 = a.a->begin + e;\n"
  "Val *pend = a.a->end;\n"
  "a.a->end -= len;\n"
  "while (p1 < pend) *p++ = *p1++;\n"
  "return r;\n"
  "}\n"
  "Val __arr_reverse (Val a) {\n"
  "Val r = __arr_copy(a);\n"
  "__arr_reverseIn(r);\n"
  "return r;\n"
  "}\n"
  "void __arr_reverseIn (Val a) {\n"
  "int64_t sz = __arr_size(a).i;\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end - 1;\n"
  "Val tmp;\n"
  "for (int i = 0; i < sz / 2; ++i) {\n"
  "tmp = *p;\n"
  "*p++ = *end;\n"
  "*end-- = tmp;\n"
  "}\n"
  "}\n"
  "void __arr_set (Val a, Val ix, Val el) {\n"
  "a.a->begin[ix.i] = el;\n"
  "}\n"
  "void __arr_set2 (char *pos, Val a, Val ix, Val el) {\n"
  "Varr *arr = a.a;\n"
  "int64_t sz = arr->end - arr->begin;\n"
  "int64_t i = ix.i;\n"
  "if (i < 0 || i >= sz)\n"
  "___built_throw(pos, (Val)str_f(\"index %d out of [0,%d]\", i, sz - 1));\n"
  "arr->begin[i] = el;\n"
  "}\n"
  "void __arr_setArr (char *pos, Val a, Val ix, Val other) {\n"
  "__arr_setRange(pos, a, ix, other, (Val)0, __arr_size(other));\n"
  "}\n"
  "void __arr_setRange (char *pos, Val this, Val ix, Val other, Val begin, Val end) {\n"
  "int64_t this_len = __arr_size(this).i;\n"
  "int64_t other_size = __arr_size(other).i;\n"
  "if (ix.i < 0 || ix.i > this_len - other_size)\n"
  "___built_throw(\n"
  "pos, (Val)str_f(\"index %d out of [0,%d]\", ix.i, this_len - other_size)\n"
  ");\n"
  "if (end.i < begin.i)\n"
  "___built_throw(pos, (Val)str_f(\"end(%d) < begin(%d)\", end.i, begin.i));\n"
  "if (begin.i < 0)\n"
  "___built_throw(pos, (Val)str_f(\"begin(%d) < 0\", begin.i));\n"
  "if (end.i > other_size)\n"
  "___built_throw(pos, (Val)str_f(\"end(%d) > size(%d)\", end.i, other_size));\n"
  "int64_t other_len = end.i - begin.i;\n"
  "if (!other_len) return;\n"
  "Val *target = this.a->begin + ix.i;\n"
  "Val *source = other.a->begin + begin.i;\n"
  "memcpy(target, source, sizeof(Val *) * other_len);\n"
  "}\n"
  "Val __arr_shift (char *pos, Val a) {\n"
  "int64_t size = __arr_size(a).i;\n"
  "if (size == 0) ___built_throw(pos, (Val)\"Array is empty\");\n"
  "Val *p = a.a->begin;\n"
  "Val r = *p;\n"
  "Val *p1 = p + 1;\n"
  "Val *end = a.a->end--;\n"
  "while (p1 < end) *p++ = *p1++;\n"
  "return r;\n"
  "}\n"
  "void __arr_shuffle (Val a) {\n"
  "int64_t size = __arr_size(a).i;\n"
  "Val *begin = a.a->begin;\n"
  "Val *p = a.a->end - 1;\n"
  "Val *pix, tmp;\n"
  "while (p > begin) {\n"
  "pix = begin + sys_rnd_i(size--);\n"
  "tmp = *p;\n"
  "*p-- = *pix;\n"
  "*pix = tmp;\n"
  "}\n"
  "}\n"
  "Val __arr_size (Val a) {\n"
  "return (Val)(a.a->end - a.a->begin);\n"
  "}\n"
  "void __arr_sort (Val a, Val fn) {\n"
  "Val (*less0)(Val, Val) = (Val (*)(Val, Val))fn.o;\n"
  "int less (Val e1, Val e2) {\n"
  "return less0(e1, e2).b;\n"
  "}\n"
  "void sort(Val *a, int64_t size) {\n"
  "if (size < 2) {\n"
  "return;\n"
  "}\n"
  "if (size == 2) {\n"
  "if (less(a[1], a[0])) { Val tmp = a[0]; a[0] = a[1]; a[1] = tmp; }\n"
  "return;\n"
  "}\n"
  "if (size == 3) {\n"
  "if (less(a[1], a[0])) { Val tmp = a[0]; a[0] = a[1]; a[1] = tmp; }\n"
  "if (less(a[2], a[0])) { Val tmp = a[0]; a[0] = a[2]; a[2] = tmp; }\n"
  "if (less(a[2], a[1])) { Val tmp = a[1]; a[1] = a[2]; a[2] = tmp; }\n"
  "}\n"
  "int64_t mid1 = size >> 1;\n"
  "int64_t mid2 = size - mid1;\n"
  "Val a1[mid1];\n"
  "Val a2[mid2];\n"
  "Val *pa = a;\n"
  "Val *pa1 = a1;\n"
  "Val *pa2 = a2;\n"
  "for (int64_t i = 0; i < mid1; ++i) *pa1++ = *pa++;\n"
  "for (int64_t i = 0; i < mid2; ++i) *pa2++ = *pa++;\n"
  "sort(a1, mid1);\n"
  "sort(a2, mid2);\n"
  "pa = a;\n"
  "pa1 = a1;\n"
  "Val *pa1_end = a1 + mid1;\n"
  "pa2 = a2;\n"
  "Val *pa2_end = a2 + mid2;\n"
  "for(;;) {\n"
  "if (pa1 == pa1_end) {\n"
  "while (pa2 < pa2_end) *pa++ = *pa2++;\n"
  "break;\n"
  "}\n"
  "if (pa2 == pa2_end) {\n"
  "while (pa1 < pa1_end) *pa++ = *pa1++;\n"
  "break;\n"
  "}\n"
  "if (less(*pa2, *pa1)) *pa++ = *pa2++;\n"
  "else *pa++ = *pa1++;\n"
  "}\n"
  "}\n"
  "sort(a.a->begin, __arr_size(a).i);\n"
  "}\n"
  "Val __arr_sub (Val a, Val begin, Val end) {\n"
  "if (begin.i < 0) begin = (Val)(__arr_size(a).i + begin.i);\n"
  "if (end.i < 0) end = (Val)(__arr_size(a).i + end.i);\n"
  "return __arr_drop(__arr_take(a, end), begin);\n"
  "}\n"
  "Val __arr_sub0 (Val a, Val begin) {\n"
  "if (begin.i < 0) begin = (Val)(__arr_size(a).i + begin.i);\n"
  "return __arr_drop(a, begin);\n"
  "}\n"
  "Val __arr_take (Val a, Val n) {\n"
  "if (n.i > __arr_size(a).i) return __arr_copy(a);\n"
  "Val r = __arr_new();\n"
  "Val *p = a.a->begin;\n"
  "for (int64_t i = 0; i < n.i; ++i) __arr_push(r, *p++);\n"
  "return r;\n"
  "}\n"
  "Val __arr_takeWhile (Val a, Val fn) {\n"
  "Val r = __arr_new();\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) {\n"
  "if (!(((Val (*)(Val))fn.o)(*p)).b) break;\n"
  "__arr_push(r, *p++);\n"
  "}\n"
  "return r;\n"
  "}\n"
  "Val __arr_toIter_next (Val obj) {\n"
  "Val *p = obj.a->begin;\n"
  "Val a = *p;\n"
  "int64_t sz = (p+1)->i;\n"
  "int64_t c = (p+2)->i;\n"
  "if (c < sz) {\n"
  "Val r = *(a.a->begin+c);\n"
  "*(p+2) = (Val)(c + 1);\n"
  "return __arr_new_from_carr((Val)1, (Val[]){r});\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __arr_toIter (Val a) {\n"
  "return __iter_new(__arr_new_from_carr((Val)2, (Val[]){\n"
  "__arr_new_from_carr((Val)3, (Val[]){a, __arr_size(a), (Val)0}),\n"
  "(Val)(void *)__arr_toIter_next\n"
  "}));\n"
  "}\n"
  "Val __arr_toJs (Val a, Val fn) {\n"
  "return __js_wa(__arr_map(a, fn));\n"
  "}\n"
  "Arr *__arr_to_sarr (Val a) {\n"
  "Arr *r = arr_new();\n"
  "Varr *va = a.a;\n"
  "Val *p = va->begin;\n"
  "Val *end = va->end;\n"
  "while (p < end) arr_push(r, (*p++).s);\n"
  "return r;\n"
  "}\n"
  "void __arr_unshift (Val a, Val e) {\n"
  "__arr_push(a, e);\n"
  "Val *p = a.a->end;\n"
  "Val *pix = a.a->begin;\n"
  "while (p > pix) {\n"
  "*p = *(p - 1);\n"
  "--p;\n"
  "}\n"
  "*p = e;\n"
  "}\n"
  "Val __arr_unzip (Val a) {\n"
  "Val a1 = __arr_new();\n"
  "Val a2 = __arr_new();\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) {\n"
  "Val t = *p++;\n"
  "__arr_push(a1, *(t.a->begin));\n"
  "__arr_push(a2, *(t.a->begin + 1));\n"
  "}\n"
  "return __arr_new_from_carr((Val)2, (Val[]){a1, a2});\n"
  "}\n"
  "Val __arr_unzip3 (Val a) {\n"
  "Val a1 = __arr_new();\n"
  "Val a2 = __arr_new();\n"
  "Val a3 = __arr_new();\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) {\n"
  "Val t = *p++;\n"
  "__arr_push(a1, *(t.a->begin));\n"
  "__arr_push(a2, *(t.a->begin + 1));\n"
  "__arr_push(a3, *(t.a->begin + 2));\n"
  "}\n"
  "return __arr_new_from_carr((Val)3, (Val[]){a1, a2, a3});\n"
  "}\n"
  "Val __arr_zip (Val a1, Val a2) {\n"
  "Val r = __arr_new();\n"
  "int64_t sz = __arr_size(a1).i < __arr_size(a2).i\n"
  "? __arr_size(a1).i\n"
  ": __arr_size(a2).i\n"
  ";\n"
  "int64_t c = 0;\n"
  "Val *p1 = a1.a->begin;\n"
  "Val *p2 = a2.a->begin;\n"
  "while (c < sz) {\n"
  "__arr_push(r, __arr_new_from_carr((Val)2, (Val[]){*p1++, *p2++}));\n"
  "++c;\n"
  "}\n"
  "return r;\n"
  "}\n"
  "Val __arr_zip3 (Val a1, Val a2, Val a3) {\n"
  "Val r = __arr_new();\n"
  "int64_t sz = __arr_size(a1).i < __arr_size(a2).i\n"
  "? __arr_size(a1).i\n"
  ": __arr_size(a2).i\n"
  ";\n"
  "sz = sz < __arr_size(a3).i\n"
  "? sz\n"
  ": __arr_size(a2).i < __arr_size(a3).i\n"
  "? __arr_size(a2).i\n"
  ": __arr_size(a3).i\n"
  ";\n"
  "int64_t c = 0;\n"
  "Val *p1 = a1.a->begin;\n"
  "Val *p2 = a2.a->begin;\n"
  "Val *p3 = a3.a->begin;\n"
  "while (c < sz) {\n"
  "__arr_push(r, __arr_new_from_carr((Val)3, (Val[]){*p1++, *p2++, *p3++}));\n"
  "++c;\n"
  "}\n"
  "return r;\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//b64\n"
  "// -------------------------------------\n"
  "\n"
  "Val __b64_decode (char *pos, Val b64) {\n"
  "char *r;\n"
  "TRY {\n"
  "r = b64_decode(b64.s);\n"
  "} CATCH(e) {\n"
  "___built_throw(pos, (Val)exc_msg(e));\n"
  "}_TRY\n"
  "return (Val) r;\n"
  "}\n"
  "Val __b64_decodeBytes (char *pos, Val b64) {\n"
  "Bytes *r;\n"
  "TRY {\n"
  "r = b64_decode_bytes(b64.s);\n"
  "} CATCH(e) {\n"
  "___built_throw(pos, (Val)exc_msg(e));\n"
  "}_TRY\n"
  "return (Val) (void *)r;\n"
  "}\n"
  "Val __b64_encode (Val s) {\n"
  "return (Val)b64_encode(s.s);\n"
  "}\n"
  "Val __b64_encodeBytes (Val bs) {\n"
  "return (Val)b64_encode_bytes(bs.o);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//bytes\n"
  "// -------------------------------------\n"
  "\n"
  "Val __bytes_add (Val bs1, Val bs2) {\n"
  "bytes_add((Bytes *)bs1.o, (Bytes *)bs2.o);\n"
  "return bs1;\n"
  "}\n"
  "Val __bytes_drop (Val bts, Val begin) {\n"
  "Bytes *bs = (Bytes *)bts.o;\n"
  "int64_t ix = begin.i;\n"
  "int64_t sz = bytes_len(bs);\n"
  "Bytes *bs2 = sz > ix\n"
  "? ix <= 0\n"
  "? bytes_from_bytes(bytes_bs(bs), sz)\n"
  ": bytes_from_bytes(bytes_bs(bs) + ix, sz - ix)\n"
  ": bytes_new()\n"
  ";\n"
  "return (Val)(void *)bs2;\n"
  "}\n"
  "Val __bytes_fromArr (Val a) {\n"
  "int64_t sz = __arr_size(a).i;\n"
  "Bytes *bs = bytes_new_bf(sz);\n"
  "unsigned char *pu = bytes_bs(bs);\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) *pu++ = (unsigned char)(*p++).i;\n"
  "return (Val)(void *)bs;\n"
  "}\n"
  "Val __bytes_fromStr (Val str) {\n"
  "return (Val)(void *)bytes_from_str(str.s);\n"
  "}\n"
  "Val __bytes_get (char *pos, Val bs, Val ix) {\n"
  "int64_t sz = __bytes_size(bs).i;\n"
  "int64_t i = ix.i;\n"
  "if (i < 0 || i >= sz)\n"
  "___built_throw(pos, (Val)str_f(\"Index %d out of [0,%d]\", i, sz - 1));\n"
  "return (Val)(int64_t)(bytes_bs((Bytes *)bs.o)[ix.i]);\n"
  "}\n"
  "Val __bytes_new (Val size) {\n"
  "int64_t bf = size.i;\n"
  "if (bf < 0) bf = 0;\n"
  "Bytes *bs = bytes_new_bf(bf);\n"
  "unsigned char *p = bytes_bs(bs);\n"
  "while (bf) {\n"
  "*p++ = 0;\n"
  "--bf;\n"
  "}\n"
  "return (Val)(void *)bs;\n"
  "}\n"
  "void __bytes_set (char *pos, Val bs, Val ix, Val byte) {\n"
  "int64_t sz = __bytes_size(bs).i;\n"
  "int64_t i = ix.i;\n"
  "if (i < 0 || i >= sz)\n"
  "___built_throw(pos, (Val)str_f(\"Index %d out of [0,%d]\", i, sz - 1));\n"
  "bytes_bs((Bytes *)bs.o)[ix.i] = (unsigned char)byte.i;\n"
  "}\n"
  "Val __bytes_size (Val bs) {\n"
  "return (Val)(int64_t)bytes_len((Bytes *)bs.o);\n"
  "}\n"
  "Val __bytes_take (Val bts, Val end) {\n"
  "Bytes *bs = (Bytes *)bts.o;\n"
  "int64_t ix = end.i;\n"
  "int64_t sz = bytes_len(bs);\n"
  "Bytes *bs2 = ix <= 0\n"
  "? bytes_new()\n"
  ": ix >= sz\n"
  "? bytes_from_bytes(bytes_bs(bs), sz)\n"
  ": bytes_from_bytes(bytes_bs(bs), ix)\n"
  ";\n"
  "return (Val)(void *)bs2;\n"
  "}\n"
  "Val __bytes_toArr (Val bts) {\n"
  "Bytes *bs = (Bytes *)bts.o;\n"
  "int sz = bytes_len(bs);\n"
  "Val a = __arr_new();\n"
  "unsigned char *p = bytes_bs(bs);\n"
  "while (sz) {\n"
  "__arr_push(a, (Val)(int64_t)*p++);\n"
  "--sz;\n"
  "}\n"
  "return a;\n"
  "}\n"
  "Val __bytes_toStr (Val bs) {\n"
  "return (Val)bytes_to_str((Bytes *)bs.o);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//cryp\n"
  "// -------------------------------------\n"
  "\n"
  "Val __cryp_decode (Val k, Val c) {\n"
  "return (Val) cryp_decode(k.s, c.s);\n"
  "}\n"
  "Val __cryp_decodeBytes (Val k, Val c) {\n"
  "return (Val)(void *)cryp_decode_bytes(k.s, c.s);\n"
  "}\n"
  "Val __cryp_encode (Val k, Val tx) {\n"
  "return (Val)cryp_encode(k.s, tx.s);\n"
  "}\n"
  "Val __cryp_encodeBytes (Val k, Val bs) {\n"
  "return (Val)cryp_encode_bytes(k.s, bs.o);\n"
  "}\n"
  "Val __cryp_genK (Val lg) {\n"
  "return (Val)cryp_genk(lg.i);\n"
  "}\n"
  "Val __cryp_key (Val s, Val lg) {\n"
  "return (Val)cryp_key(s.s, lg.i);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//dic\n"
  "// -------------------------------------\n"
  "\n"
  "Val __dic_copy (Val d) {\n"
  "Val *p = d.a->begin;\n"
  "Val *end = d.a->end;\n"
  "int64_t bf_size = end - p;\n"
  "Varr *this = MALLOC(Varr);\n"
  "this->begin = GC_MALLOC(bf_size * sizeof(Val));\n"
  "this->end = this->begin + bf_size;\n"
  "this->end_bf = this->end;\n"
  "Val *pt = this->begin;\n"
  "while (p < end) *pt++ = __arr_copy(*p++);\n"
  "return (Val) this;\n"
  "}\n"
  "Val __dic_fromArr (Val a) {\n"
  "Val r = __arr_new();\n"
  "Varr *arr = a.a;\n"
  "Val *p = arr->begin;\n"
  "Val *end = arr->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "__dic_put(r, *(kv->begin), kv->begin[1]);\n"
  "}\n"
  "return r;\n"
  "}\n"
  "Val __dic_fromIter (Val it) {\n"
  "return __dic_fromArr(__arr_fromIter(it));\n"
  "}\n"
  "Val __dic_fromJs (Val s, Val fn) {\n"
  "Val d = __js_ro(s);\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "kv->begin[1] = ((Val (*)(Val))fn.o)(kv->begin[1]);\n"
  "}\n"
  "return d;\n"
  "}\n"
  "Val __dic_from_smap (Map *m) {\n"
  "Val r = __arr_new();\n"
  "EACH(m, Kv, el) {\n"
  "Val e = __arr_new();\n"
  "__arr_push(e, (Val)kv_key(el));\n"
  "__arr_push(e, (Val)((char *)kv_value(el)));\n"
  "__arr_push(r, e);\n"
  "}_EACH\n"
  "return r;\n"
  "}\n"
  "Val __dic_get(Val d, Val key) {\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "if (!strcmp((*(kv->begin)).s, key.s)) return __rs_some(kv->begin[1]);\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __dic_get2(char *pos, Val d, Val key) {\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "if (!strcmp((*(kv->begin)).s, key.s)) return kv->begin[1];\n"
  "}\n"
  "___built_throw(pos, (Val)str_f(\"Key %s not found\", key.s));\n"
  "return (Val)0; // Unreachable\n"
  "}\n"
  "Val __dic_hasKey(Val d, Val key) {\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "if (!strcmp((*(kv->begin)).s, key.s)) return (Val)1;\n"
  "}\n"
  "return (Val)0;\n"
  "}\n"
  "Val __dic_keys (Val d) {\n"
  "Val r = __arr_new();\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "__arr_push(r, *(kv->begin));\n"
  "}\n"
  "return r;\n"
  "}\n"
  "Val __dic_map (Val d, Val fn) {\n"
  "Val dr = __dic_copy(d);\n"
  "Varr *r = dr.a;\n"
  "Val *p = r->begin;\n"
  "Val *end = r->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "kv->begin[1] = ((Val (*)(Val))fn.o)(kv->begin[1]);\n"
  "}\n"
  "return dr;\n"
  "}\n"
  "Val __dic_new_from_carr (Val n, Val *els) {\n"
  "Val r = __arr_new();\n"
  "REPEAT(n.i) {\n"
  "Varr *kv = (*els++).a;\n"
  "__dic_put(r, *(kv->begin), kv->begin[1]);\n"
  "}_REPEAT\n"
  "return r;\n"
  "}\n"
  "void __dic_put(Val d, Val key, Val value) {\n"
  "int new = TRUE;\n"
  "char *k = key.s;\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "if (!strcmp(k, (*(kv->begin)).s)) {\n"
  "kv->begin[1] = value;\n"
  "new = FALSE;\n"
  "break;\n"
  "}\n"
  "}\n"
  "if (new) __arr_push(d, __arr_new_from_carr((Val)2, (Val[]){key, value}));\n"
  "}\n"
  "void __dic_remove(Val d, Val key) {\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "Val *target = NULL;\n"
  "while (p < end) {\n"
  "if (target) {\n"
  "*target++ = *p++;\n"
  "} else {\n"
  "Val *t = p++;\n"
  "Varr *kv = t->a;\n"
  "if (!strcmp((*(kv->begin)).s, key.s)) target = t;\n"
  "}\n"
  "}\n"
  "if (target) --(a->end);\n"
  "}\n"
  "void __dic_set(char *pos, Val d, Val key, Val value) {\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "if (!strcmp((*(kv->begin)).s, key.s)) {\n"
  "kv->begin[1] = value;\n"
  "return;\n"
  "}\n"
  "}\n"
  "___built_throw(pos, (Val)str_f(\"Key %s not found\", key.s));\n"
  "}\n"
  "Val __dic_size(Val d) {\n"
  "return __arr_size(d);\n"
  "}\n"
  "Val __dic_toArr (Val d) {\n"
  "return __dic_copy(d);\n"
  "}\n"
  "Val __dic_toIter (Val d) {\n"
  "return __arr_toIter(d);\n"
  "}\n"
  "Val __dic_toJs (Val d, Val fn) {\n"
  "Map *r = map_new();\n"
  "Varr *va = d.a;\n"
  "Val *p = va->begin;\n"
  "Val *end = va->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "arr_push((Arr *)r, kv_new(\n"
  "(*(kv->begin)).s,\n"
  "((Val (*)(Val))fn.o)(kv->begin[1]).s\n"
  "));\n"
  "}\n"
  "return __js_wo(__dic_from_smap(r));\n"
  "}\n"
  "Map *__dic_to_smap (Val a) {\n"
  "Map *r = map_new();\n"
  "Varr *va = a.a;\n"
  "Val *p = va->begin;\n"
  "Val *end = va->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "arr_push((Arr *)r, kv_new((*(kv->begin)).s, (kv->begin[1]).s));\n"
  "}\n"
  "return r;\n"
  "}\n"
  "Val __dic_values (Val d){\n"
  "Val r = __arr_new();\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "__arr_push(r, kv->begin[1]);\n"
  "}\n"
  "return r;\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//file\n"
  "// -------------------------------------\n"
  "\n"
  "Val __file_aopen (Val path) {\n"
  "return (Val)(void *)file_aopen(path.s);\n"
  "}\n"
  "Val __file_base (Val path) {\n"
  "return (Val)path_base (path.s);\n"
  "}\n"
  "Val __file_canonical (char *pos, Val path) {\n"
  "char *r = opt_get(path_canonical(path.s));\n"
  "if (!r)\n"
  "___built_throw(pos, (Val)(str_f(\"'%s' can not be canonicalized\", path.s)));\n"
  "return (Val)r;\n"
  "}\n"
  "Val __file_cat (Val path, Val rpaths) {\n"
  "__arr_unshift(rpaths, *(path.s) ? path : (Val)\".\");\n"
  "return __file_clean(__arr_join(rpaths, (Val)\"/\"));\n"
  "}\n"
  "void __file_cd (Val path) {\n"
  "file_cd(path.s);\n"
  "}\n"
  "Val __file_clean (Val path) {\n"
  "return (Val)path_clean(path.s);\n"
  "}\n"
  "void __file_close (Val file) {\n"
  "file_close(file.o);\n"
  "}\n"
  "void __file_copy (char *pos, Val source, Val target) {\n"
  "void copy (char *source, char *target) {\n"
  "if (file_is_directory(source)) {\n"
  "if (file_exists(target) && !file_is_directory(target))\n"
  "___built_throw(pos, (Val)str_f(\"'%s' is not a directory\", target));\n"
  "char *tdir = path_cat(target, path_base(source), NULL);\n"
  "file_del(tdir);\n"
  "file_mkdir(tdir);\n"
  "EACH(file_dir(source), char, fname) {\n"
  "copy(path_cat(source, fname, NULL), tdir);\n"
  "}_EACH\n"
  "return;\n"
  "}\n"
  "if (file_is_directory(target))\n"
  "target = path_cat(target, path_base(source), NULL);\n"
  "file_copy(source, target);\n"
  "}\n"
  "return copy(source.s, target.s);\n"
  "}\n"
  "void __file_del (Val path) {\n"
  "file_del(path.s);\n"
  "}\n"
  "Val __file_dir (Val path) {\n"
  "Val r = __arr_new();\n"
  "EACH(file_dir(path.s), char, name) {\n"
  "__arr_push(r, (Val)name);\n"
  "}_EACH\n"
  "return r;\n"
  "}\n"
  "Val __file_exists (Val path) {\n"
  "return (Val)file_exists(path.s);\n"
  "}\n"
  "Val __file_extension (Val path) {\n"
  "return (Val)path_extension(path.s);\n"
  "}\n"
  "Val __file_isDirectory (Val path) {\n"
  "return (Val)file_is_directory(path.s);\n"
  "}\n"
  "Val __file_isLink (Val path) {\n"
  "return (Val)file_is_link(path.s);\n"
  "}\n"
  "Val __file_isRegular (Val path) {\n"
  "return (Val)file_is_regular(path.s);\n"
  "}\n"
  "void __file_mkdir (Val path) {\n"
  "file_mkdir(path.s);\n"
  "}\n"
  "void __file_mklink (Val path, Val link) {\n"
  "file_link(path.s, link.s);\n"
  "}\n"
  "Val __file_parent (Val path) {\n"
  "return (Val)path_parent(path.s);\n"
  "}\n"
  "Val __file_read (Val path) {\n"
  "return (Val)file_read(path.s);\n"
  "}\n"
  "Val __file_readBin (Val file, Val buf) {\n"
  "return (Val)(void *)file_read_bin_buf(file.o, buf.i);\n"
  "}\n"
  "Val __file_readLine (Val file) {\n"
  "char *l = file_read_line(file.o);\n"
  "if (*l) {\n"
  "if (l[strlen(l) - 1] == '\\n') l = str_left(l, -1);\n"
  "return __rs_some((Val)l);\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "void __file_rename (Val old_path, Val new_path) {\n"
  "file_rename(old_path.s, new_path.s);\n"
  "}\n"
  "Val __file_ropen (Val path) {\n"
  "return (Val)(void *)file_ropen(path.s);\n"
  "}\n"
  "Val __file_size (Val path) {\n"
  "return (Val)(int64_t)file_size(path.s);\n"
  "}\n"
  "Val __file_tm (Val path) {\n"
  "return (Val)file_modified(path.s);\n"
  "}\n"
  "Val __file_tmp (Val dir, Val name) {\n"
  "return (Val)file_tmp(dir.s, name.s);\n"
  "}\n"
  "Val __file_wd (void) {\n"
  "return (Val)file_wd();\n"
  "}\n"
  "Val __file_wopen (Val path) {\n"
  "return (Val)(void *)file_wopen(path.s);\n"
  "}\n"
  "void __file_write (Val path, Val tx) {\n"
  "file_write(path.s, tx.s);\n"
  "}\n"
  "void __file_writeBin (Val file, Val bs) {\n"
  "file_write_bin(file.o, bs.o);\n"
  "}\n"
  "void __file_writeText (Val file, Val tx) {\n"
  "file_write_text(file.o, tx.s);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//iter\n"
  "// -------------------------------------\n"
  "\n"
  "Val __iter_all (Val it, Val fn) {\n"
  "int r = TRUE;\n"
  "while (__iter_hasNext(it).b) {\n"
  "Val v = __iter_next(it);\n"
  "r = r && (((Val (*)(Val))fn.o)(v)).b;\n"
  "}\n"
  "return (Val)r;\n"
  "}\n"
  "Val __iter_any (Val it, Val fn) {\n"
  "int r = FALSE;\n"
  "while (__iter_hasNext(it).b) {\n"
  "Val v = __iter_next(it);\n"
  "r = r || (((Val (*)(Val))fn.o)(v)).b;\n"
  "}\n"
  "return (Val)r;\n"
  "}\n"
  "Val __iter_cat_next (Val obj) {\n"
  "Val *p = obj.a->begin;\n"
  "if (p->b) {\n"
  "Val it = *(p+1);\n"
  "if (__iter_hasNext(it).b) return __rs_some(__iter_next(it));\n"
  "*p = (Val) FALSE;\n"
  "}\n"
  "Val it = *(p+2);\n"
  "return (__iter_hasNext(it).b) ? __rs_some(__iter_next(it)) : __arr_new();\n"
  "}\n"
  "Val __iter_cat (Val it1, Val it2) {\n"
  "Val obj = __arr_new_from_carr((Val)3, (Val[]){(Val)TRUE, it1, it2});\n"
  "return __iter_new_aux(obj, __iter_cat_next);\n"
  "}\n"
  "Val __iter_count (Val it) {\n"
  "int64_t c = 0;\n"
  "while (__iter_hasNext(it).b) {\n"
  "__iter_next(it);\n"
  "++c;\n"
  "}\n"
  "return (Val)c;\n"
  "}\n"
  "Val __iter_drop (Val it, Val n) {\n"
  "int64_t nv = n.i;\n"
  "int64_t c = 0;\n"
  "for(;;) {\n"
  "if (c >= nv || !__iter_hasNext(it).b) break;\n"
  "++c;\n"
  "__iter_next(it);\n"
  "}\n"
  "return it;\n"
  "}\n"
  "Val __iter_dropWhile (Val it, Val fn) {\n"
  "while (__iter_hasNext(it).b && (((Val (*)(Val))fn.o)(__iter_peek(it))).b)\n"
  "__iter_next(it);\n"
  "return it;\n"
  "}\n"
  "void __iter_each (Val it, Val fn) {\n"
  "while (__iter_hasNext(it).b)\n"
  "((void (*)(Val))fn.o)(__iter_next(it));\n"
  "}\n"
  "void __iter_eachIx (Val it, Val fn) {\n"
  "int64_t c = 0;\n"
  "while (__iter_hasNext(it).b)\n"
  "((void (*)(Val, Val))fn.o)(__iter_next(it), (Val)c++);\n"
  "}\n"
  "Val __iter_empty_next (Val fake) {\n"
  "return __arr_new();\n"
  "}\n"
  "Val __iter_empty (Val fake) {\n"
  "return __iter_new_aux(fake, __iter_empty_next);\n"
  "}\n"
  "Val __iter_filter_next (Val obj) {\n"
  "Val *p = obj.a->begin;\n"
  "Val it = *p;\n"
  "Val fn = *(p+1);\n"
  "while (__iter_hasNext(it).b) {\n"
  "Val r = __iter_next(it);\n"
  "if ((((Val (*)(Val))fn.o)(r)).b) return __rs_some(r);\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __iter_filter (Val it, Val fn) {\n"
  "return __iter_new_aux(\n"
  "__arr_new_from_carr((Val)2, (Val[]){it, fn}),\n"
  "__iter_filter_next\n"
  ");\n"
  "}\n"
  "Val __iter_find (Val it, Val fn) {\n"
  "while (__iter_hasNext(it).b) {\n"
  "Val r = __iter_next(it);\n"
  "if ((((Val (*)(Val))fn.o)(r)).b) return __rs_some(r);\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __iter_fromJs (Val s, Val fn) {\n"
  "return __iter_map(__arr_toIter(__js_ra(s)), fn);\n"
  "}\n"
  "Val __iter_hasNext (Val it) {\n"
  "return (Val)(__arr_size(*(it.a->begin)).i > 0);\n"
  "}\n"
  "Val __iter_index (Val it, Val fn) {\n"
  "int64_t c = 0;\n"
  "while (__iter_hasNext(it).b) {\n"
  "Val e = __iter_next(it);\n"
  "int64_t r = c++;\n"
  "if ((((Val (*)(Val))fn.o)(e)).b) return (Val)r;\n"
  "}\n"
  "return (Val)(int64_t)-1;\n"
  "}\n"
  "Val __iter_map_next (Val obj) {\n"
  "Val *p = obj.a->begin;\n"
  "Val it = *p;\n"
  "Val fn = *(p+1);\n"
  "while (__iter_hasNext(it).b)\n"
  "return __rs_some(((Val (*)(Val))fn.o)(__iter_next(it)));\n"
  "return __arr_new();\n"
  "}\n"
  "Val __iter_map (Val it, Val fn) {\n"
  "return __iter_new_aux(\n"
  "__arr_new_from_carr((Val)2, (Val[]){it, fn}),\n"
  "__iter_map_next\n"
  ");\n"
  "}\n"
  "Val __iter_next (Val it) {\n"
  "Val r = *(it.a->begin);\n"
  "if (__arr_size(r).i == 0)\n"
  "___built_throw(\"Built-in:0\", (Val)\"Iterator is empty\");\n"
  "Val tuple = *(it.a->begin + 1);\n"
  "Val *p = tuple.a->begin;\n"
  "*(it.a->begin) = ((Val (*)(Val))(*(p+1)).o)(*p);\n"
  "return *r.a->begin;\n"
  "}\n"
  "Val __iter_new (Val tuple) {\n"
  "Val *p = tuple.a->begin;\n"
  "Val a = ((Val (*)(Val))(*(p+1)).o)(*p);\n"
  "return __arr_new_from_carr((Val)2, (Val[]){a, tuple});\n"
  "}\n"
  "Val __iter_new_aux (Val obj, Val (*fn) (Val)) {\n"
  "return __iter_new(__arr_new_from_carr((Val)2, (Val[]){\n"
  "obj, (Val)(void *)fn\n"
  "}));\n"
  "}\n"
  "Val __iter_peek (Val it) {\n"
  "Val r = *(it.a->begin);\n"
  "if (__arr_size(r).i == 0)\n"
  "___built_throw(\"Built-in:0\", (Val)\"Iterator is empty\");\n"
  "return *r.a->begin;\n"
  "}\n"
  "Val __iter_range_next (Val obj) {\n"
  "Val *p = obj.a->begin;\n"
  "int64_t begin = p->i;\n"
  "int64_t end = (p+1)->i;\n"
  "int withStep = (p+3)->i;\n"
  "if (withStep) {\n"
  "int64_t step = (p+2)->i;\n"
  "if (step > 0) {\n"
  "if (begin <= end) {\n"
  "*p = (Val)(begin + step);\n"
  "return __arr_new_from_carr((Val)1, (Val[]){(Val)begin});\n"
  "}\n"
  "} else {\n"
  "if (begin >= end) {\n"
  "*p = (Val)(begin + step);\n"
  "return __arr_new_from_carr((Val)1, (Val[]){(Val)begin});\n"
  "}\n"
  "}\n"
  "} else {\n"
  "if (begin < end) {\n"
  "*p = (Val)(begin + 1);\n"
  "return __arr_new_from_carr((Val)1, (Val[]){(Val)begin});\n"
  "}\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __iter_range (char *pos, Val vs) {\n"
  "Val obj = __arr_new();\n"
  "Val *p = vs.a->begin;\n"
  "int64_t sz = __arr_size(vs).i;\n"
  "if (sz == 1) {\n"
  "__arr_push(obj, (Val) 0);\n"
  "__arr_push(obj, *p);\n"
  "__arr_push(obj, (Val) 1);\n"
  "__arr_push(obj, (Val) 0);\n"
  "} else if (sz == 2) {\n"
  "__arr_push(obj, *p++);\n"
  "__arr_push(obj, *p);\n"
  "__arr_push(obj, (Val) 1);\n"
  "__arr_push(obj, (Val) 0);\n"
  "} else {\n"
  "__arr_push(obj, *p++);\n"
  "__arr_push(obj, *p++);\n"
  "if (p->i == 0)\n"
  "___built_throw(pos, (Val)\"Range step is 0\");\n"
  "__arr_push(obj, *p);\n"
  "__arr_push(obj, (Val) 1);\n"
  "}\n"
  "return __iter_new_aux(obj, __iter_range_next);\n"
  "}\n"
  "Val __iter_reduce (Val it, Val seed, Val fn) {\n"
  "while (__iter_hasNext(it).b)\n"
  "seed = ((Val (*)(Val, Val))fn.o)(seed, __iter_next(it));\n"
  "return seed;\n"
  "}\n"
  "Val __iter_take_next (Val obj) {\n"
  "Val *p = obj.a->begin;\n"
  "Val it = *p;\n"
  "int64_t n = (p+1)->i;\n"
  "int64_t c = (p+2)->i;\n"
  "if (c < n) {\n"
  "if (__iter_hasNext(it).b) {\n"
  "*(p+2) = (Val)(c + 1);\n"
  "return __rs_some(__iter_next(it));\n"
  "}\n"
  "*(p+2) = *(p+1);\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __iter_take (Val it, Val n){\n"
  "return __iter_new_aux(\n"
  "__arr_new_from_carr((Val)3, (Val[]){it, n, (Val)0}),\n"
  "__iter_take_next\n"
  ");\n"
  "}\n"
  "Val __iter_takeWhile_next (Val obj) {\n"
  "Val *p = obj.a->begin;\n"
  "Val it = *p;\n"
  "Val fn = *(p+1);\n"
  "return __iter_hasNext(it).b && (((Val (*)(Val))fn.o)(__iter_peek(it))).b\n"
  "? __rs_some(__iter_next(it))\n"
  ": __arr_new()\n"
  ";\n"
  "}\n"
  "Val __iter_takeWhile (Val it, Val fn) {\n"
  "return __iter_new_aux(\n"
  "__arr_new_from_carr((Val)2, (Val[]){it, fn}),\n"
  "__iter_takeWhile_next\n"
  ");\n"
  "}\n"
  "Val __iter_toJs (Val it, Val fn) {\n"
  "return __js_wa(__arr_fromIter(__iter_map(it, fn)));\n"
  "}\n"
  "Val __iter_unary_next (Val obj) {\n"
  "if (__arr_size(obj).i) {\n"
  "Val r = __arr_copy(obj);\n"
  "__arr_clear(obj);\n"
  "return r;\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __iter_unary (Val value) {\n"
  "return __iter_new_aux(__rs_some(value), __iter_unary_next);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//js\n"
  "// -------------------------------------\n"
  "\n"
  "Val __js_isNull (Val json) {\n"
  "return (Val)js_is_null(json.s);\n"
  "}\n"
  "Val __js_ra (Val json) {\n"
  "return __arr_from_sarr(js_ra(json.s));\n"
  "}\n"
  "Val __js_rb (Val json) {\n"
  "return (Val)js_rb(json.s);\n"
  "}\n"
  "Val __js_rf (Val json) {\n"
  "return (Val)js_rd(json.s);\n"
  "}\n"
  "Val __js_ri (Val json) {\n"
  "return (Val)js_rl(json.s);\n"
  "}\n"
  "Val __js_ro (Val json) {\n"
  "return __dic_from_smap(js_ro(json.s));\n"
  "}\n"
  "Val __js_rs (Val json) {\n"
  "return (Val)js_rs(json.s);\n"
  "}\n"
  "Val __js_wa(Val a) {\n"
  "return (Val)js_wa(__arr_to_sarr(a));\n"
  "}\n"
  "Val __js_wb(Val value) {\n"
  "return (Val)js_wb(value.b);\n"
  "}\n"
  "Val __js_wf(Val n) {\n"
  "return (Val)math_ftos(n.f, 9);\n"
  "}\n"
  "Val __js_wf2(Val n, Val dec) {\n"
  "return (Val)math_ftos(n.f, dec.i);\n"
  "}\n"
  "Val __js_wi(Val n) {\n"
  "return (Val)math_itos(n.i);\n"
  "}\n"
  "Val __js_wn(void) {\n"
  "return (Val)js_wn();\n"
  "}\n"
  "Val __js_wo(Val m) {\n"
  "return (Val)js_wo(__dic_to_smap(m));\n"
  "}\n"
  "Val __js_ws(Val s) {\n"
  "return (Val)js_ws(s.s);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//math\n"
  "// -------------------------------------\n"
  "\n"
  "Val __math_abs (Val n) {\n"
  "return (Val)math_abs(n.f);\n"
  "}\n"
  "Val __math_acos (Val n) {\n"
  "return (Val)acos(n.f);\n"
  "}\n"
  "Val __math_acosh (Val n) {\n"
  "return (Val)acosh(n.f);\n"
  "}\n"
  "Val __math_asin (Val n) {\n"
  "return (Val)asin(n.f);\n"
  "}\n"
  "Val __math_asinh (Val n) {\n"
  "return (Val)asinh(n.f);\n"
  "}\n"
  "Val __math_atan (Val n) {\n"
  "return (Val)atan(n.f);\n"
  "}\n"
  "Val __math_atanh (Val n) {\n"
  "return (Val)atanh(n.f);\n"
  "}\n"
  "Val __math_ceil (Val n) {\n"
  "return (Val)ceil(n.f);\n"
  "}\n"
  "Val __math_cos (Val n) {\n"
  "return (Val)cos(n.f);\n"
  "}\n"
  "Val __math_cosh (Val n) {\n"
  "return (Val)cosh(n.f);\n"
  "}\n"
  "Val __math_e (void) {\n"
  "return (Val)M_E;\n"
  "}\n"
  "Val __math_eq (Val n1, Val n2, Val gap) {\n"
  "return (Val)math_eq_gap(n1.f, n2.f, gap.f);\n"
  "}\n"
  "Val __math_exp (Val n) {\n"
  "return (Val)exp(n.f);\n"
  "}\n"
  "Val __math_exp2 (Val n) {\n"
  "return (Val)exp2(n.f);\n"
  "}\n"
  "Val __math_floor (Val n) {\n"
  "return (Val)floor(n.f);\n"
  "}\n"
  "Val __math_fromEn (Val s) {\n"
  "return __math_stof((Val)str_replace(s.s, \",\", \"\"));\n"
  "}\n"
  "Val __math_fromHex (Val s) {\n"
  "char *n = str_trim(s.s);\n"
  "if (!*n) return __arr_new();\n"
  "char *tmp;\n"
  "int64_t r = strtol(n, &tmp, 16);\n"
  "if (*tmp) return __arr_new();\n"
  "return __rs_some((Val)r);\n"
  "}\n"
  "Val __math_fromIso (Val s) {\n"
  "return __math_stof((Val)str_replace(str_replace(s.s, \".\", \"\"), \",\", \".\"));\n"
  "}\n"
  "Val __math_ftoi (Val n) {\n"
  "return (Val)(int64_t)(n.f);\n"
  "}\n"
  "Val __math_ftos (Val n) {\n"
  "return (Val)math_ftos(n.f, 9);\n"
  "}\n"
  "Val __math_ftos2 (Val n, Val dec) {\n"
  "return (Val)math_ftos(n.f, dec.i);\n"
  "}\n"
  "Val __math_isDigits (Val n) {\n"
  "return (Val)math_digits(n.s);\n"
  "}\n"
  "Val __math_itof (Val n) {\n"
  "return (Val)(double)(n.i);\n"
  "}\n"
  "Val __math_itoh (Val n) {\n"
  "return (Val)str_f(\"%x\", n.i);\n"
  "}\n"
  "Val __math_itos (Val n) {\n"
  "return (Val)math_itos(n.i);\n"
  "}\n"
  "Val __math_log (Val n) {\n"
  "return (Val)log(n.f);\n"
  "}\n"
  "Val __math_log10 (Val n) {\n"
  "return (Val)log10(n.f);\n"
  "}\n"
  "Val __math_log2 (Val n) {\n"
  "return (Val)log2(n.f);\n"
  "}\n"
  "Val __math_max (Val n1, Val n2) {\n"
  "return n1.f >= n2.f ? n1 : n2;\n"
  "}\n"
  "Val __math_maxFloat (void) {\n"
  "return (Val)DBL_MAX;\n"
  "}\n"
  "Val __math_maxInt (void) {\n"
  "return (Val)(int64_t)\n"
  "(sizeof(int64_t) == sizeof(long long int) ? LLONG_MAX : LONG_MAX);\n"
  "}\n"
  "Val __math_min (Val n1, Val n2) {\n"
  "return n1.f <= n2.f ? n1 : n2;\n"
  "}\n"
  "Val __math_minInt (void) {\n"
  "return (Val)(int64_t)\n"
  "(sizeof(int64_t) == sizeof(long long int) ? LLONG_MIN : LONG_MIN);\n"
  "}\n"
  "Val __math_pi (void) {\n"
  "return (Val)M_PI;\n"
  "}\n"
  "Val __math_pow (Val base, Val exp) {\n"
  "return (Val)pow(base.f, exp.f);\n"
  "}\n"
  "Val __math_pow10 (Val exp) {\n"
  "int64_t n = exp.i;\n"
  "double r = 1;\n"
  "double mul = n > 0 ? 10 : 0.1;\n"
  "n = n >= 0 ? n : -n;\n"
  "REPEAT(n) {\n"
  "r *= mul;\n"
  "}_REPEAT\n"
  "return (Val)r;\n"
  "}\n"
  "Val __math_rnd (void) {\n"
  "return (Val)((double)rand() / (double)RAND_MAX);\n"
  "}\n"
  "Val __math_rndi (Val top) {\n"
  "return (Val)(int64_t)(((double)rand() / (double)RAND_MAX) * top.i);\n"
  "}\n"
  "Val __math_round (Val n, Val dec) {\n"
  "return (Val)math_round(n.f, dec.i);\n"
  "}\n"
  "Val __math_sin (Val n) {\n"
  "return (Val)sin(n.f);\n"
  "}\n"
  "Val __math_sinh (Val n) {\n"
  "return (Val)sinh(n.f);\n"
  "}\n"
  "Val __math_sqrt (Val n) {\n"
  "return (Val)sqrt(n.f);\n"
  "}\n"
  "Val __math_stof (Val s) {\n"
  "char *n = str_trim(s.s);\n"
  "if (!*n) return __arr_new();\n"
  "struct lconv *lc = localeconv();\n"
  "int ix = str_cindex(n, '.');\n"
  "if (ix != -1) n[ix] = *lc->decimal_point;\n"
  "char *tmp;\n"
  "double r = strtod(n, &tmp);\n"
  "if (*tmp) return __arr_new();\n"
  "return __rs_some((Val)r);\n"
  "}\n"
  "Val __math_stoi (Val s) {\n"
  "char *n = str_trim(s.s);\n"
  "if (!*n) return __arr_new();\n"
  "char *tmp;\n"
  "int64_t r = strtol(n, &tmp, 10);\n"
  "if (*tmp) return __arr_new();\n"
  "return __rs_some((Val)r);\n"
  "}\n"
  "Val __math_tan (Val n) {\n"
  "return (Val)tan(n.f);\n"
  "}\n"
  "Val __math_tanh (Val n) {\n"
  "return (Val)tanh(n.f);\n"
  "}\n"
  "Val __math_trunc (Val n) {\n"
  "return (Val)trunc(n.f);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//regex\n"
  "// -------------------------------------\n"
  "\n"
  "Val __regex_matches (char *pos, Val s, Val rg) {\n"
  "char *ss = s.s;\n"
  "Arr *ms = opt_get(regex_matches(rg.s, ss));\n"
  "if (!ms)\n"
  "___built_throw(pos, (Val)str_f(\"Fail compiling regular expression:\\n%s\", rg));\n"
  "Val r = __arr_new();\n"
  "int ix = 0;\n"
  "EACH(ms, RegexOffset, of) {\n"
  "int begin = regexOffset_begin(of);\n"
  "int end = regexOffset_end(of);\n"
  "__arr_push(r, (Val)str_sub(ss, ix, begin));\n"
  "__arr_push(r, (Val)str_sub(ss, begin, end));\n"
  "ix = end;\n"
  "}_EACH\n"
  "__arr_push(r, (Val)str_right(ss, ix));\n"
  "return r;\n"
  "}\n"
  "Val __regex_replace (char *pos, Val s, Val rg, Val repl) {\n"
  "char *r = opt_get(regex_replace(rg.s, s.s, repl.s));\n"
  "if (r) return (Val)r;\n"
  "___built_throw(pos, (Val)str_f(\"Fail of regular expression:\\n%s\", rg));\n"
  "return (Val)0; // Unreachable\n"
  "}\n"
  "Val __regex_replacef (char *pos, Val s, Val rg, Val frpl) {\n"
  "char *fn(char *match) {\n"
  "return (((Val (*)(Val))frpl.o)((Val)match)).s;\n"
  "}\n"
  "char *r = opt_get(regex_replacef(rg.s, s.s, fn));\n"
  "if (r) return (Val)r;\n"
  "___built_throw(pos, (Val)str_f(\"Fail of regular expression:\\n%s\", rg));\n"
  "return (Val)0; // Unreachable\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//rs\n"
  "// -------------------------------------\n"
  "\n"
  "Val __rs_some (Val v) {\n"
  "return __arr_new_from_carr((Val) 1, (Val[]){v});\n"
  "}\n"
  "Val __rs_ok (Val v) {\n"
  "return __arr_new_from_carr((Val) 2, (Val[]){__rs_some(v), (Val)\"\"});\n"
  "}\n"
  "Val __rs_fail (Val v) {\n"
  "return __arr_new_from_carr((Val) 2, (Val[]){__arr_new(), v});\n"
  "}\n"
  "Val __rs_get (Val rs) {\n"
  "return *((*rs.a->begin).a->begin);\n"
  "}\n"
  "Val __rs_error (Val rs) {\n"
  "return rs.a->begin[1];\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//str\n"
  "// -------------------------------------\n"
  "\n"
  "Val __str_cmp (Val s1, Val s2) {\n"
  "return (Val)(int64_t)strcoll(s1.s, s2.s);\n"
  "}\n"
  "Val __str_ends (Val str, Val substr) {\n"
  "return (Val)str_ends(str.s, substr.s);\n"
  "}\n"
  "Val __str_fmt (char *pos, Val format, Val args) {\n"
  "char *fmt = format.s;\n"
  "Varr *as = args.a;\n"
  "Arr *pts = arr_new();\n"
  "Buf *bf = buf_new();\n"
  "char *p = fmt;\n"
  "while (*p) {\n"
  "char ch = *p++;\n"
  "if (ch == '%') {\n"
  "ch = *p;\n"
  "if (ch == 'v') {\n"
  "++p;\n"
  "arr_push(pts, buf_str(bf));\n"
  "bf = buf_new();\n"
  "continue;\n"
  "}\n"
  "if (ch == '%') ++p;\n"
  "}\n"
  "buf_cadd(bf, ch);\n"
  "}\n"
  "arr_push(pts, buf_str(bf));\n"
  "if (arr_size(pts) != __arr_size(args).i + 1)\n"
  "___built_throw(pos, (Val)str_f(\n"
  "\"Wrong arguments number (expected %d, fund %d)\",\n"
  "arr_size(pts) - 1, __arr_size(args).i\n"
  "));\n"
  "Arr *rs = arr_new();\n"
  "void **ps = arr_begin(pts);\n"
  "arr_push(rs, *ps++);\n"
  "Val *pas = as->begin;\n"
  "Val *pend = as->end;\n"
  "while (pas < pend) {\n"
  "arr_push(rs, pas++->s);\n"
  "arr_push(rs, *ps++);\n"
  "}\n"
  "return (Val)arr_join(rs, \"\");\n"
  "}\n"
  "Val __str_fromIso (Val s) {\n"
  "return (Val)str_from_iso(s.s);\n"
  "}\n"
  "Val __str_fromRunes (Val a) {\n"
  "return __arr_join(a, (Val)\"\");\n"
  "}\n"
  "Val __str_fromUtf16 (Val codepoints) {\n"
  "int64_t sz = __arr_size(codepoints).i;\n"
  "unsigned *u = ATOMIC(sizeof(unsigned) * (sz + 1));\n"
  "Val *p = codepoints.a->begin;\n"
  "Val *end = codepoints.a->end;\n"
  "unsigned *pu = u;\n"
  "while (p < end) *pu++ = (unsigned)(*p++).i;\n"
  "*pu = 0;\n"
  "return (Val)str_from_unicode(u);\n"
  "};\n"
  "Val __str_get(char *pos, Val s, Val ix) {\n"
  "if (ix.i < 0 || ix.i >= strlen(s.s))\n"
  "___built_throw(pos, (Val)str_f(\"Index %d out of [0,%d]\", ix.i, strlen(s.s) - 1));\n"
  "return (Val)str_new_c(s.s[ix.i]);\n"
  "}\n"
  "Val __str_index(Val str, Val substr) {\n"
  "return (Val)(int64_t)str_index(str.s, substr.s);\n"
  "}\n"
  "Val __str_indexFrom (Val str, Val substr, Val start) {\n"
  "return (Val)(int64_t)str_index_from(str.s, substr.s, start.i);\n"
  "}\n"
  "Val __str_lastIndex (Val str, Val substr) {\n"
  "return (Val)(int64_t)str_last_index(str.s, substr.s);\n"
  "}\n"
  "Val __str_left (Val str, Val end) {\n"
  "Val r = __str_toRunes(str);\n"
  "int64_t sz = __arr_size(r).i;\n"
  "end = end.i < 0 ? (Val)(sz + end.i) : end;\n"
  "return __arr_join(__arr_take(r, end), (Val)\"\");\n"
  "}\n"
  "Val __str_left_slice(Val str, Val begin) {\n"
  "return (Val)str_left(str.s, begin.i);\n"
  "}\n"
  "Val __str_len (Val str) {\n"
  "return (Val)(int64_t)strlen(str.s);\n"
  "}\n"
  "Val __str_ltrim (Val str) {\n"
  "return (Val)str_ltrim(str.s);\n"
  "}\n"
  "Val __str_replace (Val s, Val old, Val new) {\n"
  "return (Val)str_replace(s.s, old.s, new.s);\n"
  "}\n"
  "Val __str_right (Val str, Val begin) {\n"
  "Val r = __str_toRunes(str);\n"
  "int64_t sz = __arr_size(r).i;\n"
  "begin = begin.i < 0 ? (Val)(sz + begin.i) : begin;\n"
  "return __arr_join(__arr_drop(r, begin), (Val)\"\");\n"
  "}\n"
  "Val __str_right_slice(Val str, Val begin) {\n"
  "return (Val)str_right(str.s, begin.i);\n"
  "}\n"
  "Val __str_rtrim (Val str) {\n"
  "return (Val)str_rtrim(str.s);\n"
  "}\n"
  "Val __str_split (Val str, Val sep) {\n"
  "char *s = str.s;\n"
  "char *ssep = sep.s;\n"
  "Val r = __arr_new();\n"
  "int len = strlen(ssep);\n"
  "if (!len) {\n"
  "char *rune;\n"
  "s = str_next_rune(&rune, s);\n"
  "while (*rune) {\n"
  "__arr_push(r, (Val)rune);\n"
  "s = str_next_rune(&rune, s);\n"
  "}\n"
  "return r;\n"
  "}\n"
  "if (len == 1) {\n"
  "char csep = *ssep;\n"
  "int i = str_cindex(s, csep);\n"
  "while (i != -1) {\n"
  "char *sub = ATOMIC(i + 1);\n"
  "sub[i] = 0;\n"
  "memcpy(sub, s, i);\n"
  "__arr_push(r, (Val)sub);\n"
  "s = s + i + len;\n"
  "i = str_cindex(s, csep);\n"
  "}\n"
  "__arr_push(r, (Val)str_new(s));\n"
  "return r;\n"
  "}\n"
  "int i = str_index(s, ssep);\n"
  "while (i != -1) {\n"
  "char *sub = ATOMIC(i + 1);\n"
  "sub[i] = 0;\n"
  "memcpy(sub, s, i);\n"
  "__arr_push(r, (Val)sub);\n"
  "s = s + i + len;\n"
  "i = str_index(s, ssep);\n"
  "}\n"
  "__arr_push(r, (Val)str_new(s));\n"
  "return r;\n"
  "}\n"
  "Val __str_splitTrim (Val str, Val sep) {\n"
  "Val r = __str_split(str, sep);\n"
  "Val *p = r.a->begin;\n"
  "Val *end = r.a->end;\n"
  "while (p < end) {\n"
  "*p = __str_trim(*p);\n"
  "++p;\n"
  "}\n"
  "return r;\n"
  "}\n"
  "Val __str_starts(Val str, Val substr) {\n"
  "return (Val)str_starts(str.s, substr.s);\n"
  "}\n"
  "Val __str_sub (Val str, Val begin, Val end) {\n"
  "Val r = __str_toRunes(str);\n"
  "int64_t sz = __arr_size(r).i;\n"
  "begin = begin.i < 0 ? (Val)(sz + begin.i) : begin;\n"
  "end = end.i < 0 ? (Val)(sz + end.i) : end;\n"
  "return __arr_join(__arr_drop(__arr_take(r, end), begin), (Val)\"\");\n"
  "}\n"
  "Val __str_sub_slice(Val str, Val begin, Val end) {\n"
  "return (Val)str_sub(str.s, begin.i, end.i);\n"
  "}\n"
  "Val __str_toLower(Val s) {\n"
  "return (Val)str_to_lower(s.s);\n"
  "}\n"
  "Val __str_toUpper(Val s) {\n"
  "return (Val)str_to_upper(s.s);\n"
  "}\n"
  "Val __str_toRunes (Val str) {\n"
  "char *s = str.s;\n"
  "Val r = __arr_new();\n"
  "char *rune;\n"
  "s = str_next_rune(&rune, s);\n"
  "while (*rune) {\n"
  "__arr_push(r, (Val)rune);\n"
  "s = str_next_rune(&rune, s);\n"
  "}\n"
  "return r;\n"
  "}\n"
  "Val __str_toUtf16 (Val str) {\n"
  "unsigned *u = str_to_unicode(str.s);\n"
  "Val a = __arr_new();\n"
  "unsigned *pu = u;\n"
  "while (*pu) __arr_push(a, (Val)(int64_t)*pu++);\n"
  "return a;\n"
  "}\n"
  "Val __str_trim (Val str) {\n"
  "return (Val)str_trim(str.s);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//sys\n"
  "// -------------------------------------\n"
  "\n"
  "static Val __sys_compiler_root_v = (Val) \"\";\n"
  "static Val __sys_mainPath_v = (Val) \"\";\n"
  "static Val __sys_args_v = (Val) \"\";\n"
  "static void __sys_shandler (int sig) {\n"
  "___built_throw(\"built-in:0\", (Val)\"Arithmetic exception\");\n"
  "}\n"
  "static void __sys_sshandler (int sig) {\n"
  "___built_throw(\"built-in:0\", (Val)\"Segmentation violation\");\n"
  "}\n"
  "void __sys_init(int argc, char **argv, char *compiler_root) {\n"
  "sys_init();\n"
  "signal (SIGFPE, __sys_shandler);\n"
  "signal (SIGSEGV, __sys_sshandler);\n"
  "__sys_compiler_root_v = (Val)compiler_root;\n"
  "__sys_mainPath_v = (Val)*argv;\n"
  "__sys_args_v = __arr_new();\n"
  "for (int i = 1; i < argc; ++i) __arr_push(__sys_args_v, (Val)argv[i]);\n"
  "}\n"
  "Val __sys_args (void) {\n"
  "return __arr_copy(__sys_args_v);\n"
  "}\n"
  "Val __sys_cmd (Val command, Val args) {\n"
  "Val rs = __sys_cmd2(command, args);\n"
  "Val *ok = rs.a->begin;\n"
  "Val *err = ok + 1;\n"
  "Val r = __arr_new();\n"
  "if (*(err->s)) __arr_push(r, __arr_new());\n"
  "else __arr_push(r, __rs_some(*ok));\n"
  "__arr_push(r, *err);\n"
  "return r;\n"
  "}\n"
  "Val __sys_cmd2 (Val command, Val args) {\n"
  "Arr *acmd = arr_new();\n"
  "arr_push(acmd, command.s);\n"
  "Val *p = args.a->begin;\n"
  "Val *end = args.a->end;\n"
  "while (p < end) arr_push(acmd, str_to_escape((*p++).s));\n"
  "Tp *tp = sys_cmd2(arr_cjoin(acmd, ' '));\n"
  "Val r = __arr_new();\n"
  "__arr_push(r, (Val)tp->e1);\n"
  "__arr_push(r, (Val)tp->e2);\n"
  "return r;\n"
  "}\n"
  "Val __sys_compilerRoot (void) {\n"
  "return __sys_compiler_root_v;\n"
  "}\n"
  "Val __sys_environ (void) {\n"
  "return __dic_from_smap(sys_environ());\n"
  "}\n"
  "void __sys_exit (Val code) {\n"
  "exit(code.i);\n"
  "}\n"
  "Val __sys_exec (char *pos, Val command, Val args) {\n"
  "Arr *acmd = arr_new();\n"
  "arr_push(acmd, command.s);\n"
  "Val *p = args.a->begin;\n"
  "Val *end = args.a->end;\n"
  "while (p < end) arr_push(acmd, str_to_escape((*p++).s));\n"
  "return (Val)(int64_t)system(arr_cjoin(acmd, ' '));\n"
  "}\n"
  "Val __sys_getLocale (void) {\n"
  "return (Val)sys_get_locale();\n"
  "}\n"
  "Val __sys_home (void) {\n"
  "return (Val)sys_user_home();\n"
  "}\n"
  "Val __sys_mainPath (void) {\n"
  "return __sys_mainPath_v;\n"
  "}\n"
  "Val __sys_pid (void) {\n"
  "return (Val)getpid();\n"
  "}\n"
  "void __sys_printError (Val text) {\n"
  "fprintf(stderr, \"%s\", text.s);\n"
  "}\n"
  "Val __sys_readLine (void) {\n"
  "return (Val)sys_read_line();\n"
  "}\n"
  "void __sys_setLocale (Val charset) {\n"
  "return sys_set_locale(charset.s);\n"
  "}\n"
  "void __sys_sleep (Val millis) {\n"
  "sys_sleep(millis.i);\n"
  "}\n"
  "Val __sys_user (void) {\n"
  "return (Val)sys_user_name();\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//tcp\n"
  "// -------------------------------------\n"
  "\n"
  "Val __tcp_accept (Val server) {\n"
  "Rs *rs = tcp_accept(server.o);\n"
  "void *conn = rs_get(rs);\n"
  "if (!conn) return __rs_fail((Val)rs_error(rs));\n"
  "return __rs_ok((Val)conn);\n"
  "}\n"
  "void __tcp_closeConnection (Val conn) {\n"
  "tcp_close_conn(conn.o);\n"
  "}\n"
  "void __tcp_closeServer (Val server) {\n"
  "tcp_close_server(server.o);\n"
  "}\n"
  "Val __tcp_dial (Val server_name) {\n"
  "char *sv = server_name.s;\n"
  "int ok = TRUE;\n"
  "Arr *ps = str_csplit(sv, ':');\n"
  "if (arr_size(ps) != 2) ok = FALSE;\n"
  "if (ok && !math_digits(arr_get(ps, 1))) ok = FALSE;\n"
  "if (!ok)\n"
  "return __rs_fail((Val)str_f(\"Bad sever:port (%s)\", sv));\n"
  "Rs *rs = tcp_dial(arr_get(ps, 0), math_stoi(arr_get(ps, 1)));\n"
  "void *conn = rs_get(rs);\n"
  "if (!conn) return __rs_fail((Val)rs_error(rs));\n"
  "return __rs_ok((Val)conn);\n"
  "}\n"
  "Val __tcp_read (Val conn, Val lim, Val seconds) {\n"
  "Rs *rs = tcp_read(conn.o, lim.i, seconds.i);\n"
  "void *bs = rs_get(rs);\n"
  "if (!bs) return __rs_fail((Val)rs_error(rs));\n"
  "return __rs_ok((Val)bs);\n"
  "}\n"
  "Val __tcp_server (Val port, Val nconns) {\n"
  "return (Val)(void *)tcp_server(port.i, nconns.i);\n"
  "}\n"
  "Val __tcp_write (Val conn, Val data) {\n"
  "return (Val)tcp_write(conn.o, data.o);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//thread\n"
  "// -------------------------------------\n"
  "\n"
  "void __thread_join (Val th) {\n"
  "thread_join(th.o);\n"
  "}\n"
  "void __thread_run (Val fn) {\n"
  "thread_run ((void (*)(void))fn.o);\n"
  "}\n"
  "Val __thread_start (Val fn) {\n"
  "return (Val)(void *)thread_start((void (*)(void))fn.o);\n"
  "}\n"
  "void __thread_sync (Val fn) {\n"
  "thread_sync ((void (*)(void))fn.o);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//time\n"
  "// -------------------------------------\n"
  "\n"
  "Val __time_addDays (Val tm, Val days) {\n"
  "return (Val)time_add(tm.i, (int)days.i);\n"
  "}\n"
  "Val __time_day (Val tm) {\n"
  "return (Val)(int64_t)time_day(tm.i);\n"
  "}\n"
  "Val __time_dfDays (Val tm1, Val tm2) {\n"
  "return (Val)(int64_t)time_df(tm1.i, tm2.i);\n"
  "}\n"
  "Val __time_eqDay (Val tm1, Val tm2) {\n"
  "return (Val)time_eq(tm1.i, tm2.i);\n"
  "}\n"
  "Val __time_fmt (Val tm_val, Val template) {\n"
  "char *time_fmt (int64_t tm, char *template) {\n"
  "char *s, *rs;\n"
  "time_t tthis = (time_t)(tm / 1000);\n"
  "struct tm *t = localtime(&tthis);\n"
  "int size = 126;\n"
  "while (1) {\n"
  "rs = (char *)calloc(size, 1); // calloc ok\n"
  "if (strftime (rs, size, template, t)) {\n"
  "s = str_new(rs);\n"
  "free(rs); // free ok\n"
  "break;\n"
  "}\n"
  "free(rs); // free ok\n"
  "size += size;\n"
  "}\n"
  "return s;\n"
  "}\n"
  "int64_t tm = tm_val.i;\n"
  "char *s = template.s;\n"
  "int len = strlen(s);\n"
  "int p = 0;\n"
  "Buf *r = buf_new();\n"
  "for (;;) {\n"
  "int i = str_cindex_from(s, '%', p);\n"
  "if (i == -1) break;\n"
  "buf_add(r, str_sub(s, p, i));\n"
  "++i;\n"
  "if (i == len)\n"
  "___built_throw(\n"
  "\"built-in(time.fmt):0\",\n"
  "(Val)\"Bad '%' sequence at end of string\"\n"
  ");\n"
  "char ch = s[i];\n"
  "if (ch == '%') {\n"
  "buf_cadd(r, ch);\n"
  "p = i + 1;\n"
  "continue;\n"
  "}\n"
  "if (\n"
  "ch == 'd' || ch == 'D' || ch == 'm' || ch == 'M' || ch == 'y' ||\n"
  "ch == 'Y' || ch == 't' || ch == 'T'\n"
  ") {\n"
  "switch (ch) {\n"
  "case 'd' :\n"
  "buf_add(r, str_ltrim(time_fmt(tm, \"%e\")));\n"
  "break;\n"
  "case 'D':\n"
  "buf_add(r, time_fmt(tm, \"%d\"));\n"
  "break;\n"
  "case 'm': {\n"
  "char *v = time_fmt(tm, \"%m\");\n"
  "if (*v == '0') v = v + 1;\n"
  "buf_add(r, v);\n"
  "break;\n"
  "}\n"
  "case 'M':\n"
  "buf_add(r, time_fmt(tm, \"%m\"));\n"
  "break;\n"
  "case 'y':\n"
  "buf_add(r, time_fmt(tm, \"%y\"));\n"
  "break;\n"
  "case 'Y':\n"
  "buf_add(r, time_fmt(tm, \"%Y\"));\n"
  "break;\n"
  "case 't':\n"
  "buf_add(r, time_fmt(tm, \"%T\"));\n"
  "break;\n"
  "default: { // 'T'\n"
  "char *millis = str_f(\"%ld\", tm % 1000);\n"
  "buf_add(r, str_f(\"%s.%s\", time_fmt(tm, \"%T\"), millis));\n"
  "}\n"
  "}\n"
  "p = i + 1;\n"
  "continue;\n"
  "}\n"
  "___built_throw(\"built-in(time.fmt):0\", (Val)\"Bad '%' sequence\");\n"
  "}\n"
  "buf_add(r, str_right(s, p));\n"
  "return (Val)str_new(buf_str(r));\n"
  "}\n"
  "Val __time_fromClock (Val tm, Val template) {\n"
  "int to_time_number (char *n, int max) {\n"
  "if (strlen(n) != 2) return -1;\n"
  "if (!math_digits(n)) return -1;\n"
  "int nn = math_stoi(n);\n"
  "if (nn >= max) return -1;\n"
  "return nn;\n"
  "}\n"
  "char *tms = template.s;\n"
  "Arr *ps = str_csplit(tms, ':');\n"
  "if (arr_size(ps) == 3) {\n"
  "int h = to_time_number(arr_get(ps, 0), 24);\n"
  "if (h != 1) {\n"
  "int m = to_time_number(arr_get(ps, 1), 60);\n"
  "if (m != -1) {\n"
  "int s = to_time_number(arr_get(ps, 2), 60);\n"
  "if (s != -1) {\n"
  "return __rs_some(__time_new(\n"
  "__time_day(tm), __time_month(tm), __time_year(tm),\n"
  "(Val)(int64_t)h, (Val)(int64_t)m, (Val)(int64_t)s\n"
  "));\n"
  "}\n"
  "}\n"
  "}\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __time_from_str_op_aux(char *date) {\n"
  "if (strlen(date) != 8 && !math_digits(date)) return __arr_new();\n"
  "char tpl[5];\n"
  "memset (tpl, 0, 5);\n"
  "memcpy(tpl, date + 6, 2);\n"
  "int d = atoi(tpl);\n"
  "memcpy(tpl, date + 4, 2);\n"
  "int m = atoi(tpl);\n"
  "memcpy(tpl, date, 4);\n"
  "int y = atoi(tpl);\n"
  "return __rs_some(__time_newDate(\n"
  "(Val)(int64_t)d, (Val)(int64_t)m, (Val)(int64_t)y\n"
  "));\n"
  "}\n"
  "Val __time_from_iso_en_op (int is_iso, char *date, char sep) {\n"
  "Arr *parts = str_csplit(date, sep);\n"
  "if (arr_size(parts) == 3) {\n"
  "char *d = arr_get(parts, (is_iso) ? 0 : 1);\n"
  "char *m = arr_get(parts, (is_iso) ? 1 : 0);\n"
  "char *y = arr_get(parts, 2);\n"
  "if (strlen(d) == 1) d = str_f(\"%s%s\", \"0\", d);\n"
  "if (strlen(m) == 1) m = str_f(\"%s%s\", \"0\", m);\n"
  "if (strlen(y) == 2) y = str_f(\"%s%s\", \"20\", y);\n"
  "if (strlen(d) == 2 && strlen(m) == 2 && strlen(y) == 4)\n"
  "return __time_from_str_op_aux(str_f(\"%s%s%s\", y, m, d));\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __time_fromEn (Val s, Val sep) {\n"
  "return __time_from_iso_en_op(FALSE, s.s, *sep.s);\n"
  "}\n"
  "Val __time_fromIso (Val s, Val sep) {\n"
  "return __time_from_iso_en_op(TRUE, s.s, *sep.s);\n"
  "}\n"
  "Val __time_fromStr (Val s) {\n"
  "return __time_from_str_op_aux(s.s);\n"
  "}\n"
  "Val __time_hour (Val tm) {\n"
  "return (Val)(int64_t)time_hour(tm.i);\n"
  "}\n"
  "Val __time_millisecond (Val tm) {\n"
  "return (Val)(int64_t)time_millisecond(tm.i);\n"
  "}\n"
  "Val __time_minute (Val tm) {\n"
  "return (Val)(int64_t)time_minute(tm.i);\n"
  "}\n"
  "Val __time_month (Val tm) {\n"
  "return (Val)(int64_t)(time_month(tm.i) + 1);\n"
  "}\n"
  "Val __time_new (Val day, Val month, Val year, Val hour, Val minute, Val second) {\n"
  "return (Val)time_new_time(\n"
  "(int)day.i, (int)(month.i - 1), (int)year.i,\n"
  "(int)hour.i, (int)minute.i, (int)second.i\n"
  ");\n"
  "}\n"
  "Val __time_newDate (Val day, Val month, Val year) {\n"
  "return (Val)time_new((int)day.i, (int)(month.i - 1), (int)year.i);\n"
  "}\n"
  "Val __time_now (void) {\n"
  "return (Val)time_now();\n"
  "}\n"
  "Val __time_second (Val tm) {\n"
  "return (Val)(int64_t)time_second(tm.i);\n"
  "}\n"
  "Val __time_toEn (Val tm) {\n"
  "return (Val)time_to_us(tm.i);\n"
  "}\n"
  "Val __time_toIso (Val tm) {\n"
  "return (Val)time_to_iso(tm.i);\n"
  "}\n"
  "Val __time_toStr (Val tm) {\n"
  "return (Val)time_to_str(tm.i);\n"
  "}\n"
  "Val __time_weekday (Val tm) {\n"
  "return (Val)(int64_t)time_week_day(tm.i);\n"
  "}\n"
  "Val __time_year (Val tm) {\n"
  "return (Val)(int64_t)time_year(tm.i);\n"
  "}\n"
  "Val __time_yearDay (Val tm) {\n"
  "return (Val)(int64_t)(time_year_day(tm.i) + 1);\n"
  "}\n"
  "\n"
  "\n"
;
}
