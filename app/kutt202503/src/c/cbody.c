// Code generated by mkBuiltC.

#include "c/cheader.h"

char *cbody_code (void) {
  return ""
  "#include \"built.h\"\n"
"\n"
  "//\n"
  "// thread.c ---------------------------------\n"
  "//\n"
  "// Copyright 21-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "static pthread_mutex_t thread_mutex;\n"
  "static pthread_t *thread_in = NULL;\n"
  "\n"
  "struct thread_Thread {\n"
  "  void (*fn) (void *);\n"
  "  void *value;\n"
  "};\n"
  "\n"
  "static struct thread_Thread *thread_thread_new (\n"
  "  void (*fn) (void *), void *value\n"
  ") {\n"
  "  struct thread_Thread *this = MALLOC(struct thread_Thread);\n"
  "  this->fn = fn;\n"
  "  this->value = value;\n"
  "  return this;\n"
  "}\n"
  "\n"
  "static void *thread_thread_run (struct thread_Thread *data) {\n"
  "  exc_thread_init();\n"
  "  data->fn(data->value);\n"
  "  exc_thread_end();\n"
  "  return NULL;\n"
  "}\n"
  "\n"
  "static void *thread_thread_run0 (void (*fn)(void)) {\n"
  "  exc_thread_init();\n"
  "  fn();\n"
  "  exc_thread_end();\n"
  "  return NULL;\n"
  "}\n"
  "\n"
  "pthread_t *thread_start (void (*fn)(void)) {\n"
  "  pthread_t *thr = MALLOC(pthread_t);\n"
  "  int err = pthread_create(thr, NULL, (void *(*)(void *))thread_thread_run0, fn);\n"
  "  if (err != 0)\n"
  "    EXC_GENERIC(str_f(\"Fail starting thread: %s\", strerror(err)));\n"
  "  return thr;\n"
  "}\n"
  "\n"
  "pthread_t *thread_start2 (void (*fn)(void *), void *value) {\n"
  "  pthread_t *thr = MALLOC(pthread_t);\n"
  "  struct thread_Thread *data = thread_thread_new(fn, value);\n"
  "  int err = pthread_create(thr, NULL, (void *(*)(void *))thread_thread_run, data);\n"
  "  if (err != 0)\n"
  "    EXC_GENERIC(str_f(\"Fail starting thread: %s\", strerror(err)));\n"
  "  return thr;\n"
  "}\n"
  "\n"
  "void thread_run (void (*fn)(void)) {\n"
  "  pthread_attr_t attr;\n"
  "  pthread_attr_init(&attr);\n"
  "  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n"
  "\n"
  "  pthread_t *thr = MALLOC(pthread_t);\n"
  "  int err = pthread_create(thr, &attr, (void *(*)(void *))thread_thread_run0, fn);\n"
  "  if (err != 0)\n"
  "    EXC_GENERIC(str_f(\"Fail running thread: %s\", strerror(err)));\n"
  "}\n"
  "\n"
  "void thread_run2 (void (*fn)(void *), void *value) {\n"
  "  pthread_attr_t attr;\n"
  "  pthread_attr_init(&attr);\n"
  "  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n"
  "\n"
  "  pthread_t *thr = MALLOC(pthread_t);\n"
  "  struct thread_Thread *data = thread_thread_new(fn, value);\n"
  "  int err = pthread_create(thr, &attr, (void *(*)(void *))thread_thread_run, data);\n"
  "  if (err != 0)\n"
  "    EXC_GENERIC(str_f(\"Fail running thread: %s\", strerror(err)));\n"
  "}\n"
  "\n"
  "void thread_join (pthread_t *thr) {\n"
  "  pthread_join(*thr, NULL);\n"
  "}\n"
  "\n"
  "void thread_sync (void (*fn)(void)) {\n"
  "  pthread_t self = pthread_self();\n"
  "  if (thread_in && pthread_equal(self, *thread_in)) {\n"
  "    fn();\n"
  "    return;\n"
  "  }\n"
  "\n"
  "  pthread_mutex_lock(&thread_mutex);\n"
  "  thread_in = MALLOC(pthread_t);\n"
  "  *thread_in = self;\n"
  "  fn();\n"
  "  thread_in = NULL;\n"
  "  pthread_mutex_unlock(&thread_mutex);\n"
  "}\n"
  "\n"
  "void thread_sync2 (void (*fn)(void *), void *value) {\n"
  "  pthread_t self = pthread_self();\n"
  "  if (thread_in && pthread_equal(self, *thread_in)) {\n"
  "    fn(value);\n"
  "    return;\n"
  "  }\n"
  "\n"
  "  pthread_mutex_lock(&thread_mutex);\n"
  "  thread_in = MALLOC(pthread_t);\n"
  "  *thread_in = self;\n"
  "  fn(value);\n"
  "  thread_in = NULL;\n"
  "  pthread_mutex_unlock(&thread_mutex);\n"
  "}\n"
  "\n"
  "//\n"
  "// opt.c ---------------------------------\n"
  "//\n"
  "// Copyright 21-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "struct opt_Opt {\n"
  "  void *value;\n"
  "};\n"
  "\n"
  "Opt *opt_some (void *value) {\n"
  "  Opt *this = MALLOC(Opt);\n"
  "  this->value = value;\n"
  "  return this;\n"
  "}\n"
  "\n"
  "Opt *opt_none (void) {\n"
  "  Opt *this = MALLOC(Opt);\n"
  "  this->value = NULL;\n"
  "  return this;\n"
  "}\n"
  "\n"
  "void *opt_get (Opt *this) {\n"
  "  return this->value;\n"
  "}\n"
  "\n"
  "void *opt_eget (Opt *this) {\n"
  "  if (!this->value)\n"
  "    EXC_ILLEGAL_STATE(\"Option is null\");\n"
  "\n"
  "  return this->value;\n"
  "}\n"
  "\n"
  "char *opt_to_js (Opt *this, char *(*to)(void *e)) {\n"
  "  if (this->value) return to(this->value);\n"
  "  return js_wn();\n"
  "}\n"
  "\n"
  "\n"
  "Opt *opt_from_js (char *js, void *(*from)(char *jse)) {\n"
  "  if (js_is_null(js)) return opt_none();\n"
  "  return opt_some(from(js));\n"
  "}\n"
  "\n"
  "//\n"
  "// arr.c ---------------------------------\n"
  "//\n"
  "// Copyright 20-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "struct arr_Arr {\n"
  "  void **es; // Start elements.\n"
  "  void **end; //End elements. (Elements are between 'es' (inclusive) and 'end'\n"
  "             // exclusive.\n"
  "  void **endbf; // End buffer.\n"
  "};\n"
  "\n"
  "Arr *arr_new (void) {\n"
  "  return arr_new_bf(15);\n"
  "}\n"
  "\n"
  "Arr *arr_new_bf (int buffer) {\n"
  "  if (buffer < 1) buffer = 1;\n"
  "  Arr *this = MALLOC(Arr);\n"
  "  void **es = GC_MALLOC(buffer * sizeof(void *));\n"
  "  this->es = es;\n"
  "  this->end = es;\n"
  "  this->endbf = es + buffer;\n"
  "  return this;\n"
  "}\n"
  "\n"
  "Arr *arr_new_fill (void *e, int size) {\n"
  "  int bf_size = size < 15 ? 15 : size;\n"
  "  Arr *this = MALLOC(Arr);\n"
  "  void **es = GC_MALLOC(bf_size * sizeof(void *));\n"
  "  void **end = es + size;\n"
  "  this->es = es;\n"
  "  this->end = end;\n"
  "  this->endbf = es + bf_size;\n"
  "  void **p = es;\n"
  "  while (p < end) *p++ = e;\n"
  "  return this;\n"
  "}\n"
  "\n"
  "Arr *arr_new_from (void *e, ...) {\n"
  "  va_list args;\n"
  "  void *tmp;\n"
  "\n"
  "  Arr *this = arr_new();\n"
  "  arr_push(this, e);\n"
  "\n"
  "  va_start(args, e);\n"
  "  tmp = va_arg(args, void *);\n"
  "  while (tmp) {\n"
  "    arr_push(this, tmp);\n"
  "    tmp = va_arg(args, void *);\n"
  "  }\n"
  "  va_end(args);\n"
  "\n"
  "  return this;\n"
  "}\n"
  "\n"
  "Arr *arr_new_c (int size, void **es) {\n"
  "  int bf_size = size < 15 ? 15 : size;\n"
  "\n"
  "  Arr *this = MALLOC(Arr);\n"
  "  this->es = GC_MALLOC(bf_size * sizeof(void *));\n"
  "  this->end = this->es + size;\n"
  "  this->endbf = this->es + bf_size;\n"
  "  memcpy(this->es, es, size * sizeof(void *));\n"
  "  return this;\n"
  "}\n"
  "\n"
  "Arr *arr_copy (Arr *this) {\n"
  "  int buffer = this->endbf - this->es;\n"
  "  int bf_size = buffer * sizeof(void *);\n"
  "  Arr *r = MALLOC(Arr);\n"
  "  void **es = GC_MALLOC(bf_size);\n"
  "  r->es = es;\n"
  "  r->end = es + (this->end - this->es);\n"
  "  r->endbf = es + buffer;\n"
  "  memcpy(es, this->es, bf_size);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "void **arr_begin (Arr *this) {\n"
  "  return this->es;\n"
  "}\n"
  "\n"
  "void **arr_end (Arr *this) {\n"
  "  return this->end;\n"
  "}\n"
  "\n"
  "int arr_size (Arr *this) {\n"
  "  return this->end - this->es;\n"
  "}\n"
  "\n"
  "int arr_empty (Arr *this) {\n"
  "  return this->es == this->end;\n"
  "}\n"
  "\n"
  "void *arr_get (Arr *this, int ix) {\n"
  "  EXC_RANGE(ix, 0, arr_size(this) - 1);\n"
  "  return *(this->es + ix);\n"
  "}\n"
  "\n"
  "void arr_push (Arr *this, void *e) {\n"
  "  if (this->end == this->endbf) {\n"
  "    int size = this->endbf - this->es;\n"
  "    int new_size = size + size;\n"
  "    this->es = GC_REALLOC(this->es, new_size * sizeof(void *));\n"
  "    this->end = this->es + size;\n"
  "    this->endbf = this->es + new_size;\n"
  "  }\n"
  "  *this->end++ = e;\n"
  "}\n"
  "\n"
  "void *arr_pop (Arr *this) {\n"
  "  if (this->es >= this->end)\n"
  "    EXC_ILLEGAL_STATE(\"Array is empty\");\n"
  "\n"
  "  --this->end;\n"
  "  return *this->end;\n"
  "}\n"
  "\n"
  "void *arr_peek (Arr *this) {\n"
  "  if (this->es >= this->end)\n"
  "    EXC_ILLEGAL_STATE(\"Array is empty\");\n"
  "\n"
  "  return *(this->end - 1);\n"
  "}\n"
  "\n"
  "void arr_set (Arr *this, int ix, void *e) {\n"
  "  EXC_RANGE(ix, 0, arr_size(this) - 1);\n"
  "\n"
  "  void **p = this->es + ix;\n"
  "  *p = e;\n"
  "}\n"
  "\n"
  "void arr_insert (Arr *this, int ix, void *e) {\n"
  "  EXC_RANGE(ix, 0, arr_size(this));\n"
  "\n"
  "  arr_push(this, e);\n"
  "  void **p = this->end - 1;\n"
  "  void **pix = this->es + ix;\n"
  "  while (p > pix) {\n"
  "    *p = *(p - 1);\n"
  "    --p;\n"
  "  }\n"
  "  *p = e;\n"
  "}\n"
  "\n"
  "void arr_remove (Arr *this, int ix) {\n"
  "  EXC_RANGE(ix, 0, arr_size(this) - 1);\n"
  "\n"
  "  void **p = this->es + ix;\n"
  "  void **p1 = p + 1;\n"
  "  void **pend = this->end;\n"
  "  while (p1 < pend) {\n"
  "    *p++ = *p1++;\n"
  "  }\n"
  "  --this->end;\n"
  "}\n"
  "\n"
  "void arr_cat (Arr *this, Arr *other) {\n"
  "  int other_len = other->end - other->es;\n"
  "  if (other_len) {\n"
  "    int this_len = this->end - this->es;\n"
  "    int this_size = this->endbf - this->es;\n"
  "    if (this_len + other_len >= this_size){\n"
  "      int new_size = this_size + other_len;\n"
  "      this->es = GC_REALLOC(this->es, new_size * sizeof(void *));\n"
  "      this->end = this->es + this_len;\n"
  "      this->endbf = this->es + new_size;\n"
  "    }\n"
  "    void **s = other->es;\n"
  "    void **t = this->end;\n"
  "    while (s < other->end) *t++ = *s++;\n"
  "    this->end = t;\n"
  "  }\n"
  "}\n"
  "\n"
  "void arr_set_arr (Arr *this, int ix, Arr *other) {\n"
  "  arr_set_range(this, ix, other, 0, arr_size(other));\n"
  "}\n"
  "\n"
  "void arr_set_range (Arr *this, int ix, Arr *other, int begin, int end) {\n"
  "  if (end < begin)\n"
  "    EXC_ILLEGAL_ARGUMENT(\n"
  "      \"end < begin\", str_f(\"end >= %d\", begin), str_f(\"end == %d\", end)\n"
  "    );\n"
  "  int size = end - begin;\n"
  "  if (!size) return;\n"
  "  EXC_RANGE(begin, 0, arr_size(other) - size);\n"
  "  EXC_RANGE(ix, 0, arr_size(this) - size);\n"
  "  void **target = this->es + ix;\n"
  "  void **source = other->es + begin;\n"
  "  memcpy(target, source, sizeof(void *) * size);\n"
  "}\n"
  "\n"
  "void arr_insert_arr (Arr *this, int ix, Arr *other) {\n"
  "  return arr_insert_range(this, ix, other, 0, arr_size(other));\n"
  "}\n"
  "\n"
  "void arr_insert_range (Arr *this, int ix, Arr *other, int begin, int end) {\n"
  "  if (end < begin)\n"
  "    EXC_ILLEGAL_ARGUMENT(\n"
  "      \"end < begin\", str_f(\"end >= %d\", begin), str_f(\"end == %d\", end)\n"
  "    );\n"
  "  int other_len = end - begin;\n"
  "  if (!other_len) return;\n"
  "\n"
  "  int this_len = this->end - this->es;\n"
  "  EXC_RANGE(begin, 0, arr_size(other) - other_len);\n"
  "  EXC_RANGE(ix, 0, this_len);\n"
  "\n"
  "  int new_len = this_len + other_len;\n"
  "  int new_size = new_len + 15;\n"
  "  void **new_es = GC_MALLOC(new_size * sizeof(void *));\n"
  "  memcpy(new_es, this->es, sizeof(void *) * ix);\n"
  "  memcpy(new_es + ix, other->es + begin, sizeof(void *) * other_len);\n"
  "  memcpy(\n"
  "    new_es + (ix + other_len),\n"
  "    this->es + ix,\n"
  "    sizeof(void *) * ((this->end - this->es) - ix)\n"
  "  );\n"
  "  this->es = new_es;\n"
  "  this->end = new_es + new_len;\n"
  "  this->endbf = new_es + new_size;\n"
  "}\n"
  "\n"
  "void arr_remove_range (Arr *this, int begin, int end) {\n"
  "  int sz = arr_size(this);\n"
  "  EXC_RANGE(end, 0, sz);\n"
  "  EXC_RANGE(begin, 0, end);\n"
  "\n"
  "  int df = end - begin;\n"
  "  if (df == 0) {\n"
  "    return;\n"
  "  }\n"
  "\n"
  "  void **pb = this->es + begin;\n"
  "  void **pe = this->es + end;\n"
  "  void **pend = this->end;\n"
  "  while (pe < pend) {\n"
  "    *pb++ = *pe++;\n"
  "  }\n"
  "  this->end -= df;\n"
  "}\n"
  "\n"
  "void arr_clear (Arr *this) {\n"
  "  this->end = this->es;\n"
  "}\n"
  "\n"
  "void arr_reverse (Arr *this) {\n"
  "  void **p = this->es;\n"
  "  void **end = this->end - 1;\n"
  "  void *tmp;\n"
  "  for (int i = 0; i < (this->end - this->es) / 2; ++i) {\n"
  "    tmp = *p;\n"
  "    *p++ = *end;\n"
  "    *end-- = tmp;\n"
  "  }\n"
  "}\n"
  "\n"
  "void arr_sort (Arr *this, int (*greater)(void *, void *)) {\n"
  "  void sort(void **a, int size) {\n"
  "    if (size < 2) {\n"
  "      return;\n"
  "    }\n"
  "    if (size == 2) {\n"
  "      if (greater(a[0], a[1])) { void *tmp = a[0]; a[0] = a[1]; a[1] = tmp; }\n"
  "      return;\n"
  "    }\n"
  "    if (size == 3) {\n"
  "      if (greater(a[0], a[1])) { void *tmp = a[0]; a[0] = a[1]; a[1] = tmp; }\n"
  "      if (greater(a[0], a[2])) { void *tmp = a[0]; a[0] = a[2]; a[2] = tmp; }\n"
  "      if (greater(a[1], a[2])) { void *tmp = a[1]; a[1] = a[2]; a[2] = tmp; }\n"
  "    }\n"
  "    int mid1 = size >> 1;\n"
  "    int mid2 = size - mid1;\n"
  "    void *a1[mid1];\n"
  "    void *a2[mid2];\n"
  "    void **pa = a;\n"
  "    void **pa1 = a1;\n"
  "    void **pa2 = a2;\n"
  "    for (int i = 0; i < mid1; ++i) *pa1++ = *pa++;\n"
  "    for (int i = 0; i < mid2; ++i) *pa2++ = *pa++;\n"
  "    sort(a1, mid1);\n"
  "    sort(a2, mid2);\n"
  "\n"
  "    pa = a;\n"
  "    pa1 = a1;\n"
  "    void **pa1_end = a1 + mid1;\n"
  "    pa2 = a2;\n"
  "    void **pa2_end = a2 + mid2;\n"
  "\n"
  "    for(;;) {\n"
  "      if (pa1 == pa1_end) {\n"
  "        while (pa2 < pa2_end) *pa++ = *pa2++;\n"
  "        break;\n"
  "      }\n"
  "      if (pa2 == pa2_end) {\n"
  "        while (pa1 < pa1_end) *pa++ = *pa1++;\n"
  "        break;\n"
  "      }\n"
  "      if (greater(*pa1, *pa2)) *pa++ = *pa2++;\n"
  "      else *pa++ = *pa1++;\n"
  "    }\n"
  "  }\n"
  "\n"
  "  sort(this->es, this->end - this->es);\n"
  "}\n"
  "\n"
  "void arr_shuffle (Arr *this) {\n"
  "  int rnd_i (int max) {\n"
  "    return (int)(((double)rand() / (double)RAND_MAX) * max);\n"
  "  }\n"
  "  void **es = this->es;\n"
  "  int size = this->end - es;\n"
  "  void **p = this->end - 1;\n"
  "  void **pix, *tmp;\n"
  "  while (p > es) {\n"
  "    pix = es + rnd_i(size--);\n"
  "    tmp = *p;\n"
  "    *p-- = *pix;\n"
  "    *pix = tmp;\n"
  "  }\n"
  "}\n"
  "\n"
  "int arr_all (Arr *this, int (*pred)(void *e)) {\n"
  "  void **p = this->es;\n"
  "  while (p < this->end) if (!pred(*p++)) return 0;\n"
  "  return 1;\n"
  "}\n"
  "\n"
  "int arr_any (Arr *this, int (*pred)(void *e)) {\n"
  "  void **p = this->es;\n"
  "  while (p < this->end) if (pred(*p++)) return 1;\n"
  "  return 0;\n"
  "}\n"
  "\n"
  "void arr_each(Arr *this, void (*fn)(void *e)) {\n"
  "  void **p = this->es;\n"
  "  while (p < this->end) fn(*p++);\n"
  "}\n"
  "\n"
  "void arr_each_ix(Arr *this, void (*fn)(void *e, int ix)) {\n"
  "  void **p = this->es;\n"
  "  int ix = 0;\n"
  "  while (p < this->end) fn(*p++, ix++);\n"
  "}\n"
  "\n"
  "int arr_eq(Arr *a1, Arr *a2, int (*feq)(void *e1, void *e2)) {\n"
  "  if (arr_size(a1) != arr_size(a2)) return FALSE;\n"
  "  void **p1 = a1->es;\n"
  "  void **p2 = a2->es;\n"
  "  while (p1 < a1->end) if (!feq(*p1++, *p2++)) return FALSE;\n"
  "  return TRUE;\n"
  "}\n"
  "\n"
  "int arr_index (Arr *this, int (*pred)(void *e)) {\n"
  "  void **es = this->es;\n"
  "  void **p = es;\n"
  "  while (p < this->end) if (pred(*p++)) return p - es - 1;\n"
  "  return -1;\n"
  "}\n"
  "\n"
  "Opt *arr_find(Arr *this, int (*pred)(void *e)) {\n"
  "  void **p = this->es;\n"
  "  while (p < this->end) {\n"
  "    void *e = *p++;\n"
  "    if (pred(e)) return opt_some(e);\n"
  "  }\n"
  "  return opt_none();\n"
  "}\n"
  "\n"
  "Opt *arr_find_last(Arr *this, int (*pred)(void *e)) {\n"
  "  Opt *r = opt_none();\n"
  "  void **p = this->es;\n"
  "  while (p < this->end) {\n"
  "    void *e = *p++;\n"
  "    if (pred(e)) r = opt_some(e);\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "int arr_last_index (Arr *this, int (*pred)(void *e)) {\n"
  "  void **es = this->es;\n"
  "  void **p = this->end;\n"
  "  if (p > es) {\n"
  "    while (--p > es) if (pred(*p)) return p - es;\n"
  "    if (pred(*es)) return 0;\n"
  "  }\n"
  "  return -1;\n"
  "}\n"
  "\n"
  "void arr_filter_in (Arr *this, int (*pred)(void *e)) {\n"
  "  void **p = this->es;\n"
  "  void **end = this->end;\n"
  "  void **new_end = p;\n"
  "  while (p < end) {\n"
  "    if (pred(*p)) {\n"
  "      *new_end++ = *p;\n"
  "    }\n"
  "    ++p;\n"
  "  }\n"
  "  this->end = new_end;\n"
  "}\n"
  "\n"
  "Arr *arr_take (Arr *this, int n) {\n"
  "  if (n > arr_size(this)) return arr_copy(this);\n"
  "  Arr *r = arr_new();\n"
  "  void **p = this->es;\n"
  "  for (int i = 0; i < n; ++i) arr_push(r, *p++);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "Arr *arr_takef (Arr *this, int (*predicate)(void *e)) {\n"
  "  Arr *r = arr_new();\n"
  "  void **p = this->es;\n"
  "  while (p < this->end) {\n"
  "    if (predicate(*p)) arr_push(r, *p);\n"
  "    else break;\n"
  "    ++p;\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "Arr *arr_drop (Arr *this, int n) {\n"
  "  if (n < 0) return arr_copy(this);\n"
  "  if (n >= arr_size(this)) return arr_new();\n"
  "  Arr *r = arr_new();\n"
  "  void **p = this->es + n;\n"
  "  while (p < this->end) arr_push(r, *p++);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "Arr *arr_dropf (Arr *this, int (*predicate)(void *e)) {\n"
  "  Arr *r = arr_new();\n"
  "  void **p = this->es;\n"
  "  while (p < this->end) {\n"
  "    if (!predicate(*p)) break;\n"
  "    ++p;\n"
  "  }\n"
  "  while (p < this->end) arr_push(r, *p++);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "Arr *arr_filter_to (Arr *this, int (*predicate)(void *e)) {\n"
  "  Arr *r = arr_new();\n"
  "  void **p = this->es;\n"
  "  while (p < this->end) {\n"
  "    void *e = *p++;\n"
  "    if (predicate(e)) arr_push(r, e);\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "Arr *arr_map (Arr *this, void *(*converter)(void *e)) {\n"
  "  Arr *r = arr_new();\n"
  "  void **p = this->es;\n"
  "  while (p < this->end) arr_push(r, converter(*p++));\n"
  "  return r;\n"
  "}\n"
  "\n"
  "Arr *arr_map2 (Arr *this, void *(*conv1)(void *e), void *(*conv2)(void *e)) {\n"
  "  Arr *r = arr_new();\n"
  "  void **p = this->es;\n"
  "  void **end = this->end;\n"
  "  if (p < end) arr_push(r, conv1(*p++));\n"
  "  while (p < end) arr_push(r, conv2(*p++));\n"
  "  return r;\n"
  "}\n"
  "\n"
  "void *arr_reduce(Arr *this, void *seed, void *(*fn)(void *seed, void *elem)) {\n"
  "  void **p = this->es;\n"
  "  while (p < this->end) seed = fn(seed, *p++);\n"
  "  return seed;\n"
  "}\n"
  "\n"
  "Arr *arr_zip (Arr *a1, Arr *a2, void *(*converter)(void *e1, void *e2)) {\n"
  "  Arr *r = arr_new();\n"
  "  void **p1 = a1->es;\n"
  "  void **p2 = a2->es;\n"
  "  while (p1 < a1->end && p2 < a2->end) arr_push(r, converter(*p1++, *p2++));\n"
  "  return r;\n"
  "}\n"
  "\n"
  "Arr *arr_zip3 (\n"
  "  Arr *a1, Arr *a2, Arr *a3, void*(*converter)(void*e1, void*e2, void*e3)\n"
  ") {\n"
  "  Arr *r = arr_new();\n"
  "  void **p1 = a1->es;\n"
  "  void **p2 = a2->es;\n"
  "  void **p3 = a3->es;\n"
  "  while (p1 < a1->end && p2 < a2->end && p3 < a3->end)\n"
  "    arr_push(r, converter(*p1++, *p2++, *p3++));\n"
  "  return r;\n"
  "}\n"
  "\n"
  "Arr *arr_duplicates (Arr *this, int (feq)(void *e1, void *e2)) {\n"
  "  Arr *r = arr_new();\n"
  "  Arr *new = arr_new();\n"
  "  void **p = this->es;\n"
  "  while (p < this->end) {\n"
  "    void *e = *p++;\n"
  "    int unique = 1;\n"
  "    void **newp = new->es;\n"
  "    while (newp < new->end) {\n"
  "      void *newe = *newp++;\n"
  "      if (feq(e, newe)) {\n"
  "        int rnew = 1;\n"
  "        void **rp = r->es;\n"
  "        while (rp < r->end) {\n"
  "          void *re = *rp++;\n"
  "          if (feq(e, re)) {\n"
  "            rnew = 0;\n"
  "            break;\n"
  "          }\n"
  "        }\n"
  "        if (rnew) {\n"
  "          arr_push(r, e);\n"
  "        }\n"
  "        unique = 0;\n"
  "        break;\n"
  "      }\n"
  "    }\n"
  "    if (unique) {\n"
  "      arr_push(new, e);\n"
  "    }\n"
  "  }\n"
  "  this->es = new->es;\n"
  "  this->end = new->end;\n"
  "  this->endbf = new->endbf;\n"
  "\n"
  "  return r;\n"
  "}\n"
  "\n"
  "// a is Arr<char>\n"
  "char *arr_cjoin(Arr *a, char sep) {\n"
  "  Buf *bf = buf_new();\n"
  "  int first = 1;\n"
  "  char **p = (char **)a->es;\n"
  "  while (p < (char **)a->end) {\n"
  "    if (first) {\n"
  "      first = 0;\n"
  "    } else {\n"
  "      buf_cadd(bf, sep);\n"
  "    }\n"
  "    buf_add(bf, *p++);\n"
  "  }\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "\n"
  "// a is Arr<char>\n"
  "char *arr_join(Arr *a, char *sep) {\n"
  "  Buf *bf = buf_new();\n"
  "  int first = 1;\n"
  "  char **p = (char **)a->es;\n"
  "  while (p < (char **)a->end) {\n"
  "    if (first) {\n"
  "      first = 0;\n"
  "    } else {\n"
  "      buf_add(bf, sep);\n"
  "    }\n"
  "    buf_add(bf, *p++);\n"
  "  }\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "\n"
  "// -------------------------------------------------------------------------- //\n"
  "typedef struct {                                                              //\n"
  "  void **es;                                                                  //\n"
  "  size_t n;                                                                   //\n"
  "  size_t i;                                                                   //\n"
  "} arr_to_it_O;                                                                //\n"
  "static Opt *to_it_next(arr_to_it_O *o) {                                      //\n"
  "  size_t i = o->i;                                                            //\n"
  "  if (i < o->n) {                                                             //\n"
  "    o->i += 1;                                                                //\n"
  "    return opt_some(o->es[i]);                                                //\n"
  "  } else {                                                                    //\n"
  "    return opt_none();                                                        //\n"
  "  }                                                                           //\n"
  "}                                                                             //\n"
  "// -------------------------------------------------------------------------- //\n"
  "It *arr_to_it (Arr *this) {\n"
  "  arr_to_it_O *o = MALLOC(arr_to_it_O);\n"
  "  o->es = this->es;\n"
  "  o->n = arr_size(this);\n"
  "  o->i = 0;\n"
  "  return it_new(o, (Opt *(*)(void*))to_it_next);\n"
  "}\n"
  "\n"
  "Arr *arr_from_it (It *it) {\n"
  "  Arr *r = arr_new();\n"
  "  while (it_has_next(it)) {\n"
  "    arr_push(r, it_next(it));\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "char *arr_to_js (Arr *this, char *(*to)(void *e)) {\n"
  "  return js_wa((Arr *)arr_map(this, (FMAP)to));\n"
  "}\n"
  "\n"
  "Arr *arr_from_js (char *js, void *(*from)(char *ejs)) {\n"
  "  return arr_map(js_ra(js), (FMAP)from);\n"
  "}\n"
  "\n"
  "//\n"
  "// bytes.c ---------------------------------\n"
  "//\n"
  "// Copyright 16-Oct-2018 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "struct bytes_Bytes {\n"
  "  unsigned char *bs;\n"
  "  int length;\n"
  "};\n"
  "\n"
  "Bytes *bytes_new() {\n"
  "  return bytes_new_bf(0);\n"
  "}\n"
  "\n"
  "Bytes *bytes_new_bf(int length) {\n"
  "  Bytes *this = MALLOC(Bytes);\n"
  "  this->bs = ATOMIC(length);\n"
  "  this->length = length;\n"
  "  return this;\n"
  "}\n"
  "\n"
  "Bytes *bytes_from_bytes(unsigned char *bs, int length) {\n"
  "  Bytes *this = MALLOC(Bytes);\n"
  "  this->bs = ATOMIC(length);\n"
  "  memcpy(this->bs, bs, length);\n"
  "  this->length = length;\n"
  "  return this;\n"
  "}\n"
  "\n"
  "Bytes *bytes_from_str (char *s) {\n"
  "  return bytes_from_bytes((unsigned char *)s, strlen(s));\n"
  "}\n"
  "\n"
  "unsigned char *bytes_bs(Bytes *this) {\n"
  "  return this->bs;\n"
  "}\n"
  "\n"
  "int bytes_len(Bytes *this) {\n"
  "  return this->length;\n"
  "}\n"
  "\n"
  "void bytes_add_bytes (Bytes *this, unsigned char *bs, int length) {\n"
  "  int sum = this->length + length;\n"
  "  if (sum) {\n"
  "    this->bs = GC_REALLOC(this->bs, sum);\n"
  "    memcpy(this->bs + this->length, bs, length);\n"
  "    this->length = sum;\n"
  "  }\n"
  "}\n"
  "\n"
  "void bytes_add (Bytes *this, Bytes *another) {\n"
  "  bytes_add_bytes(this, another->bs, another->length);\n"
  "}\n"
  "\n"
  "void bytes_add_str (Bytes *this, char *s) {\n"
  "  bytes_add_bytes(this, (unsigned char *)s, strlen(s));\n"
  "}\n"
  "\n"
  "char *bytes_to_str(Bytes *this) {\n"
  "  int len = this->length;\n"
  "  char *r = ATOMIC(len + 1);\n"
  "  memcpy(r, this->bs, len);\n"
  "  r[len] = 0;\n"
  "  return r;\n"
  "}\n"
  "\n"
  "char *bytes_to_js(Bytes *this) {\n"
  "  char *b64 = b64_encode_bytes(this);\n"
  "  size_t len = strlen(b64);\n"
  "  char *r = ATOMIC(len + 3);\n"
  "  r[0] = '\"';\n"
  "  memcpy(r + 1, b64, len);\n"
  "  r[len + 1] = '\"';\n"
  "  r[len + 2] = 0;\n"
  "  return r;\n"
  "}\n"
  "\n"
  "Bytes *bytes_from_js(char *js) {\n"
  "  size_t len = strlen(js) - 2;\n"
  "  char *b64 = ATOMIC(len + 1);\n"
  "  memcpy(b64, js + 1, len);\n"
  "  b64[len] = 0;\n"
  "\n"
  "  return b64_decode_bytes(b64);\n"
  "}\n"
  "\n"
  "//\n"
  "// b64.c ---------------------------------\n"
  "//\n"
  "// Copyright 22-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "static char encoding_table[] =\n"
  "    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n"
  "\n"
  "static const unsigned char decoding_table[256] = {\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,\n"
  "  52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,\n"
  "  64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,\n"
  "  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,\n"
  "  64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n"
  "  41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64\n"
  "};\n"
  "static int mod_table[] = {0, 2, 1};\n"
  "\n"
  "static char *base64_encode(\n"
  "  unsigned char *data,\n"
  "  size_t input_length,\n"
  "  size_t *output_length\n"
  ") {\n"
  "  *output_length = 4 * ((input_length + 2) / 3);\n"
  "  char *encoded_data = ATOMIC(*output_length + 1);\n"
  "\n"
  "  for (int i = 0, j = 0; i < input_length;) {\n"
  "    uint32_t octet_a = i < input_length ? (unsigned char)data[i++] : 0;\n"
  "    uint32_t octet_b = i < input_length ? (unsigned char)data[i++] : 0;\n"
  "    uint32_t octet_c = i < input_length ? (unsigned char)data[i++] : 0;\n"
  "\n"
  "    uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;\n"
  "\n"
  "    encoded_data[j++] = encoding_table[(triple >> 3 * 6) & 0x3F];\n"
  "    encoded_data[j++] = encoding_table[(triple >> 2 * 6) & 0x3F];\n"
  "    encoded_data[j++] = encoding_table[(triple >> 1 * 6) & 0x3F];\n"
  "    encoded_data[j++] = encoding_table[(triple >> 0 * 6) & 0x3F];\n"
  "  }\n"
  "\n"
  "  for (int i = 0; i < mod_table[input_length % 3]; i++) {\n"
  "    encoded_data[*output_length - 1 - i] = '=';\n"
  "  }\n"
  "\n"
  "  *(encoded_data + *output_length) = 0;\n"
  "  return encoded_data;\n"
  "}\n"
  "\n"
  "// Only for positive input_length\n"
  "static Bytes *base64_decode(\n"
  "  const char *data,\n"
  "  size_t input_length,\n"
  "  size_t *output_length\n"
  ") {\n"
  "  if (input_length % 4 != 0)\n"
  "    EXC_ILLEGAL_ARGUMENT(\n"
  "      \"Bad B64 string\", \"Length % 4 != 0\", str_f(\"Length %ld\", input_length)\n"
  "    );\n"
  "\n"
  "  *output_length = input_length / 4 * 3;\n"
  "  if (data[input_length - 1] == '=') (*output_length)--;\n"
  "  if (data[input_length - 2] == '=') (*output_length)--;\n"
  "\n"
  "  Bytes *bs = bytes_new_bf(*output_length);\n"
  "  unsigned char *decoded_data = bytes_bs(bs);\n"
  "\n"
  "  for (int i = 0, j = 0; i < input_length;) {\n"
  "    uint32_t sextet_a = data[i] == '='\n"
  "      ? 0 & i++\n"
  "      : decoding_table[(int)data[i++]];\n"
  "    uint32_t sextet_b = data[i] == '='\n"
  "      ? 0 & i++\n"
  "      : decoding_table[(int)data[i++]];\n"
  "    uint32_t sextet_c = data[i] == '='\n"
  "      ? 0 & i++\n"
  "      : decoding_table[(int)data[i++]];\n"
  "    uint32_t sextet_d = data[i] == '='\n"
  "      ? 0 & i++\n"
  "      : decoding_table[(int)data[i++]];\n"
  "\n"
  "    uint32_t triple = (sextet_a << 3 * 6) +\n"
  "      (sextet_b << 2 * 6) +\n"
  "      (sextet_c << 1 * 6) +\n"
  "      (sextet_d << 0 * 6);\n"
  "\n"
  "    if (j < *output_length) {\n"
  "      decoded_data[j++] = (triple >> 2 * 8) & 0xFF;\n"
  "    }\n"
  "    if (j < *output_length) {\n"
  "      decoded_data[j++] = (triple >> 1 * 8) & 0xFF;\n"
  "    }\n"
  "    if (j < *output_length) {\n"
  "      decoded_data[j++] = (triple >> 0 * 8) & 0xFF;\n"
  "    }\n"
  "  }\n"
  "  return bs;\n"
  "}\n"
  "\n"
  "char *b64_decode(char *b64) {\n"
  "  Bytes *bs = b64_decode_bytes(b64);\n"
  "  int len = bytes_len(bs);\n"
  "  char *s = ATOMIC(len + 1);\n"
  "  memcpy(s, bytes_bs(bs), len);\n"
  "  *(s + len) = 0;\n"
  "  if (str_runes_len(s) == -1)\n"
  "    return arr_join(str_runes(s), \"\");\n"
  "\n"
  "  return s;\n"
  "}\n"
  "\n"
  "Bytes *b64_decode_bytes(char *b64) {\n"
  "  if (*b64) {\n"
  "    size_t len;\n"
  "    return base64_decode(b64, strlen(b64), &len);\n"
  "  } else {\n"
  "    return bytes_new_bf(0);\n"
  "  }\n"
  "}\n"
  "\n"
  "char *b64_encode(char *s) {\n"
  "  size_t len;\n"
  "  return base64_encode((unsigned char *)s, strlen(s), &len);\n"
  "}\n"
  "\n"
  "char *b64_encode_bytes(Bytes *bs) {\n"
  "  size_t len;\n"
  "  return base64_encode(bytes_bs(bs), bytes_len(bs), &len);\n"
  "}\n"
  "\n"
  "//\n"
  "// buf.c ---------------------------------\n"
  "//\n"
  "// Copyright 21-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "struct buf_Buf{\n"
  "  char *str; // String in course.\n"
  "  int len; // Length of 'str'.\n"
  "  int bf_size; // Buffer size.\n"
  "};\n"
  "\n"
  "Buf *buf_new(void) {\n"
  "  return buf_new_bf(151);\n"
  "}\n"
  "\n"
  "Buf *buf_new_bf(int buffer_size) {\n"
  "  Buf *this = MALLOC(Buf);\n"
  "  this->bf_size = buffer_size - 1;\n"
  "  this->str = ATOMIC(buffer_size);\n"
  "  memset(this->str, 0, buffer_size);\n"
  "  this->len = 0;\n"
  "  return this;\n"
  "}\n"
  "\n"
  "char *buf_str (Buf *this) {\n"
  "  return this->str;\n"
  "}\n"
  "\n"
  "int buf_len (Buf *this) {\n"
  "  return this->len;\n"
  "}\n"
  "\n"
  "void buf_add_buf (Buf *this, char *data, int length) {\n"
  "  int ixend = this->len + length;\n"
  "  if (this->bf_size < ixend) {\n"
  "      while (this->bf_size < ixend) {\n"
  "          this->bf_size += this->bf_size;\n"
  "      }\n"
  "      int memsize = this->bf_size + 1;\n"
  "      char *newstr = ATOMIC(memsize);\n"
  "      memset(newstr, 0, memsize);\n"
  "      memcpy(newstr, this->str, this->len);\n"
  "      this->str = newstr;\n"
  "  }\n"
  "  memcpy(this->str + this->len, data, length);\n"
  "  this->len = ixend;\n"
  "}\n"
  "\n"
  "void buf_add (Buf *this, char *data) {\n"
  "  buf_add_buf(this, data, strlen(data));\n"
  "}\n"
  "\n"
  "void buf_cadd (Buf *this, char data) {\n"
  "  buf_add_buf(this, &data, 1);\n"
  "}\n"
  "\n"
  "void buf_reset(Buf *this) {\n"
  "  memset(this->str, 0, this->bf_size);\n"
  "  this->len = 0;\n"
  "}\n"
  "\n"
  "\n"
  "//\n"
  "// cryp.c ---------------------------------\n"
  "//\n"
  "// Copyright 22-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "static char *b64_base =\n"
  "  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n"
  "\n"
  "char *cryp_genk (int lg) {\n"
  "  if (lg <= 0)\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Value out of range\", \"Value < 0\", str_f(\"%d\", lg));\n"
  "\n"
  "  char *r = ATOMIC(lg + 1);\n"
  "  char *p = r + lg;\n"
  "  *p-- = 0;\n"
  "  while (lg--) {\n"
  "    *p-- = *(b64_base + sys_rnd_i(64));\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "char *cryp_key (char *key, int lg) {\n"
  "  if (!*key)\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Wrong key\", \"Value != \\\"\\\"\", \"\\\"\\\"\");\n"
  "\n"
  "  char *k0 = str_f(\n"
  "    \"%scodified in irreversibleDeme is good, very good!\\n\\r8@@\", key);\n"
  "  char *b64 = b64_encode(k0);\n"
  "  Bytes *k = b64_decode_bytes(b64);\n"
  "\n"
  "  unsigned char *ka = bytes_bs(k);\n"
  "  size_t lenk = bytes_len(k);\n"
  "  unsigned char sum = 0;\n"
  "  unsigned char *p = ka;\n"
  "  for (int i = 0; i < lenk; ++i) sum += *p++;\n"
  "\n"
  "  size_t lg2 = lg + lenk;\n"
  "  Bytes *rbs = bytes_new_bf(lg2);\n"
  "  unsigned char *ra = bytes_bs(rbs);\n"
  "  Bytes *rbs1 = bytes_new_bf(lg2);\n"
  "  unsigned char *ra1 = bytes_bs(rbs1);\n"
  "  Bytes *rbs2 = bytes_new_bf(lg2);\n"
  "  unsigned char *ra2 = bytes_bs(rbs2);\n"
  "\n"
  "  size_t ik = 0;\n"
  "  size_t v1, v2, v3, v4;\n"
  "  for (size_t i = 0; i < lg2; ++i) {\n"
  "    v1 = ka[ik];\n"
  "    v2 = v1 + ka[v1 % lenk];\n"
  "    v3 = v2 + ka[v2 % lenk];\n"
  "    v4 = v3 + ka[v3 % lenk];\n"
  "    sum = sum + i + v4;\n"
  "    ra1[i] = sum;\n"
  "    ra2[i] = sum;\n"
  "    ++ik;\n"
  "    if (ik == lenk) {\n"
  "      ik = 0;\n"
  "    }\n"
  "  }\n"
  "\n"
  "  for (size_t i = 0; i < lg2; ++i) {\n"
  "    v1 = ra2[i];\n"
  "    v2 = v1 + ra2[v1 % lg2];\n"
  "    v3 = v2 + ra2[v2 % lg2];\n"
  "    v4 = v3 + ra2[v3 % lg2];\n"
  "    sum = sum + v4;\n"
  "    ra2[i] = sum;\n"
  "    ra[i] = sum + ra1[i];\n"
  "  }\n"
  "\n"
  "  return str_left(b64_encode_bytes(rbs), lg);\n"
  "}\n"
  "\n"
  "static char *encode_aux (char *k, char *b64) {\n"
  "  if (!*k)\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Wrong key\", \"Value != \\\"\\\"\", \"\\\"\\\"\");\n"
  "\n"
  "  size_t lg = strlen(b64);\n"
  "  char *k2 = cryp_key(k, lg);\n"
  "\n"
  "  Bytes *rbs = bytes_new_bf(lg);\n"
  "\n"
  "  unsigned char *prbs = bytes_bs(rbs);\n"
  "  unsigned char *pk2 = (unsigned char *)k2;\n"
  "  unsigned char *pb64 = (unsigned char *)b64;\n"
  "  for(int i = 0; i < lg; ++i) *prbs++ = (*pk2++) + (*pb64++);\n"
  "\n"
  "  return b64_encode_bytes(rbs);\n"
  "}\n"
  "\n"
  "char *cryp_encode (char *k, char *s) {\n"
  "  return encode_aux(k, b64_encode(s));\n"
  "}\n"
  "\n"
  "char *cryp_encode_bytes (char *k, Bytes *bs) {\n"
  "  return encode_aux(k, b64_encode_bytes(bs));\n"
  "}\n"
  "\n"
  "static char *decode_aux (char *k, char *c) {\n"
  "  if (!*k)\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Wrong key\", \"Value != \\\"\\\"\", \"\\\"\\\"\");\n"
  "\n"
  "  Bytes *bs = b64_decode_bytes(c);\n"
  "\n"
  "  size_t lg = bytes_len(bs);\n"
  "  char *k2 = cryp_key(k, lg);\n"
  "\n"
  "  char *b64 = ATOMIC(lg + 1);\n"
  "\n"
  "  unsigned char *pbs = bytes_bs(bs);\n"
  "  unsigned char *pk2 = (unsigned char *)k2;\n"
  "  char *pb64 = b64;\n"
  "  for(int i = 0; i < lg; ++i) *pb64++ = *pbs++ - *pk2++;\n"
  "  *pb64 = 0;\n"
  "\n"
  "  return b64;\n"
  "}\n"
  "\n"
  "char *cryp_decode (char *k, char *c) {\n"
  "  return b64_decode(decode_aux(k, c));\n"
  "}\n"
  "\n"
  "Bytes *cryp_decode_bytes (char *k, char *c) {\n"
  "  return b64_decode_bytes(decode_aux(k, c));\n"
  "}\n"
  "\n"
  "//\n"
  "// exc.c ---------------------------------\n"
  "//\n"
  "// Copyright 21-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "\n"
  "// Arr[Exc]\n"
  "static Arr *pool = NULL;\n"
  "static pthread_mutex_t mutex;\n"
  "\n"
  "struct exc_Exc {\n"
  "  pthread_t thread;\n"
  "  // [jmp_buf]\n"
  "  Arr *buf;\n"
  "  char *type;\n"
  "  char *msg;\n"
  "  // [char]\n"
  "  Arr *stack;\n"
  "};\n"
  "\n"
  "static Exc *exc_new (pthread_t thread, jmp_buf *bf) {\n"
  "  Exc *this = MALLOC(Exc);\n"
  "  this->thread = thread;\n"
  "  this->buf = arr_new_from(bf, NULL);\n"
  "  this->type = NULL;\n"
  "  this->msg = NULL;\n"
  "  this->stack = arr_new();\n"
  "  return this;\n"
  "}\n"
  "\n"
  "char *exc_type (Exc *this) {\n"
  "  if (!this->type) {\n"
  "    puts(\"exc_type: 'type' is NULL\");\n"
  "    exit(1);\n"
  "  }\n"
  "  return this->type;\n"
  "}\n"
  "\n"
  "char *exc_msg (Exc *this) {\n"
  "  if (!this->msg) {\n"
  "    printf(\"exc_msg: 'msg' is NULL\");\n"
  "    exit(1);\n"
  "  }\n"
  "  return this->msg;\n"
  "}\n"
  "\n"
  "// Arr[char]\n"
  "Arr *exc_stack (Exc *this) {\n"
  "  return this->stack;\n"
  "}\n"
  "\n"
  "static void exc_exit (Exc *this) {\n"
  "  puts(exc_msg(this));\n"
  "\n"
  "  // Arr[char]\n"
  "  Arr *st = exc_stack(this);\n"
  "  printf(\"\\nObtained %d stack frames.\\n\", arr_size(st));\n"
  "\n"
  "  for (int i = 0; i < arr_size(st); ++i) {\n"
  "    puts(arr_get(st, i));\n"
  "  }\n"
  "\n"
  "  exit(1);\n"
  "}\n"
  "\n"
  "void exc_init () {\n"
  "  if (pool) {\n"
  "    return;\n"
  "  }\n"
  "  pool = arr_new();\n"
  "  pthread_mutex_init(&mutex, NULL);\n"
  "\n"
  "  jmp_buf *bf = MALLOC(jmp_buf);\n"
  "  Exc *exc = exc_new(pthread_self(), bf);\n"
  "  arr_push(pool, exc);\n"
  "\n"
  "  int val = setjmp(*bf);\n"
  "  if (val) {\n"
  "    Exc *exc = exc_get();\n"
  "    exc_exit(exc);\n"
  "  }\n"
  "}\n"
  "\n"
  "void exc_thread_init (void) {\n"
  "  if (pool) {\n"
  "    pthread_mutex_lock(&mutex);\n"
  "\n"
  "    pthread_t self = pthread_self();\n"
  "    jmp_buf *bf = MALLOC(jmp_buf);\n"
  "    Exc *exc = exc_new(self, bf);\n"
  "\n"
  "    int i = -1;\n"
  "    EACH(pool, Exc, exc2)\n"
  "      if (pthread_equal(exc2->thread, self)) {\n"
  "        i = _i;\n"
  "        break;\n"
  "      }\n"
  "    _EACH\n"
  "\n"
  "    if (i == -1) {\n"
  "      arr_push(pool, exc);\n"
  "    } else {\n"
  "      arr_set(pool, i, exc);\n"
  "    }\n"
  "\n"
  "    pthread_mutex_unlock(&mutex);\n"
  "\n"
  "    int val = setjmp(*bf);\n"
  "    if (val) {\n"
  "      Exc *exc = exc_get();\n"
  "      exc_exit(exc);\n"
  "    }\n"
  "  } else {\n"
  "    puts(\"'exc_init()' has not been called\");\n"
  "    exit(1);\n"
  "  }\n"
  "}\n"
  "\n"
  "void exc_thread_end (void) {\n"
  "  if (pool) {\n"
  "    pthread_mutex_lock(&mutex);\n"
  "\n"
  "    pthread_t th = pthread_self();\n"
  "    int i = -1;\n"
  "    EACH(pool, Exc, exc)\n"
  "      if (pthread_equal(exc->thread, th)) {\n"
  "        i = _i;\n"
  "        break;\n"
  "      }\n"
  "    _EACH\n"
  "    if (i != -1) {\n"
  "      arr_remove(pool, i);\n"
  "    }\n"
  "\n"
  "    pthread_mutex_unlock(&mutex);\n"
  "  } else {\n"
  "    puts(\"'exc_init()' has not been called\");\n"
  "    exit(1);\n"
  "  }\n"
  "}\n"
  "\n"
  "void exc_add (jmp_buf *jump) {\n"
  "  Exc *exc = exc_get();\n"
  "  arr_push(exc->buf, jump);\n"
  "}\n"
  "\n"
  "void exc_remove () {\n"
  "  Exc *exc = exc_get();\n"
  "  arr_pop(exc->buf);\n"
  "}\n"
  "\n"
  "Exc *exc_get (void) {\n"
  "  Exc *r = NULL;\n"
  "  if (pool) {\n"
  "    pthread_mutex_lock(&mutex);\n"
  "\n"
  "    pthread_t th = pthread_self();\n"
  "    EACH(pool, Exc, exc)\n"
  "      if (pthread_equal(exc->thread, th)) {\n"
  "        r = exc;\n"
  "        break;\n"
  "      }\n"
  "    _EACH\n"
  "\n"
  "    pthread_mutex_unlock(&mutex);\n"
  "  } else {\n"
  "    puts(\"'exc_init()' has not been called\");\n"
  "    exit(1);\n"
  "  }\n"
  "\n"
  "  if (!r) {\n"
  "    puts(\"exc_get: thread not found\");\n"
  "    exit(1);\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "void exc_throw (char *type, char *message, char *file, char *func, int line) {\n"
  "  Exc *exc = exc_get();\n"
  "\n"
  "  void *array[25];\n"
  "  size_t size;\n"
  "  char **strings;\n"
  "  size = backtrace(array, 25);\n"
  "  strings = backtrace_symbols(array, size);\n"
  "  // Arr[char]\n"
  "  Arr *stack = arr_new();\n"
  "  RANGE0(i, size) {\n"
  "    arr_push(stack, str_new(strings[i]));\n"
  "  }_RANGE\n"
  "  free(strings);\n"
  "\n"
  "  exc->stack = stack;\n"
  "  exc->msg = str_f(\n"
  "    \"%s:%d:[%s]: %s\", path_base(file), line, func, message\n"
  "  );\n"
  "  exc->type = type;\n"
  "  longjmp(*((jmp_buf *)arr_pop(exc->buf)), 1);\n"
  "}\n"
  "\n"
  "char *exc_range(int begin, int end, int index) {\n"
  "  return str_f(\n"
  "    \"Index out of range: %d < %d or %d > %d\", index, begin, index, end\n"
  "  );\n"
  "}\n"
  "\n"
  "char *exc_illegal_argument(char *msg, char *expected, char *actual) {\n"
  "  return str_f(\n"
  "    \"%s\\nExpected: %s\\n  Actual: %s\",\n"
  "    msg, expected, actual\n"
  "  );\n"
  "}\n"
  "\n"
  "//\n"
  "// time.c ---------------------------------\n"
  "//\n"
  "// Copyright 25-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "static time_t to_time (Time this) {\n"
  "  return (time_t)(this / 1000);\n"
  "}\n"
  "\n"
  "static Time from_time (time_t tm) {\n"
  "  return (Time)tm * 1000;\n"
  "}\n"
  "\n"
  "static int day_light_correction (int day, int month, int year) {\n"
  "  struct tm t;\n"
  "  memset(&t, 0, sizeof(struct tm));\n"
  "  t.tm_year = year - 1900;\n"
  "  t.tm_mon = month;\n"
  "  t.tm_mday = day;\n"
  "  t.tm_hour = 12;\n"
  "\n"
  "  time_t t2 = mktime(&t);\n"
  "  int h = localtime(&t2)->tm_hour;\n"
  "  return 12 - h;\n"
  "}\n"
  "\n"
  "Time time_now (void) {\n"
  "  struct timeval tm;\n"
  "  gettimeofday(&tm, NULL);\n"
  "  return tm.tv_sec * 1000 + tm.tv_usec / 1000;\n"
  "}\n"
  "\n"
  "Time time_new (int day, int month, int year) {\n"
  "  struct tm t;\n"
  "  memset(&t, 0, sizeof(struct tm));\n"
  "  t.tm_year = year - 1900;\n"
  "  t.tm_mon = month;\n"
  "  t.tm_mday = day;\n"
  "  t.tm_hour = 12 + day_light_correction(day, month, year);\n"
  "  return from_time((time_t) mktime(&t));\n"
  "}\n"
  "\n"
  "Time time_new_time (\n"
  "  int day, int month, int year, int hour, int minute, int second\n"
  ") {\n"
  "  struct tm t;\n"
  "  memset(&t, 0, sizeof(struct tm));\n"
  "  t.tm_year = year - 1900;\n"
  "  t.tm_mon = month;\n"
  "  t.tm_mday = day;\n"
  "  t.tm_hour = hour + day_light_correction(day, month, year);\n"
  "  t.tm_min = minute;\n"
  "  t.tm_sec = second;\n"
  "\n"
  "  return from_time((time_t) mktime(&t));\n"
  "}\n"
  "\n"
  "static Time from_str(char *date) {\n"
  "  char tpl[5];\n"
  "  memset (tpl, 0, 5);\n"
  "  memcpy(tpl, date + 6, 2);\n"
  "  int d = atoi(tpl);\n"
  "  memcpy(tpl, date + 4, 2);\n"
  "  int m = atoi(tpl);\n"
  "  memcpy(tpl, date, 4);\n"
  "  int y = atoi(tpl);\n"
  "  return time_new(d, m - 1, y);\n"
  "}\n"
  "\n"
  "Time time_from_str (char *date) {\n"
  "  if (strlen(date) != 8 && !math_digits(date))\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad date\", \"Date string\", date);\n"
  "  return from_str(date);\n"
  "}\n"
  "\n"
  "static Time from_iso_us (int is_iso, char *date, char sep) {\n"
  "  // <char>\n"
  "  Arr *parts = str_csplit(date, sep);\n"
  "  if (arr_size(parts) == 3) {\n"
  "    char *d = arr_get(parts, (is_iso) ? 0 : 1);\n"
  "    char *m = arr_get(parts, (is_iso) ? 1 : 0);\n"
  "    char *y = arr_get(parts, 2);\n"
  "\n"
  "    if (strlen(d) == 1) d = str_f(\"%s%s\", \"0\", d);\n"
  "    if (strlen(m) == 1) m = str_f(\"%s%s\", \"0\", m);\n"
  "    if (strlen(y) == 2) y = str_f(\"%s%s\", \"20\", y);\n"
  "\n"
  "    if (strlen(d) == 2 && strlen(m) == 2 && strlen(y) == 4)\n"
  "      return from_str(str_f(\"%s%s%s\", y, m, d));\n"
  "  }\n"
  "  EXC_ILLEGAL_ARGUMENT(\n"
  "    \"Bad date\",\n"
  "    str_f(\n"
  "      \"%s date string with separator '%c'\",\n"
  "      (is_iso) ? \"ISO\" : \"'EN'\", sep\n"
  "    ),\n"
  "    date\n"
  "  );\n"
  "\n"
  "  return 0; // Unreacheable\n"
  "}\n"
  "\n"
  "Time time_from_iso (char *date) {\n"
  "  return from_iso_us(TRUE, date, '/');\n"
  "}\n"
  "\n"
  "Time time_from_us (char *date) {\n"
  "  return from_iso_us(FALSE, date, '/');\n"
  "}\n"
  "\n"
  "Time time_from_iso_sep (char *date, char sep) {\n"
  "  return from_iso_us(TRUE, date, sep);\n"
  "}\n"
  "\n"
  "Time time_from_us_sep (char *date, char sep) {\n"
  "  return from_iso_us(FALSE, date, sep);\n"
  "}\n"
  "\n"
  "int time_day (Time this) {\n"
  "  time_t t = to_time(this);\n"
  "  return localtime(&t)->tm_mday;\n"
  "}\n"
  "\n"
  "int time_month (Time this) {\n"
  "  time_t t = to_time(this);\n"
  "  return localtime(&t)->tm_mon;\n"
  "}\n"
  "\n"
  "int time_year (Time this) {\n"
  "  time_t t = to_time(this);\n"
  "  return localtime(&t)->tm_year + 1900;\n"
  "}\n"
  "\n"
  "int time_year_day (Time this) {\n"
  "  time_t t = to_time(this);\n"
  "  return localtime(&t)->tm_yday;\n"
  "}\n"
  "\n"
  "int time_week_day (Time this) {\n"
  "  time_t t = to_time(this);\n"
  "  return localtime(&t)->tm_wday;\n"
  "}\n"
  "\n"
  "int time_hour (Time this) {\n"
  "  time_t t = to_time(this);\n"
  "  return localtime(&t)->tm_hour;\n"
  "}\n"
  "\n"
  "int time_minute (Time this) {\n"
  "  time_t t = to_time(this);\n"
  "  return localtime(&t)->tm_min;\n"
  "}\n"
  "\n"
  "int time_second (Time this) {\n"
  "  time_t t = to_time(this);\n"
  "  return localtime(&t)->tm_sec;\n"
  "}\n"
  "\n"
  "int time_millisecond (Time this) {\n"
  "  return this % 1000;\n"
  "}\n"
  "\n"
  "Time time_add (Time this, int days) {\n"
  "  return this + (Time)days * 86400000;\n"
  "}\n"
  "\n"
  "int time_df (Time t1, Time t2) {\n"
  "  return (t1 / 86400000) - (t2 / 86400000);\n"
  "}\n"
  "\n"
  "int time_eq (Time t1, Time t2) {\n"
  "  return (time_df(t1, t2)) ? FALSE : TRUE;\n"
  "}\n"
  "\n"
  "char *time_f (Time this, char *template) {\n"
  "  char *s, *rs;\n"
  "  time_t tthis = to_time(this);\n"
  "  struct tm *t = localtime(&tthis);\n"
  "  int size = 126;\n"
  "  while (1) {\n"
  "    rs = (char *)calloc(size, 1); // calloc ok\n"
  "    if (strftime (rs, size, template, t)) {\n"
  "      s = str_new(rs);\n"
  "      free(rs); // free ok\n"
  "      break;\n"
  "    }\n"
  "    free(rs); // free ok\n"
  "    size += size;\n"
  "  }\n"
  "  return s;\n"
  "}\n"
  "\n"
  "char *time_to_str (Time this) {\n"
  "  return time_f(this, \"%Y%m%d\");\n"
  "}\n"
  "\n"
  "char *time_to_iso (Time this) {\n"
  "  return time_f(this, \"%d/%m/%Y\");\n"
  "}\n"
  "\n"
  "char *time_to_us (Time this) {\n"
  "  return time_f(this, \"%m-%d-%Y\");\n"
  "}\n"
  "\n"
  "//\n"
  "// file.c ---------------------------------\n"
  "//\n"
  "// Copyright 25-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "struct file_File {\n"
  "  struct flock *lock;\n"
  "  FILE *f;\n"
  "};\n"
  "\n"
  "static File *lckFile_new(struct flock *lock, FILE *f) {\n"
  "  File *this = MALLOC(File);\n"
  "  this->lock = lock;\n"
  "  this->f = f;\n"
  "  return this;\n"
  "}\n"
  "\n"
  "char *file_tmp (char *dir, char *path) {\n"
  "  if (!*dir) dir = \"/tmp\";\n"
  "  char *fpath = NULL;\n"
  "  for (;;) {\n"
  "    char *k = cryp_genk(16);\n"
  "    char *pid = str_f(\"%d\", (int)getpid());\n"
  "    char *v = str_left(cryp_encode(k, pid), 8);\n"
  "    fpath = str_f(\"%s/%s%s\", dir, path, str_replace(v, \"/\", \"-\"));\n"
  "    if (!file_exists(fpath)) break;\n"
  "  }\n"
  "  return fpath;\n"
  "}\n"
  "\n"
  "char *file_wd (void) {\n"
  "  char *d = getcwd(NULL, 0);\n"
  "  if (!d)\n"
  "    EXC_IO(str_f(\"Working directory can no be find: %s\", strerror(errno)));\n"
  "\n"
  "  char *r = str_new(d);\n"
  "  free(d);  // free is ok\n"
  "  return r;\n"
  "}\n"
  "\n"
  "void file_cd (char *path) {\n"
  "  if (chdir(path)) {\n"
  "    EXC_IO(str_f(\n"
  "      \"Fail changing the working directory to %s: %s\",\n"
  "      path, strerror(errno)\n"
  "    ));\n"
  "  }\n"
  "}\n"
  "\n"
  "void file_mkdir (char *path) {\n"
  "  if (!*path || (*path == '/' && !path[1])) {\n"
  "    return;\n"
  "  }\n"
  "\n"
  "  char *p;\n"
  "  if (*path != '/') {\n"
  "    char *cwd = file_wd();\n"
  "    p = str_f(\"%s/%s\", cwd, path);\n"
  "  } else {\n"
  "    p = path;\n"
  "  }\n"
  "  p = path_parent(p);\n"
  "  file_mkdir(p);\n"
  "\n"
  "  if (mkdir(path, 0755) && errno != EEXIST)\n"
  "    EXC_IO(str_f(\"Fail making directory %s: %s\" , path, strerror(errno)));\n"
  "}\n"
  "\n"
  "// Arr<char>\n"
  "Arr *file_dir (char *path) {\n"
  "  DIR *d = opendir(path);\n"
  "  if (!d)\n"
  "    EXC_IO(str_f(\"Fail reading directory %s: %s\", path, strerror(errno)));\n"
  "\n"
  "  // Arr<char>\n"
  "  Arr *a = arr_new();\n"
  "  struct dirent *res;\n"
  "  while ((res = readdir(d))) {\n"
  "    char *name = res->d_name;\n"
  "    if (str_eq(name, \".\") || str_eq(name, \"..\")) {\n"
  "      continue;\n"
  "    }\n"
  "    arr_push(a, str_new(name));\n"
  "  }\n"
  "  closedir(d);\n"
  "  return a;\n"
  "}\n"
  "\n"
  "void file_del (char *path) {\n"
  "  struct stat buf;\n"
  "  int err = stat(path, &buf);\n"
  "  if (err == -1 && errno != ENOENT)\n"
  "      EXC_IO(str_f(\"Fail deleting %s: %s\", path, strerror(errno)));\n"
  "\n"
  "  if (!err && S_ISDIR(buf.st_mode)) {\n"
  "    // <char>\n"
  "    Arr *names = file_dir(path);\n"
  "    EACH(names, char, name) {\n"
  "      file_del(str_f(\"%s/%s\", path, name));\n"
  "    }_EACH\n"
  "\n"
  "    if (rmdir(path) && errno != ENOENT)\n"
  "      EXC_IO(str_f(\"Fail deleting %s: %s\", path, strerror(errno)));\n"
  "  } else {\n"
  "    if (unlink(path) && errno != ENOENT)\n"
  "      EXC_IO(str_f(\"Fail deleting %s: %s\", path, strerror(errno)));\n"
  "  }\n"
  "}\n"
  "\n"
  "void file_rename (char *old_path, char *new_path) {\n"
  "  if (rename(old_path, new_path) == -1)\n"
  "    EXC_IO(str_f(\n"
  "      \"Fail renaming '%s' to '%s: %s\", old_path, new_path, strerror(errno)\n"
  "    ));\n"
  "}\n"
  "\n"
  "void file_link (char *path, char *link) {\n"
  "  if (symlink(path, link) == -1)\n"
  "    EXC_IO(str_f(\n"
  "      \"Fail linking '%s' to '%s: %s\", link, path, strerror(errno)\n"
  "    ));\n"
  "}\n"
  "\n"
  "int file_exists (char *path) {\n"
  "  struct stat buf;\n"
  "  if (stat(path, &buf)) {\n"
  "    if (errno == ENOENT) {\n"
  "      return FALSE;\n"
  "    }\n"
  "    EXC_IO(str_f(\"Fail reading %s: %s\", path, strerror(errno)));\n"
  "  }\n"
  "  return TRUE;\n"
  "}\n"
  "\n"
  "int file_is_directory (char *path) {\n"
  "  struct stat buf;\n"
  "  if (stat(path, &buf)) {\n"
  "    if (errno == ENOENT) {\n"
  "      return FALSE;\n"
  "    }\n"
  "    EXC_IO(str_f(\"Fail reading %s: %s\", path, strerror(errno)));\n"
  "  }\n"
  "  if (S_ISDIR(buf.st_mode))\n"
  "    return TRUE;\n"
  "  return FALSE;\n"
  "}\n"
  "\n"
  "int file_is_link (char *path) {\n"
  "  struct stat buf;\n"
  "  if (lstat(path, &buf)) {\n"
  "    if (errno == ENOENT) {\n"
  "      return FALSE;\n"
  "    }\n"
  "    EXC_IO(str_f(\"Fail reading %s: %s\", path, strerror(errno)));\n"
  "  }\n"
  "  if (S_ISLNK(buf.st_mode))\n"
  "    return TRUE;\n"
  "  return FALSE;\n"
  "}\n"
  "\n"
  "int file_is_regular (char *path) {\n"
  "  struct stat buf;\n"
  "  if (stat(path, &buf)) {\n"
  "    if (errno == ENOENT) {\n"
  "      return FALSE;\n"
  "    }\n"
  "    EXC_IO(str_f(\"Fail reading %s: %s\", path, strerror(errno)));\n"
  "  }\n"
  "  if (S_ISREG(buf.st_mode))\n"
  "    return TRUE;\n"
  "  return FALSE;\n"
  "}\n"
  "\n"
  "struct stat *file_info (char *path) {\n"
  "  struct stat *r = MALLOC(struct stat);\n"
  "  if (stat(path, r))\n"
  "    EXC_IO(str_f(\"Fail reading %s: %s\", path, strerror(errno)));\n"
  "\n"
  "  return r;\n"
  "}\n"
  "\n"
  "int file_size(char *path) {\n"
  "  struct stat *i = file_info (path);\n"
  "  return i->st_size;\n"
  "}\n"
  "\n"
  "Time file_modified(char *path) {\n"
  "  struct stat *i = file_info (path);\n"
  "  return ((Time)i->st_mtime) * 1000;\n"
  "}\n"
  "\n"
  "char *file_read (char *path) {\n"
  "  FILE *fl;\n"
  "  size_t len = 0;\n"
  "  struct flock lck = {\n"
  "    .l_whence = SEEK_SET,\n"
  "    .l_start = 0,\n"
  "    .l_len = 0,\n"
  "  };\n"
  "\n"
  "  fl = fopen(path, \"r\");\n"
  "  if (!fl)\n"
  "    EXC_IO(str_f(\"Fail openning %s: %s\", path, strerror(errno)));\n"
  "\n"
  "  lck.l_type = F_RDLCK;\n"
  "  fcntl (fileno(fl), F_SETLKW, &lck);\n"
  "\n"
  "  Buf *bf = buf_new();\n"
  "  char *line = NULL;\n"
  "  while (getline(&line, &len, fl) != -1) {\n"
  "    buf_add(bf, line);\n"
  "    free(line); // free ok\n"
  "    line = NULL;\n"
  "  }\n"
  "  free(line); // free ok\n"
  "\n"
  "  lck.l_type = F_UNLCK;\n"
  "  fcntl (fileno(fl), F_SETLK, &lck);\n"
  "  fclose(fl);\n"
  "\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "\n"
  "void file_write (char *path, char *text) {\n"
  "  FILE *fl;\n"
  "  int error;\n"
  "  struct flock lck = {\n"
  "    .l_whence = SEEK_SET,\n"
  "    .l_start = 0,\n"
  "    .l_len = 0,\n"
  "  };\n"
  "\n"
  "  fl = fopen(path, \"w\");\n"
  "  if (!fl)\n"
  "    EXC_IO(str_f(\"Fail openning %s: %s\", path, strerror(errno)));\n"
  "\n"
  "  lck.l_type = F_WRLCK;\n"
  "  fcntl (fileno(fl), F_SETLKW, &lck);\n"
  "\n"
  "  error = fputs(text, fl);\n"
  "\n"
  "  lck.l_type = F_UNLCK;\n"
  "  fcntl (fileno(fl), F_SETLK, &lck);\n"
  "\n"
  "  if (error == EOF || error < 0) {\n"
  "    fclose(fl);\n"
  "    EXC_IO(str_f(\"Fail writing '%s': %s\", path, strerror(error)));\n"
  "  }\n"
  "  fclose(fl);\n"
  "}\n"
  "\n"
  "void file_append (char *path, char *text) {\n"
  "  FILE *fl;\n"
  "  int error;\n"
  "  struct flock lck = {\n"
  "    .l_whence = SEEK_SET,\n"
  "    .l_start = 0,\n"
  "    .l_len = 0,\n"
  "  };\n"
  "\n"
  "  fl = fopen(path, \"a\");\n"
  "  if (!fl)\n"
  "    EXC_IO(str_f(\"Fail openning %s: %s\", path, strerror(errno)));\n"
  "\n"
  "  lck.l_type = F_WRLCK;\n"
  "  fcntl (fileno(fl), F_SETLKW, &lck);\n"
  "\n"
  "  error = fputs(text, fl);\n"
  "\n"
  "  lck.l_type = F_UNLCK;\n"
  "  fcntl (fileno(fl), F_SETLK, &lck);\n"
  "\n"
  "  if (error == EOF || error < 0) {\n"
  "    fclose(fl);\n"
  "    EXC_IO(str_f(\"Fail writing '%s': %s\", path, strerror(error)));\n"
  "  }\n"
  "  fclose(fl);\n"
  "}\n"
  "\n"
  "void file_copy (char *source_path, char *target_path) {\n"
  "  if (!strcmp(source_path, target_path)) {\n"
  "    return;\n"
  "  }\n"
  "\n"
  "  FILE *f1;\n"
  "  FILE *f2;\n"
  "\n"
  "  char  buffer[32678];\n"
  "  size_t  n;\n"
  "\n"
  "  if ((f1 = fopen(source_path, \"rb\")) == 0)\n"
  "    EXC_IO(str_f(\"Fail openning '%s': %s\", source_path, strerror(errno)));\n"
  "\n"
  "  if ((f2 = fopen(target_path, \"wb\")) == 0)\n"
  "    EXC_IO(str_f(\"Fail openning '%s': %s\", target_path, strerror(errno)));\n"
  "\n"
  "  while ((n = fread(buffer, sizeof(char), sizeof(buffer), f1)) > 0) {\n"
  "    if (fwrite(buffer, sizeof(char), n, f2) != n)\n"
  "      EXC_IO(str_f(\"Fail writing '%s': %s\", target_path, strerror(errno)));\n"
  "  }\n"
  "\n"
  "  fclose(f1);\n"
  "  fclose(f2);\n"
  "}\n"
  "\n"
  "static File *lck_new(FILE *file) {\n"
  "  struct flock *lck = MALLOC(struct flock);\n"
  "  lck->l_whence = SEEK_SET;\n"
  "  lck->l_start = 0;\n"
  "  lck->l_len = 0;\n"
  "  return lckFile_new(lck, file);\n"
  "}\n"
  "\n"
  "File *file_ropen (char *path) {\n"
  "  FILE *file = fopen(path, \"r\");\n"
  "  if (!file)\n"
  "    EXC_IO(str_f(\"Fail opening '%s': %s\", path, strerror(errno)));\n"
  "\n"
  "  File *r = lck_new(file);\n"
  "  r->lock->l_type = F_RDLCK;\n"
  "  fcntl (fileno(file), F_SETLKW, r->lock);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "File *file_wopen (char *path) {\n"
  "  FILE *file = fopen(path, \"w\");\n"
  "  if (!file)\n"
  "    EXC_IO(str_f(\"Fail opening '%s': %s\", path, strerror(errno)));\n"
  "\n"
  "  File *r = lck_new(file);\n"
  "  r->lock->l_type = F_WRLCK;\n"
  "  fcntl (fileno(file), F_SETLKW, r->lock);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "File *file_aopen (char *path) {\n"
  "  FILE *file = fopen(path, \"a\");\n"
  "  if (!file)\n"
  "    EXC_IO(str_f(\"Fail opening '%s': %s\", path, strerror(errno)));\n"
  "\n"
  "  File *r = lck_new(file);\n"
  "  r->lock->l_type = F_WRLCK;\n"
  "  fcntl (fileno(file), F_SETLKW, r->lock);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "char *file_read_line (File *lck) {\n"
  "  size_t len = 0;\n"
  "  errno = 0;\n"
  "  char *line= NULL;\n"
  "  if (getline(&line, &len, lck->f) != -1) {\n"
  "    char *r = str_new(line);\n"
  "    free(line); // free ok\n"
  "    return r;\n"
  "  }\n"
  "  free(line); // free ok\n"
  "  if (errno) {\n"
  "    file_close(lck);\n"
  "    EXC_IO(str_f(\"Fail file_read_line: %s\", strerror(errno)));\n"
  "  }\n"
  "  return \"\";\n"
  "}\n"
  "\n"
  "void file_write_text (File *lck, char *text) {\n"
  "  int error = fputs(text, lck->f);\n"
  "  if (error == EOF || error < 0) {\n"
  "    file_close(lck);\n"
  "    EXC_IO(str_f(\"Fail file_write_line: %s\", strerror(errno)));\n"
  "  }\n"
  "}\n"
  "\n"
  "Bytes *file_read_bin_buf (File *lck, int buffer) {\n"
  "  unsigned char bs[buffer];\n"
  "  int len = (int)fread(bs, 1, buffer, lck->f);\n"
  "  if (len == -1) {\n"
  "    file_close(lck);\n"
  "    EXC_IO(str_f(\"Fail file_read_bin_buf: %s\", strerror(errno)));\n"
  "  }\n"
  "  if (len == 0) {\n"
  "    return bytes_new();\n"
  "  }\n"
  "  return bytes_from_bytes(bs, len);\n"
  "}\n"
  "\n"
  "Bytes *file_read_bin (File *lck) {\n"
  "  return file_read_bin_buf(lck, 8192);\n"
  "}\n"
  "\n"
  "void file_write_bin (File *lck, Bytes *bs) {\n"
  "  if (fwrite(bytes_bs(bs), bytes_len(bs), 1, lck->f) == -1)\n"
  "    EXC_IO(str_f(\"Fail file_write_bin: %s\", strerror(errno)));\n"
  "}\n"
  "\n"
  "void file_close (File *lck) {\n"
  "  FILE *fl = lck->f;\n"
  "  struct flock *lock = lck->lock;\n"
  "\n"
  "  lock->l_type = F_UNLCK;\n"
  "  fcntl (fileno(fl), F_SETLK, &lock);\n"
  "  fclose(fl);\n"
  "}\n"
  "\n"
  "\n"
  "//\n"
  "// tp.c ---------------------------------\n"
  "//\n"
  "// Copyright 23-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "struct tp_Tp {\n"
  "  void *e1;\n"
  "  void *e2;\n"
  "};\n"
  "\n"
  "Tp *tp_new (void *e1, void *e2) {\n"
  "  Tp *this = MALLOC(Tp);\n"
  "  this->e1 = e1;\n"
  "  this->e2 = e2;\n"
  "  return this;\n"
  "}\n"
  "\n"
  "void *tp_e1 (Tp *this) {\n"
  "  return this->e1;\n"
  "}\n"
  "\n"
  "void *tp_e2 (Tp *this) {\n"
  "  return this->e2;\n"
  "}\n"
  "\n"
  "//\n"
  "// tp3.c ---------------------------------\n"
  "//\n"
  "// Copyright 23-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "struct tp3_Tp3 {\n"
  "  void *e1;\n"
  "  void *e2;\n"
  "  void *e3;\n"
  "};\n"
  "\n"
  "Tp3 *tp3_new (void *e1, void *e2, void *e3) {\n"
  "  Tp3 *this = MALLOC(Tp3);\n"
  "  this->e1 = e1;\n"
  "  this->e2 = e2;\n"
  "  this->e3 = e3;\n"
  "  return this;\n"
  "}\n"
  "\n"
  "void *tp3_e1 (Tp3 *this) {\n"
  "  return this->e1;\n"
  "}\n"
  "\n"
  "void *tp3_e2 (Tp3 *this) {\n"
  "  return this->e2;\n"
  "}\n"
  "\n"
  "void *tp3_e3 (Tp3 *this) {\n"
  "  return this->e3;\n"
  "}\n"
  "\n"
  "//\n"
  "// it.c ---------------------------------\n"
  "//\n"
  "// Copyright 23-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "struct it_It {\n"
  "  void *o;\n"
  "  Opt *e;\n"
  "  Opt *(*next)(void *o);\n"
  "};\n"
  "\n"
  "typedef Opt *(*it_Next)(void *);\n"
  "\n"
  "It *it_new(\n"
  "  void *o,\n"
  "  Opt *(*next)(void *o)\n"
  ") {\n"
  "  It *this = MALLOC(It);\n"
  "  this->o = o;\n"
  "  this->next = next;\n"
  "  this->e = next(o);\n"
  "  return this;\n"
  "}\n"
  "\n"
  "static Opt *empty_next (void *o) { return opt_none(); }\n"
  "It *it_empty (void) {\n"
  "  return it_new(opt_none(), empty_next);\n"
  "}\n"
  "\n"
  "  //--\n"
  "  typedef struct {\n"
  "    void *e;\n"
  "    int is_first;\n"
  "  } it_unary_O;\n"
  "  static Opt *unary_next(it_unary_O *o) {\n"
  "    if (o->is_first) {\n"
  "      o->is_first = 0;\n"
  "      return opt_some(o->e);\n"
  "    }\n"
  "    return opt_none();\n"
  "  }\n"
  "It *it_unary (void *e) {\n"
  "  it_unary_O *o = MALLOC(it_unary_O);\n"
  "  o->e = e;\n"
  "  o->is_first = 1;\n"
  "  return it_new(o, (it_Next)unary_next);\n"
  "}\n"
  "\n"
  "  //--\n"
  "  typedef struct {\n"
  "    int i;\n"
  "    int end;\n"
  "  } it_range_O;\n"
  "  static Opt *range_next (it_range_O *o) {\n"
  "    int i = (o->i)++;\n"
  "    if (i >= o->end) {\n"
  "      return opt_none();\n"
  "    }\n"
  "    int *r = ATOMIC(sizeof(int));\n"
  "    *r = i;\n"
  "    return opt_some(r);\n"
  "  }\n"
  "It *it_range (int begin, int end) {\n"
  "  it_range_O *o = MALLOC(it_range_O);\n"
  "  o->i = begin;\n"
  "  o->end = end;\n"
  "  return it_new(o, (it_Next)range_next);\n"
  "}\n"
  "\n"
  "It *it_range0 (int end) {\n"
  "  return it_range(0, end);\n"
  "}\n"
  "\n"
  "int it_has_next (It *this) {\n"
  "  return opt_get(this->e) ? TRUE : FALSE;\n"
  "}\n"
  "\n"
  "static Opt *it_onext (It *this) {\n"
  "  Opt *r = this->e;\n"
  "  this->e = this->next(this->o);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "void *it_next (It *this) {\n"
  "  return opt_get(it_onext(this));\n"
  "}\n"
  "\n"
  "void *it_peek (It *this) {\n"
  "  return opt_get(this->e);\n"
  "}\n"
  "\n"
  "It *it_add(It *this, void *element) {\n"
  "  return it_cat(this, it_unary(element));\n"
  "}\n"
  "\n"
  "It *it_add0(It *this, void *element) {\n"
  "  return it_cat(it_unary(element), this);\n"
  "}\n"
  "\n"
  "  //--\n"
  "  typedef struct {\n"
  "    It *it1;\n"
  "    It *it2;\n"
  "  } it_cat_O;\n"
  "  static Opt *cat_next (it_cat_O *o) {\n"
  "    return (it_has_next(o->it1)) ? it_onext(o->it1)\n"
  "      : (it_has_next(o->it2)) ? it_onext(o->it2) : opt_none();\n"
  "  }\n"
  "It *it_cat (It *this, It *another) {\n"
  "  it_cat_O *o = MALLOC(it_cat_O);\n"
  "  o->it1 = this;\n"
  "  o->it2 = another;\n"
  "  return it_new(o, (it_Next)cat_next);\n"
  "}\n"
  "\n"
  "  //--\n"
  "  typedef struct {\n"
  "    It *it;\n"
  "    int i;\n"
  "    int n;\n"
  "  } it_take_O;\n"
  "  static Opt *take_next (it_take_O *o) {\n"
  "    if (o->i < o->n && it_has_next(o->it)) {\n"
  "      o->i += 1;\n"
  "      return it_onext(o->it);\n"
  "    }\n"
  "    else return opt_none();\n"
  "  }\n"
  "It *it_take (It *this, int n) {\n"
  "  it_take_O *o = MALLOC(it_take_O);\n"
  "  o->it = this;\n"
  "  o->n = n;\n"
  "  o->i = 0;\n"
  "  return it_new(o, (it_Next)take_next);\n"
  "}\n"
  "\n"
  "  //--\n"
  "  typedef struct {\n"
  "    It *it;\n"
  "    int (*f)(void *e);\n"
  "  } it_takef_O;\n"
  "  static Opt *takef_next (it_takef_O *o) {\n"
  "    return it_has_next(o->it) && o->f(it_peek(o->it))\n"
  "      ? it_onext(o->it) : opt_none();\n"
  "  }\n"
  "It *it_takef (It *this, int (*predicate)(void *e)) {\n"
  "  it_takef_O *o = MALLOC(it_takef_O);\n"
  "  o->it = this;\n"
  "  o->f = predicate;\n"
  "  return it_new(o, (it_Next)takef_next);\n"
  "}\n"
  "\n"
  "It *it_drop (It *this, int n) {\n"
  "  int i = 0;\n"
  "  while (it_has_next(this) && i++ < n)\n"
  "    it_next(this);\n"
  "  return this;\n"
  "}\n"
  "\n"
  "It *it_dropf (It *this, int (*predicate)(void *e)) {\n"
  "  while (it_has_next(this) && predicate(it_peek(this)))\n"
  "    it_next(this);\n"
  "  return this;\n"
  "}\n"
  "\n"
  "  //--\n"
  "  typedef struct {\n"
  "    It *it;\n"
  "    int (*f)(void *e);\n"
  "  } it_filter_O;\n"
  "  static Opt *filter_next (it_filter_O *o) {\n"
  "    for(;;) {\n"
  "      if (!it_has_next(o->it)) return opt_none();\n"
  "      Opt *onext = it_onext(o->it);\n"
  "      void *next = opt_get(onext);\n"
  "      if (o->f(next)) return onext;\n"
  "    }\n"
  "  }\n"
  "It *it_filter (It *this, int (*predicate)(void *e)) {\n"
  "  it_filter_O *o = MALLOC(it_filter_O);\n"
  "  o->it = this;\n"
  "  o->f = predicate;\n"
  "  return it_new(o, (it_Next)filter_next);\n"
  "}\n"
  "\n"
  "  //--\n"
  "  typedef struct {\n"
  "    It *it;\n"
  "    void *(*f)(void *);\n"
  "  } it_map_O;\n"
  "  static Opt *map_next (it_map_O *o) {\n"
  "    return it_has_next(o->it) ? opt_some(o->f(it_next(o->it))) : opt_none();\n"
  "  }\n"
  "It *it_map (It *this, void *(*converter)(void *e)) {\n"
  "  it_map_O *o = MALLOC(it_map_O);\n"
  "  o->it = this;\n"
  "  o->f = converter;\n"
  "  return it_new(o, (it_Next)map_next);\n"
  "}\n"
  "\n"
  "  //--\n"
  "  typedef struct {\n"
  "    It *it;\n"
  "    int is_first;\n"
  "    void *(*f1)(void *);\n"
  "    void *(*f)(void *);\n"
  "  } it_map2_O;\n"
  "  static Opt *map2_next(it_map2_O *o) {\n"
  "    if (!it_has_next(o->it)) return opt_none();\n"
  "    if (o->is_first) {\n"
  "      o->is_first = 0;\n"
  "      return opt_some(o->f1(it_next(o->it)));\n"
  "    }\n"
  "    return opt_some(o->f(it_next(o->it)));\n"
  "  }\n"
  "It *it_map2 (It *this, void *(*conv1)(void *e), void *(*conv2)(void *e)) {\n"
  "  it_map2_O *o = MALLOC(it_map2_O);\n"
  "  o->it = this;\n"
  "  o->is_first = 1;\n"
  "  o->f1 = conv1;\n"
  "  o->f = conv2;\n"
  "  return it_new(o, (it_Next)map2_next);\n"
  "}\n"
  "\n"
  "  //--\n"
  "  typedef struct {\n"
  "    It *it1;\n"
  "    It *it2;\n"
  "  } it_zip_O;\n"
  "  static Opt *zip_next(it_zip_O *o) {\n"
  "    return it_has_next(o->it1) && it_has_next(o->it2)\n"
  "      ? opt_some(tp_new(it_next(o->it1), it_next(o->it2)))\n"
  "      : opt_none();\n"
  "  }\n"
  "It *it_zip (It *it1, It *it2) {\n"
  "  it_zip_O *o = MALLOC(it_zip_O);\n"
  "  o->it1 = it1;\n"
  "  o->it2 = it2;\n"
  "  return it_new(o, (it_Next)zip_next);\n"
  "}\n"
  "\n"
  "  //--\n"
  "  typedef struct {\n"
  "    It *it1;\n"
  "    It *it2;\n"
  "    It *it3;\n"
  "  } it_zip3_O;\n"
  "  static Opt *zip3_next(it_zip3_O *o) {\n"
  "    return it_has_next(o->it1) && it_has_next(o->it2) && it_has_next(o->it3)\n"
  "      ? opt_some(tp3_new(\n"
  "          it_next(o->it1),\n"
  "          it_next(o->it2),\n"
  "          it_next(o->it3)\n"
  "        ))\n"
  "      : opt_none();\n"
  "  }\n"
  "It *it_zip3 (It *it1, It *it2, It *it3) {\n"
  "  it_zip3_O *o = MALLOC(it_zip3_O);\n"
  "  o->it1 = it1;\n"
  "  o->it2 = it2;\n"
  "  o->it3 = it3;\n"
  "\n"
  "  return it_new(o, (it_Next)zip3_next);\n"
  "}\n"
  "\n"
  "It *it_reverse (It *this) {\n"
  "  Arr *a = arr_from_it(this);\n"
  "  arr_reverse(a);\n"
  "  return arr_to_it(a);\n"
  "}\n"
  "\n"
  "It *it_sort (It *this, int (*comparator)(void *, void *)) {\n"
  "  Arr *a = arr_from_it(this);\n"
  "  arr_sort(a, comparator);\n"
  "  return arr_to_it(a);\n"
  "}\n"
  "\n"
  "void it_each (It *this, void (*f)(void *e)) {\n"
  "  while (it_has_next(this)) f(it_next(this));\n"
  "}\n"
  "\n"
  "void it_each_ix (It *this, void (*f)(void *e, int ix)) {\n"
  "  int c = 0;\n"
  "  while (it_has_next(this))\n"
  "    f(it_next(this), c++);\n"
  "}\n"
  "\n"
  "int it_count (It *this) {\n"
  "  int c = 0;\n"
  "  while (it_has_next(this)) {\n"
  "    it_next(this);\n"
  "    ++c;\n"
  "  }\n"
  "  return c;\n"
  "}\n"
  "\n"
  "int it_eq (It *it1, It *it2, int (*feq)(void *e1, void *e2)) {\n"
  "  while (it_has_next(it1) && it_has_next(it2)) {\n"
  "    void *e1 = it_next(it1);\n"
  "    void *e2 = it_next(it2);\n"
  "    if (!feq(e1, e2))\n"
  "      return 0;\n"
  "  }\n"
  "  if (it_has_next(it1) || it_has_next(it2))\n"
  "    return 0;\n"
  "  return 1;\n"
  "}\n"
  "\n"
  "int it_index (It *this, int (*predicate)(void *e)) {\n"
  "  int ix = 0;\n"
  "  while(it_has_next(this)) {\n"
  "    if (predicate(it_next(this)))\n"
  "      return ix;\n"
  "    ++ix;\n"
  "  }\n"
  "  return -1;\n"
  "}\n"
  "\n"
  "int it_contains (It *this, int (*predicate)(void *e)) {\n"
  "  while(it_has_next(this))\n"
  "    if (predicate(it_next(this)))\n"
  "      return 1;\n"
  "  return 0;\n"
  "}\n"
  "\n"
  "int it_last_index (It *this, int (*predicate)(void *e)) {\n"
  "  int r = -1;\n"
  "  int ix = 0;\n"
  "  while(it_has_next(this)) {\n"
  "    if (predicate(it_next(this)))\n"
  "      r = ix;\n"
  "    ++ix;\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "Opt *it_find (It *this, int (*predicate)(void *e)) {\n"
  "  while(it_has_next(this)) {\n"
  "    void *next = it_next(this);\n"
  "    if (predicate(next)) {\n"
  "      return opt_some(next);\n"
  "    }\n"
  "  }\n"
  "  return opt_none();\n"
  "}\n"
  "\n"
  "Arr *it_to (It *this) {\n"
  "  return arr_from_it (this);\n"
  "}\n"
  "\n"
  "It *it_from (Arr *a) {\n"
  "  return arr_to_it(a);\n"
  "}\n"
  "\n"
  "// Tp[Arr, Arr]\n"
  "Tp *it_duplicates (It *this, int (feq)(void *e1, void *e2)) {\n"
  "  Arr *d = arr_new();\n"
  "  Arr *r = arr_new();\n"
  "  void fn (void *e1) {\n"
  "    int fcontains (void *e2) { return feq(e1, e2); }\n"
  "    if (it_contains(it_from(r), fcontains)) {\n"
  "      if (!it_contains(it_from(d), fcontains)) {\n"
  "        arr_push(d, e1);\n"
  "      }\n"
  "    } else {\n"
  "      arr_push(r, e1);\n"
  "    }\n"
  "  }\n"
  "  it_each(this, fn);\n"
  "\n"
  "  return tp_new(d, r);\n"
  "}\n"
  "\n"
  "//\n"
  "// kv.c ---------------------------------\n"
  "//\n"
  "// Copyright 23-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "struct kv_Kv {\n"
  "  char *key;\n"
  "  void *value;\n"
  "};\n"
  "\n"
  "Kv *kv_new (char *key, void *value) {\n"
  "  Kv *this = MALLOC(Kv);\n"
  "  this->key = key;\n"
  "  this->value = value;\n"
  "  return this;\n"
  "}\n"
  "\n"
  "char *kv_key (Kv *this) {\n"
  "  return this->key;\n"
  "}\n"
  "\n"
  "void *kv_value (Kv *this) {\n"
  "  return this->value;\n"
  "}\n"
  "\n"
  "char *kv_to_js (Kv *this, char *(*to)(void *e)) {\n"
  "  return js_wa(arr_new_from(\n"
  "    js_ws(this->key),\n"
  "    to(this->value),\n"
  "    NULL\n"
  "  ));\n"
  "}\n"
  "\n"
  "Kv *kv_from_js (char *js, void *(*from)(char *ejs)) {\n"
  "  // <char>\n"
  "  Arr *a = js_ra(js);\n"
  "  return kv_new(\n"
  "    js_rs(arr_get(a, 0)),\n"
  "    from(arr_get(a, 1))\n"
  "  );\n"
  "}\n"
  "\n"
  "//\n"
  "// map.c ---------------------------------\n"
  "//\n"
  "// Copyright 23-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "Map *map_new(void) {\n"
  "  return (Map *)arr_new();\n"
  "}\n"
  "\n"
  "int map_size(Map *this) {\n"
  "  return arr_size((Arr *)this);\n"
  "}\n"
  "\n"
  "void map_add(Map *this, char *key, void *value) {\n"
  "  if (map_has_key(this, key))\n"
  "    EXC_ILLEGAL_ARGUMENT(\n"
  "      str_f(\"Fail adding the key '%s'\", key),\n"
  "      \"A new key\",\n"
  "      \"Key is duplicate\"\n"
  "    );\n"
  "  arr_push((Arr *)this, kv_new(key, value));\n"
  "}\n"
  "\n"
  "void map_set(Map *this, char *key, void *value) {\n"
  "  EACH((Arr *)this, Kv, kv) {\n"
  "    if (!strcmp(kv_key(kv), key)) {\n"
  "      arr_set((Arr *)this, _i, kv_new(key, value));\n"
  "      return;\n"
  "    }\n"
  "  }_EACH\n"
  "  EXC_ILLEGAL_ARGUMENT(\n"
  "    str_f(\"Fail changing the value of key '%s'\", key),\n"
  "    \"Key already existing\",\n"
  "    \"Key does not exist\"\n"
  "  );\n"
  "}\n"
  "\n"
  "void map_put(Map *this, char *key, void *value) {\n"
  "  int todo = TRUE;\n"
  "  EACH((Arr *)this, Kv, kv) {\n"
  "    if (!strcmp(kv_key(kv), key)) {\n"
  "      arr_set((Arr *)this, _i, kv_new(key, value));\n"
  "      todo = FALSE;\n"
  "      break;\n"
  "    }\n"
  "  }_EACH\n"
  "\n"
  "  if (todo) arr_push((Arr *)this, kv_new(key, value));\n"
  "}\n"
  "\n"
  "int map_has_key(Map *this, char *key) {\n"
  "  EACH((Arr *)this, Kv, kv) {\n"
  "    if (!strcmp(kv_key(kv), key)) return TRUE;\n"
  "  }_EACH\n"
  "  return FALSE;\n"
  "}\n"
  "\n"
  "Opt *map_get(Map *this, char *key) {\n"
  "  EACH((Arr *)this, Kv, kv) {\n"
  "    if (!strcmp(kv_key(kv), key)) return opt_some(kv_value(kv));\n"
  "  }_EACH\n"
  "  return opt_none();\n"
  "}\n"
  "\n"
  "void map_remove(Map *this, char *key) {\n"
  "  int ix = -1;\n"
  "  EACH((Arr *)this, Kv, kv) {\n"
  "    if (!strcmp(kv_key(kv), key)) {\n"
  "      ix = _i;\n"
  "      break;\n"
  "    }\n"
  "  }_EACH\n"
  "\n"
  "  if (ix != -1) arr_remove((Arr *)this, ix);\n"
  "}\n"
  "\n"
  "// <char>\n"
  "Arr *map_keys(Map *this) {\n"
  "  //(\n"
  "    char *fmap (Kv *kv) {\n"
  "      return kv_key(kv);\n"
  "    }\n"
  "  //)\n"
  "  return arr_map((Arr *)this, (FMAP)fmap);\n"
  "}\n"
  "\n"
  "//<kv>\n"
  "Arr *map_to_array(Map *this) {\n"
  "  return arr_copy((Arr *)this);\n"
  "}\n"
  "\n"
  "// Arr<kv>\n"
  "Map *map_from_array(Arr *this) {\n"
  "  // <Kv>\n"
  "  Arr *r = arr_copy(this);\n"
  "  //(\n"
  "    int feq (Kv *e1, Kv *e2) {\n"
  "      return !str_cmp(kv_key(e1), kv_key(e2));\n"
  "    }\n"
  "  //)\n"
  "  arr_duplicates(r, (FEQ)feq);\n"
  "  return (Map *)r;\n"
  "}\n"
  "\n"
  "void map_sort(Map *this) {\n"
  "  //(\n"
  "    int greater(Kv *e1, Kv *e2) {\n"
  "      return str_greater(kv_key(e1), kv_key(e2));\n"
  "    }\n"
  "  //)\n"
  "  arr_sort((Arr *)this, (FEQ)greater);\n"
  "}\n"
  "\n"
  "void map_sort_locale(Map *this) {\n"
  "  //(\n"
  "    int greater(Kv *e1, Kv *e2) {\n"
  "      return str_greater_locale(kv_key(e1), kv_key(e2));\n"
  "    }\n"
  "  //)\n"
  "  arr_sort((Arr *)this, (FEQ)greater);\n"
  "}\n"
  "\n"
  "char *map_to_js(Map *this, char *(*to)(void *e)) {\n"
  "    //-- <char>\n"
  "    Kv *fto (Kv *kv) { return kv_new(kv_key(kv), to(kv_value(kv))); }\n"
  "  return js_wo((Map *)arr_map((Arr *)this, (FMAP)fto));\n"
  "}\n"
  "\n"
  "// <char>\n"
  "Map *map_from_js(char *js, void *(*from)(char *jse)) {\n"
  "    //-- kv is Kv<char>\n"
  "    Kv *ffrom (Kv *kv) { return kv_new(kv_key(kv), from(kv_value(kv))); }\n"
  "  return (Map *)arr_map((Arr *)js_ro(js), (FMAP)ffrom);\n"
  "}\n"
  "\n"
  "//\n"
  "// js.c ---------------------------------\n"
  "//\n"
  "// Copyright 24-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "static void json_unicode(Buf *bf, char *hexdigits) {\n"
  "  char hexvalue (char ch) {\n"
  "    return (ch <= '9') ? ch - '0' : toupper(ch) - 'A' + 10;\n"
  "  }\n"
  "  unsigned int codepoint =\n"
  "    hexvalue(*hexdigits) * 4096 +\n"
  "    hexvalue(*(hexdigits + 1)) * 256 +\n"
  "    hexvalue(*(hexdigits + 2)) * 16 +\n"
  "    hexvalue(*(hexdigits + 3));\n"
  "  if (codepoint < 0x80) {\n"
  "    buf_cadd(bf, (codepoint>>0  & 0x7F) | 0x00);\n"
  "    return;\n"
  "  }\n"
  "  if (codepoint < 0x0800) {\n"
  "    buf_cadd(bf, (codepoint>>6  & 0x1F) | 0xC0);\n"
  "    buf_cadd(bf, (codepoint>>0  & 0x3F) | 0x80);\n"
  "    return;\n"
  "  }\n"
  "  buf_cadd(bf, (codepoint>>12 & 0x0F) | 0xE0);\n"
  "  buf_cadd(bf, (codepoint>>6  & 0x3F) | 0x80);\n"
  "  buf_cadd(bf, (codepoint>>0  & 0x3F) | 0x80);\n"
  "}\n"
  "\n"
  "static char *json_blanks(char *json) {\n"
  "  while (*json && ((unsigned char)*json) <= ' ') {\n"
  "    ++json;\n"
  "  }\n"
  "  return json;\n"
  "}\n"
  "\n"
  "inline\n"
  "static char *json_snull(char *json) {\n"
  "  return json_blanks(json + 4);\n"
  "}\n"
  "\n"
  "static char *json_sbool(char *json) {\n"
  "  if (*json == 't') {\n"
  "    return json_blanks(json + 4);\n"
  "  }\n"
  "  return json_blanks(json + 5);\n"
  "}\n"
  "\n"
  "static char *json_snumber(char *j) {\n"
  "  while (\n"
  "    *j && *j != '}' && *j != ']' && *j != ',' && ((unsigned char) *j) > ' '\n"
  "  ) {\n"
  "    ++j;\n"
  "  }\n"
  "  return json_blanks(j);\n"
  "}\n"
  "\n"
  "static char *json_sstring(char *j) {\n"
  "  ++j;\n"
  "  while (*j && *j != '\"') {\n"
  "    if (*j++ == '\\\\') {\n"
  "      if (*j) {\n"
  "        ++j;\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "  if (*j) {\n"
  "    ++j;\n"
  "  }\n"
  "  return json_blanks(j);\n"
  "}\n"
  "\n"
  "static char *json_selement(char *j);\n"
  "\n"
  "static char *json_sarray(char *j) {\n"
  "  ++j;\n"
  "  j = json_blanks(j);\n"
  "  while (*j && *j != ']') {\n"
  "    j = json_selement(j);\n"
  "    if (*j == ',') {\n"
  "      ++j;\n"
  "      j = json_blanks(j);\n"
  "    }\n"
  "  }\n"
  "  if (*j) {\n"
  "    ++j;\n"
  "  }\n"
  "  return json_blanks(j);\n"
  "}\n"
  "\n"
  "static char *json_sobject(char *j) {\n"
  "  ++j;\n"
  "  j = json_blanks(j);\n"
  "  while (*j && *j != '}') {\n"
  "    j = json_sstring(j);\n"
  "    ++j;\n"
  "    j = json_selement(j);\n"
  "    if (*j == ',') {\n"
  "      ++j;\n"
  "      j = json_blanks(j);\n"
  "    }\n"
  "  }\n"
  "  if (*j) {\n"
  "    ++j;\n"
  "  }\n"
  "  return json_blanks(j);\n"
  "}\n"
  "\n"
  "static char *json_selement(char *j) {\n"
  "  j = json_blanks(j);\n"
  "  switch (*j) {\n"
  "  case 'n': return json_snull(j);\n"
  "  case 't':\n"
  "  case 'f': return json_sbool(j);\n"
  "  case '\"': return json_sstring(j);\n"
  "  case '[': return json_sarray(j);\n"
  "  case '{': return json_sobject(j);\n"
  "  case '-': return json_snumber(j);\n"
  "  default :\n"
  "    if (*j >= '0' && *j <= '9') {\n"
  "      return json_snumber(j);\n"
  "    } else {\n"
  "      if (*j) {\n"
  "        ++j;\n"
  "      }\n"
  "      return j;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "\n"
  "static int json_rend(char *json) {\n"
  "  while (*json && ((unsigned char)*json) <= ' ') {\n"
  "    ++json;\n"
  "  }\n"
  "  return *json ? 0 : 1;\n"
  "}\n"
  "\n"
  "static char *errorf(char *json) {\n"
  "  return str_runes_len(json) > 70\n"
  "    ? str_f(\"%s...\", arr_join(arr_take(str_runes(json), 67), \"\"))\n"
  "    : json\n"
  "  ;\n"
  "}\n"
  "\n"
  "int js_is_null (char *json) {\n"
  "  char *j = json_blanks(json);\n"
  "  if (memcmp(j, \"null\", 4)) {\n"
  "    return 0;\n"
  "  }\n"
  "  return json_rend(j + 4);\n"
  "}\n"
  "\n"
  "int js_rb (char *json) {\n"
  "  char *jsons = json_blanks(json);\n"
  "  int r;\n"
  "\n"
  "  char *j = jsons;\n"
  "  if (memcmp(j, \"true\", 4)) {\n"
  "    if (memcmp(j, \"false\", 5))\n"
  "      EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Boolean value\", errorf(json));\n"
  "\n"
  "    r = 0;\n"
  "    j += 5;\n"
  "  } else {\n"
  "    r = 1;\n"
  "    j += 4;\n"
  "  }\n"
  "  if (!json_rend(j))\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Boolean value (spare characters)\", errorf(json));\n"
  "\n"
  "  return r;\n"
  "}\n"
  "\n"
  "int js_ri (char *json) {\n"
  "  return js_rl(json);\n"
  "}\n"
  "\n"
  "long js_rl (char *json) {\n"
  "  char *jsons = json_blanks(json);\n"
  "  char *j = jsons;\n"
  "  if (*j != '-' && (*j < '0' || *j > '9'))\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Long value\", errorf(json));\n"
  "\n"
  "  Buf *bf = buf_new();\n"
  "  while (\n"
  "    *j && *j != '}' && *j != ']' && *j != ',' && ((unsigned char)*j) > ' '\n"
  "  ) {\n"
  "    ++j;\n"
  "  }\n"
  "  buf_add_buf(bf, jsons, j - jsons);\n"
  "  char *n = buf_str(bf);\n"
  "  if (!json_rend(j))\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Long value (spare characters)\", errorf(json));\n"
  "\n"
  "  char *tail;\n"
  "  errno = 0;\n"
  "  long r = strtol(n, &tail, 10);\n"
  "  if (errno)\n"
  "    EXC_GENERIC(str_f(\"Bad JSON string: Long overflow in %s\", errorf(json)));\n"
  "\n"
  "  if (*tail)\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Long value\", errorf(json));\n"
  "\n"
  "  return r;\n"
  "}\n"
  "\n"
  "double js_rd (char *json) {\n"
  "  struct lconv *lc = localeconv();\n"
  "  char *jsons = json_blanks(json);\n"
  "  char *j = jsons;\n"
  "  if (*j != '-' && (*j < '0' || *j > '9'))\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Float value\", errorf(json));\n"
  "\n"
  "  Buf *bf = buf_new();\n"
  "  while (\n"
  "    *j && *j != '}' && *j != ']' && *j != ',' && ((unsigned char)*j) > ' '\n"
  "  ) {\n"
  "    ++j;\n"
  "  }\n"
  "  buf_add_buf(bf, jsons, j - jsons);\n"
  "  char *n = buf_str(bf);\n"
  "  int ix = str_cindex(n, '.');\n"
  "  if (ix != -1) {\n"
  "    n[ix] = *lc->decimal_point;\n"
  "  }\n"
  "  if (!json_rend(j))\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Float value (spare characters)\", errorf(json));\n"
  "\n"
  "  errno = 0;\n"
  "  char *tail;\n"
  "  double r = strtod(n, &tail);\n"
  "  if (errno)\n"
  "    EXC_GENERIC(str_f(\"Bad JSON string: Float overflow in %s\", errorf(json)));\n"
  "\n"
  "  if (*tail)\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Float value\", errorf(json));\n"
  "\n"
  "  return r;\n"
  "}\n"
  "\n"
  "char *js_rs (char *j) {\n"
  "  int is_hex (char ch) {\n"
  "    return (ch >= '0' && ch <= '9') ||\n"
  "      (ch >= 'a' && ch <= 'f') ||\n"
  "      (ch >= 'A' && ch <= 'F');\n"
  "  }\n"
  "\n"
  "  char *json = json_blanks(j);\n"
  "  if (*json != '\"')\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"String value (not begin with '\\\"')\", errorf(j));\n"
  "\n"
  "  ++json;\n"
  "  Buf *bf = buf_new();\n"
  "  while (*json && *json != '\"') {\n"
  "    if (*json == '\\\\') {\n"
  "      ++json;\n"
  "      switch (*json) {\n"
  "        case '\"' :\n"
  "        case '\\\\' :\n"
  "        case '/' :\n"
  "          buf_cadd(bf, *json);\n"
  "          break;\n"
  "        case 'b' :\n"
  "          buf_cadd(bf, '\\b');\n"
  "          break;\n"
  "        case 'f' :\n"
  "          buf_cadd(bf, '\\f');\n"
  "          break;\n"
  "        case 'n' :\n"
  "          buf_cadd(bf, '\\n');\n"
  "          break;\n"
  "        case 'r' :\n"
  "          buf_cadd(bf, '\\r');\n"
  "          break;\n"
  "        case 't' :\n"
  "          buf_cadd(bf, '\\t');\n"
  "          break;\n"
  "        case 'u' : {\n"
  "          ++json;\n"
  "          int c = 5;\n"
  "          while (--c) {\n"
  "            if (!is_hex(*json++))\n"
  "              EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"String value (Bad unicode)\", errorf(j));\n"
  "\n"
  "          }\n"
  "          json_unicode(bf, json - 4);\n"
  "          continue;\n"
  "        }\n"
  "        default :\n"
  "          EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"String value (Bad escape sequence)\", errorf(j));\n"
  "      }\n"
  "      ++json;\n"
  "    } else {\n"
  "      buf_cadd(bf, *json++);\n"
  "    }\n"
  "  }\n"
  "  if (!*json)\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"String value (not end with '\\\"')\", errorf(j));\n"
  "\n"
  "  if (!json_rend(json + 1))\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"String value (spare characters)\", errorf(j));\n"
  "\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "\n"
  "// <char>\n"
  "Arr *js_ra (char *j) {\n"
  "  char *json = json_blanks(j);\n"
  "  if (*json != '[')\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Array value (not begin with '[')\", errorf(j));\n"
  "\n"
  "  ++json;\n"
  "  // <char>\n"
  "  Arr *a = arr_new();\n"
  "  while (*json && *json != ']') {\n"
  "    char *tmp = json;\n"
  "    json = json_selement(json);\n"
  "    Buf *bf = buf_new();\n"
  "    buf_add_buf(bf, tmp, json - tmp);\n"
  "    arr_push(a, str_new(buf_str(bf)));\n"
  "    if (*json == ',') {\n"
  "      ++json;\n"
  "    } else if (*json && *json != ']')\n"
  "      EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Array value (comma missing)\", errorf(j));\n"
  "\n"
  "  }\n"
  "  if (!*json)\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Array value (not end with ']')\", errorf(j));\n"
  "\n"
  "  if (!json_rend(json + 1))\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Array value (spare characters)\", errorf(j));\n"
  "\n"
  "  return a;\n"
  "}\n"
  "\n"
  "// <char>\n"
  "Map *js_ro (char *j) {\n"
  "  char *json = json_blanks(j);\n"
  "  if (*json != '{')\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Object value (not begin with '{')\", errorf(j));\n"
  "\n"
  "  json = json_blanks(json + 1);\n"
  "\n"
  "  Map *m = map_new();\n"
  "  while (*json && *json != '}') {\n"
  "    if (*json != '\"')\n"
  "      EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Object value (bad key)\", errorf(j));\n"
  "\n"
  "    char *tmp = json;\n"
  "    json = json_sstring(json);\n"
  "    Buf *kbf = buf_new();\n"
  "    buf_add_buf(kbf, tmp, json - tmp);\n"
  "\n"
  "    if (*json != ':')\n"
  "      EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Object value (':' is missing)\", errorf(j));\n"
  "\n"
  "    ++json;\n"
  "    tmp = json;\n"
  "    json = json_selement(json);\n"
  "    Buf *vbf = buf_new();\n"
  "    buf_add_buf(vbf, tmp, json - tmp);\n"
  "\n"
  "    map_put(m, js_rs(buf_str(kbf)), str_new(buf_str(vbf)));\n"
  "\n"
  "    if (*json == ',') {\n"
  "      json = json_blanks(json + 1);\n"
  "    } else if (*json && *json != '}')\n"
  "      EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Object value (comma missing)\", errorf(j));\n"
  "\n"
  "  }\n"
  "  if (!*json)\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Object value (not end with '}')\", errorf(j));\n"
  "\n"
  "  if (!json_rend(json + 1))\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad JSON string\", \"Object value (spare characters)\", errorf(j));\n"
  "\n"
  "  return m;\n"
  "}\n"
  "\n"
  "char *js_wn() {\n"
  "  return str_new(\"null\");\n"
  "}\n"
  "\n"
  "char *js_wb(int value) {\n"
  "  return str_new(value ? \"true\" : \"false\");\n"
  "}\n"
  "\n"
  "char *js_wi(int n) {\n"
  "  return str_f(\"%d\", n);\n"
  "}\n"
  "\n"
  "char *js_wl(long n) {\n"
  "  return str_f(\"%ld\", n);\n"
  "}\n"
  "\n"
  "char *js_wf(double n, int scale) {\n"
  "  return math_ftos(n, scale);\n"
  "}\n"
  "\n"
  "char *js_ws(char *s) {\n"
  "  Buf *bf = buf_new();\n"
  "\n"
  "  char tmp;\n"
  "  buf_cadd(bf, '\"');\n"
  "  while (*s) {\n"
  "    tmp = *s++;\n"
  "    switch (tmp) {\n"
  "    case '\"':\n"
  "      buf_add(bf, \"\\\\\\\"\");\n"
  "      break;\n"
  "    case '\\\\':\n"
  "      buf_add(bf, \"\\\\\\\\\");\n"
  "      break;\n"
  "    case '\\b':\n"
  "      buf_add(bf, \"\\\\b\");\n"
  "      break;\n"
  "    case '\\f':\n"
  "      buf_add(bf, \"\\\\f\");\n"
  "      break;\n"
  "    case '\\n':\n"
  "      buf_add(bf, \"\\\\n\");\n"
  "      break;\n"
  "    case '\\r':\n"
  "      buf_add(bf, \"\\\\r\");\n"
  "      break;\n"
  "    case '\\t':\n"
  "      buf_add(bf, \"\\\\t\");\n"
  "      break;\n"
  "    default:\n"
  "      buf_cadd(bf, tmp);\n"
  "    }\n"
  "  }\n"
  "  buf_cadd(bf, '\"');\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "\n"
  "// Arr<char>\n"
  "char *js_wa(Arr *a) {\n"
  "  int size = arr_size(a);\n"
  "  Buf *bf = buf_new();\n"
  "  buf_cadd(bf, '[');\n"
  "  if (size > 0) {\n"
  "    buf_add(bf, arr_get(a, 0));\n"
  "    int i;\n"
  "    for (i = 1; i < size; ++i) {\n"
  "      buf_cadd(bf, ',');\n"
  "      buf_add(bf, arr_get(a, i));\n"
  "    }\n"
  "  }\n"
  "  buf_cadd(bf, ']');\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "\n"
  "// Map<char>\n"
  "char *js_wo(Map *m) {\n"
  "  Buf *bf = buf_new();\n"
  "  buf_cadd(bf, '{');\n"
  "  // <char>\n"
  "  Arr *kvs = map_to_array(m);\n"
  "  for (int i = 0; i < arr_size(kvs); i++) {\n"
  "    //<char>\n"
  "    Kv *kv = arr_get(kvs, i);\n"
  "    if (i) {\n"
  "      buf_cadd(bf, ',');\n"
  "    }\n"
  "    buf_add(bf, js_ws(kv_key(kv)));\n"
  "    buf_cadd(bf, ':');\n"
  "    buf_add(bf, kv_value(kv));\n"
  "  }\n"
  "  buf_cadd(bf, '}');\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "\n"
  "//\n"
  "// math.c ---------------------------------\n"
  "//\n"
  "// Copyright 24-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "char *math_itos (int64_t n) {\n"
  "  return str_f(\"%ld\", n);\n"
  "}\n"
  "\n"
  "char *math_ftos (double n, int scale) {\n"
  "  scale = scale < 0 ? 0 : scale > 9 ? 9 : scale;\n"
  "  char *tpl = str_f(\"%%.%df\", scale);\n"
  "  char *ns = str_f(tpl, n + (n >= 0 ? 0.000000000001 : -0.000000000001));\n"
  "  if (scale > 0) {\n"
  "    char *p = ns;\n"
  "    while (*p) {\n"
  "      if (*p == ',') *p++ = '.';\n"
  "      else ++p;\n"
  "    }\n"
  "    --p;\n"
  "    while (*p == '0') --p;\n"
  "    if (*p != '.') ++p;\n"
  "    ns = str_left(ns, p - ns);\n"
  "  }\n"
  "  if (!strcmp(ns, \"-0\")) ns = \"0\";\n"
  "  return ns;\n"
  "}\n"
  "\n"
  "int math_stoi (char *s) {\n"
  "  return math_stol(s);\n"
  "}\n"
  "\n"
  "long math_stol (char *s) {\n"
  "  s = str_trim(s);\n"
  "  if (!*s)\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad number\", \"An integer\", \"A empty string\");\n"
  "\n"
  "  char *tmp;\n"
  "  int64_t r = strtol(s, &tmp, 0);\n"
  "  if (*tmp)\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad number\", \"A valid number\", s);\n"
  "\n"
  "  return r;\n"
  "}\n"
  "\n"
  "float math_stof (char *s) {\n"
  "  return math_stod(s);\n"
  "}\n"
  "\n"
  "double math_stod (char *s) {\n"
  "  s = str_trim(s);\n"
  "  if (!*s)\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad number\", \"A double\", \"A empty string\");\n"
  "\n"
  "  struct lconv *lc = localeconv();\n"
  "  int ix = str_cindex(s, '.');\n"
  "  if (ix != -1) s[ix] = *lc->decimal_point;\n"
  "\n"
  "  char *tmp;\n"
  "  double r = strtod(s, &tmp);\n"
  "  if (*tmp)\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad number\", \"A valid number\", s);\n"
  "\n"
  "  return r;\n"
  "}\n"
  "\n"
  "char *math_to_locale (double n, int scale) {\n"
  "  scale = scale < 0 ? 0 : scale > 9 ? 9 : scale;\n"
  "  char *tpl = str_f(\"%%'.%df\", scale);\n"
  "  char *ns = str_f(tpl, n);\n"
  "  if (str_starts(ns, \"-0\")) ns = str_right(ns, 1);\n"
  "  return ns;\n"
  "}\n"
  "\n"
  "double math_from_iso (char *s) {\n"
  "  return math_stod(str_replace(str_replace(s, \".\", \"\"), \",\", \".\"));\n"
  "}\n"
  "\n"
  "double math_from_en (char *s) {\n"
  "  return math_stod(str_replace(s, \",\", \"\"));\n"
  "}\n"
  "\n"
  "int math_digits (char *s) {\n"
  "  if (!*s) return FALSE;\n"
  "  char *ps = s;\n"
  "  char ch;\n"
  "  while ((ch = *ps++)) if (ch < '0' || ch > '9') return FALSE;\n"
  "  return TRUE;\n"
  "}\n"
  "\n"
  "double math_round (double n, int scale) {\n"
  "  n = n >= 0 ? n + 0.00000000001 : n - 0.00000000001;\n"
  "  switch (scale) {\n"
  "    case 0: return round(n);\n"
  "    case 1: return round (n * 10.0) / 10.0;\n"
  "    case 2: return round (n * 100.0) / 100.0;\n"
  "    case 3: return round (n * 1000.0) / 1000.0;\n"
  "    case 4: return round (n * 10000.0) / 10000.0;\n"
  "    case 5: return round (n * 100000.0) / 100000.0;\n"
  "    case 6: return round (n * 1000000.0) / 1000000.0;\n"
  "    case 7: return round (n * 10000000.0) / 10000000.0;\n"
  "    case 8: return round (n * 100000000.0) / 100000000.0;\n"
  "    case 9: return round (n * 1000000000.0) / 1000000000.0;\n"
  "    default: if (scale < 0) return round(n);\n"
  "             else return round (n * 1000000000.0) / 1000000000.0;\n"
  "  }\n"
  "}\n"
  "\n"
  "int math_eq (double n1, double n2) {\n"
  "  return math_eq_gap(n1, n2, 0.0000001);\n"
  "}\n"
  "\n"
  "int math_eq_gap (double n1, double n2, double gap) {\n"
  "  gap = gap > 1 ? 1 : gap < 0.0000000001 ? 0.0000000001 : gap;\n"
  "  return n1 < n2 + gap && n1 > n2 - gap;\n"
  "}\n"
  "\n"
  "double math_abs (double n) {\n"
  "  return n >= 0 ? n : -n;\n"
  "}\n"
  "\n"
  "double math_pow (double base, double exp) {\n"
  "  return pow(base, exp);\n"
  "}\n"
  "\n"
  "double math_sqrt (double n) {\n"
  "  return sqrt(n);\n"
  "}\n"
  "\n"
  "//\n"
  "// path.c ---------------------------------\n"
  "//\n"
  "// Copyright 21-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "static char *normalize(char *path) {\n"
  "  char *r = str_trim(path);\n"
  "  while (str_ends(r, \"/\")) r = str_left(r, -1);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "char *path_cat (char *name1, char *name2, ...) {\n"
  "  va_list args;\n"
  "  char *tmp;\n"
  "\n"
  "  if (!name1 || !name2)\n"
  "    EXC_GENERIC(\"'path_cat' requieres at least 2 arguments.\");\n"
  "  if (!*name1) name1 = \".\";\n"
  "\n"
  "  Buf *bf = buf_new();\n"
  "  buf_add(bf, name1);\n"
  "  if (*buf_str(bf)) buf_cadd(bf, '/');\n"
  "  buf_add(bf, name2);\n"
  "\n"
  "  va_start(args, name2);\n"
  "  tmp = va_arg(args, char *);\n"
  "  while (tmp) {\n"
  "    if (*buf_str(bf)) buf_cadd(bf, '/');\n"
  "    buf_add(bf, tmp);\n"
  "    tmp = va_arg(args, char *);\n"
  "  }\n"
  "  va_end(args);\n"
  "\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "\n"
  "char *path_base (char *path) {\n"
  "  path = normalize(path);\n"
  "  int ix = str_last_cindex(path, '/');\n"
  "  if (ix != -1) return str_right(path, ix + 1);\n"
  "  return path;\n"
  "}\n"
  "\n"
  "char *path_parent (char *path) {\n"
  "  char *s = normalize(path);\n"
  "  if (!*s) EXC_GENERIC(str_f(\"'%s' has not parent directory\", path));\n"
  "  int ix = str_last_cindex(s, '/');\n"
  "  if (ix == -1) return \"\";\n"
  "  if (ix == 0) return \"/\";\n"
  "  return str_left(s, ix);\n"
  "}\n"
  "\n"
  "char *path_extension (char *path) {\n"
  "  path = path_base(path);\n"
  "  int ix = str_last_cindex(path, '.');\n"
  "  if (ix == -1) return \"\";\n"
  "  return str_right(path, ix);\n"
  "}\n"
  "\n"
  "char *path_clean (char *path) {\n"
  "  char *s = str_trim(path);\n"
  "  if (!*s) return \"\";\n"
  "  Buf *bf = buf_new();\n"
  "  int isSlash = 0;\n"
  "  while (*s) {\n"
  "    char ch = *s++;\n"
  "    if (ch == '/') {\n"
  "      if (isSlash) continue;\n"
  "      isSlash = 1;\n"
  "      buf_cadd(bf, ch);\n"
  "      continue;\n"
  "    }\n"
  "    isSlash = 0;\n"
  "    buf_cadd(bf, ch);\n"
  "  }\n"
  "  s = buf_str(bf);\n"
  "  if (!s[1]) return s;\n"
  "  if (str_ends(s, \"/\")) s = str_left(s, -1);\n"
  "  //<char>\n"
  "  Arr *new = arr_new();\n"
  "  EACH(str_csplit(s, '/'), char, part) {\n"
  "    if (!strcmp(part, \".\")) continue;\n"
  "    if (!strcmp(part, \"..\")) {\n"
  "      if (arr_size(new)) arr_pop(new);\n"
  "      else EXC_GENERIC(str_f(\"Bad path for cleaning '%s'\", path));\n"
  "      continue;\n"
  "    }\n"
  "    arr_push(new, part);\n"
  "  }_EACH\n"
  "  s = arr_cjoin(new, '/');\n"
  "  if (!*s && *path == '/')\n"
  "    EXC_GENERIC(str_f(\"Bad path for cleaning '%s'\", path));\n"
  "\n"
  "  return s;\n"
  "}\n"
  "\n"
  "Opt *path_canonical (char *s) {\n"
  "  char *tmp = realpath(s, NULL);\n"
  "  Opt *r = tmp ? opt_some(str_new(tmp)) : opt_none();\n"
  "  free(tmp);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "//\n"
  "// regex.c ---------------------------------\n"
  "//\n"
  "// Copyright 26-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "struct regex_RegexOffset {\n"
  "  int begin;\n"
  "  int end;\n"
  "};\n"
  "\n"
  "static RegexOffset *regexOffset_new(int begin, int end) {\n"
  "  RegexOffset *this = MALLOC(RegexOffset);\n"
  "  this->begin = begin;\n"
  "  this->end = end;\n"
  "  return this;\n"
  "}\n"
  "\n"
  "int regexOffset_begin (RegexOffset *off) {\n"
  "  return off->begin;\n"
  "}\n"
  "\n"
  "int regexOffset_end (RegexOffset *off) {\n"
  "  return off->end;\n"
  "}\n"
  "\n"
  "// <RegexOffset>\n"
  "static Arr *matches (regex_t *rex, char *s) {\n"
  "  Arr *r = arr_new();\n"
  "\n"
  "  regmatch_t match;\n"
  "\n"
  "  int ix = 0;\n"
  "  for (;;) {\n"
  "    char *sub = str_right(s, ix);\n"
  "    RegexOffset *offset = NULL;\n"
  "    int rs = regexec(rex, sub, 1, &match, 0);\n"
  "    if (rs == REG_ESPACE)\n"
  "      EXC_GENERIC(\"Regular expression out of memory\");\n"
  "\n"
  "    if (!rs) {\n"
  "      int end = ix + match.rm_eo;\n"
  "      offset = regexOffset_new(ix + match.rm_so, end);\n"
  "      ix = end;\n"
  "    }\n"
  "\n"
  "    if (offset) arr_push(r, offset);\n"
  "    else break;\n"
  "  }\n"
  "\n"
  "  regfree(rex);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "// <Arr<RegexOffset>>\n"
  "Opt *regex_matches (char *rex, char *s) {\n"
  "  if (!*rex)\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad regular expresion\", \"An expresion\", \"An empty string\");\n"
  "\n"
  "  regex_t exp;\n"
  "  if (regcomp(&exp, rex, REG_EXTENDED)) return opt_none();\n"
  "  return opt_some(matches(&exp, s));\n"
  "}\n"
  "\n"
  "// <Arr<RegexOffset>>\n"
  "Opt *regex_matches_ic (char *rex, char *s) {\n"
  "  if (!*rex)\n"
  "    EXC_ILLEGAL_ARGUMENT(\"Bad regular expresion\", \"An expresion\", \"An empty string\");\n"
  "\n"
  "  regex_t exp;\n"
  "  if (regcomp(&exp, rex, REG_EXTENDED | REG_ICASE)) return opt_none();\n"
  "  return opt_some(matches(&exp, s));\n"
  "}\n"
  "\n"
  "// matches is Arr<RegexOffset>\n"
  "static char *replace (Arr *matches, char *s, char *replacement) {\n"
  "  Buf *bf = buf_new();\n"
  "  int ix = 0;\n"
  "  EACH(matches, RegexOffset, rg) {\n"
  "    buf_add(bf, str_sub(s, ix, rg->begin));\n"
  "    buf_add(bf, replacement);\n"
  "    ix = rg->end;\n"
  "  }_EACH\n"
  "  buf_add(bf, str_right(s, ix));\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "\n"
  "// <char>\n"
  "Opt *regex_replace (char *rex, char *s, char *replacement) {\n"
  "  // <RegexOffset>\n"
  "  Arr *matches = opt_get(regex_matches(rex, s));\n"
  "  if (matches) return opt_some(replace(matches, s, replacement));\n"
  "  return opt_none();\n"
  "}\n"
  "\n"
  "// <char>\n"
  "Opt *regex_replace_ic (char *rex, char *s, char *replacement) {\n"
  "  // <RegexOffset>\n"
  "  Arr *matches = opt_get(regex_matches_ic(rex, s));\n"
  "  if (matches) return opt_some(replace(matches, s, replacement));\n"
  "  return opt_none();\n"
  "}\n"
  "\n"
  "// matches is Arr<RegexOffset>\n"
  "static char *replacef (Arr *matches, char *s, char *(*frepl)(char *match)) {\n"
  "  Buf *bf = buf_new();\n"
  "  int ix = 0;\n"
  "  EACH(matches, RegexOffset, rg) {\n"
  "    buf_add(bf, str_sub(s, ix, rg->begin));\n"
  "    buf_add(bf, frepl(str_sub(s, rg->begin, rg->end)));\n"
  "    ix = rg->end;\n"
  "  }_EACH\n"
  "  buf_add(bf, str_right(s, ix));\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "\n"
  "Opt *regex_replacef (char *rex, char *s, char *(*freplacement)(char *match)) {\n"
  "  // <RegexOffset>\n"
  "  Arr *matches = opt_get(regex_matches(rex, s));\n"
  "  if (matches) return opt_some(replacef(matches, s, freplacement));\n"
  "  return opt_none();\n"
  "}\n"
  "\n"
  "//\n"
  "// rs.c ---------------------------------\n"
  "//\n"
  "// Copyright 23-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "struct rs_Rs {\n"
  "  char *error;\n"
  "  void *value;\n"
  "};\n"
  "\n"
  "Rs *rs_ok (void *value) {\n"
  "  Rs *this = MALLOC(Rs);\n"
  "  this->error = \"\";\n"
  "  this->value = value;\n"
  "  return this;\n"
  "}\n"
  "\n"
  "Rs *rs_fail (char *msg) {\n"
  "  Rs *this = MALLOC(Rs);\n"
  "  this->error = msg;\n"
  "  this->value = NULL;\n"
  "  return this;\n"
  "}\n"
  "\n"
  "void *rs_get (Rs *this) {\n"
  "  return this->value;\n"
  "}\n"
  "\n"
  "char *rs_error (Rs *this) {\n"
  "  return this->error;\n"
  "}\n"
  "\n"
  "char *rs_to_js (Rs *this, char *(*to)(void *e)) {\n"
  "  return (*this->error)\n"
  "    ? js_wa(arr_new_from(\n"
  "        js_ws(this->error),\n"
  "        js_wn(),\n"
  "        NULL\n"
  "      ))\n"
  "    : js_wa(arr_new_from(\n"
  "        js_ws(\"\"),\n"
  "        to(this->value),\n"
  "        NULL\n"
  "      ));\n"
  "  ;\n"
  "}\n"
  "\n"
  "Rs *rs_from_js (char *js, void *(*from)(char *jse)) {\n"
  "  // <char>\n"
  "  Arr *a = js_ra(js);\n"
  "  char *error = js_rs(arr_get(a, 0));\n"
  "  return (*error) ? rs_fail(error) : rs_ok(from(arr_get(a, 1)));\n"
  "}\n"
  "\n"
  "//\n"
  "// str.c ---------------------------------\n"
  "//\n"
  "// Copyright 20-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "char *str_new (char *s) {\n"
  "  char *r = ATOMIC(strlen(s) + 1);\n"
  "  strcpy(r, s);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "char *str_new_c (char ch) {\n"
  "  char *r = ATOMIC(2);\n"
  "  *r = ch;\n"
  "  r[1] = 0;\n"
  "  return r;\n"
  "}\n"
  "\n"
  "int str_cmp(char *s1, char *s2) {\n"
  "  return strcmp(s1, s2);\n"
  "}\n"
  "\n"
  "int str_cmp_locale(char *s1, char *s2) {\n"
  "  return strcoll(s1, s2);\n"
  "}\n"
  "\n"
  "int str_greater(char *s1, char *s2) {\n"
  "  return strcmp(s1, s2) > 0;\n"
  "}\n"
  "\n"
  "int str_greater_locale(char *s1, char *s2) {\n"
  "  return strcoll(s1, s2) > 0;\n"
  "}\n"
  "\n"
  "int str_eq (char *str1, char *str2) {\n"
  "  return !strcmp(str1, str2);\n"
  "}\n"
  "\n"
  "int str_starts (char *str, char  *substr) {\n"
  "  while (*substr)\n"
  "    if (*str++ != *substr++) return 0;\n"
  "  return 1;\n"
  "}\n"
  "\n"
  "int str_ends (char *str, char  *substr) {\n"
  "  int slen = strlen(str);\n"
  "  int sublen = strlen(substr);\n"
  "  return slen >= sublen && !memcmp(str + slen - sublen, substr, sublen);\n"
  "}\n"
  "\n"
  "int str_cindex (char *str, char ch) {\n"
  "  int c = 0;\n"
  "  char *p  = str;\n"
  "  while (*p) {\n"
  "    if (*p++ == ch) {\n"
  "      return c;\n"
  "    };\n"
  "    ++c;\n"
  "  }\n"
  "  return -1;\n"
  "}\n"
  "\n"
  "int str_cindex_from (char *str, char ch, int from) {\n"
  "  if (from >= strlen(str)) {\n"
  "    return -1;\n"
  "  }\n"
  "  int c = from;\n"
  "  char *p  = str + from;\n"
  "  while (*p) {\n"
  "    if (*p++ == ch) {\n"
  "      return c;\n"
  "    };\n"
  "    ++c;\n"
  "  }\n"
  "  return -1;\n"
  "}\n"
  "\n"
  "int str_index(char *str, char *substr) {\n"
  "  if (!*substr) {\n"
  "    return 0;\n"
  "  }\n"
  "  int c = 0;\n"
  "  int limit = strlen(str) - strlen(substr);\n"
  "  char *p  = str;\n"
  "  for (;;) {\n"
  "    if (c > limit) {\n"
  "      break;\n"
  "    }\n"
  "    if (str_starts(p++, substr)) {\n"
  "      return c;\n"
  "    };\n"
  "    ++c;\n"
  "  }\n"
  "  return -1;\n"
  "}\n"
  "\n"
  "int str_index_from(char *str, char *substr, int from) {\n"
  "  if (from >= strlen(str)) {\n"
  "    return -1;\n"
  "  }\n"
  "\n"
  "  if (!*substr) {\n"
  "    return from;\n"
  "  }\n"
  "  int c = from;\n"
  "  int limit = strlen(str) - strlen(substr);\n"
  "  char *p  = str + from;\n"
  "  for (;;) {\n"
  "    if (c > limit) {\n"
  "      break;\n"
  "    }\n"
  "    if (str_starts(p++, substr)) {\n"
  "      return c;\n"
  "    };\n"
  "    ++c;\n"
  "  }\n"
  "  return -1;\n"
  "}\n"
  "\n"
  "int str_last_cindex(char *str, char ch) {\n"
  "  int r = -1;\n"
  "  int c = 0;\n"
  "  char *p  = str;\n"
  "  while (*p) {\n"
  "    if (*p++ == ch) {\n"
  "      r = c;\n"
  "    };\n"
  "    ++c;\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "int str_last_index(char *str, char *substr) {\n"
  "  int r = -1;\n"
  "  if (!*substr) {\n"
  "    return strlen(str);\n"
  "  }\n"
  "  int c = 0;\n"
  "  int limit = strlen(str) - strlen(substr);\n"
  "  char *p  = str;\n"
  "  while (*p) {\n"
  "    if (c > limit) {\n"
  "      break;\n"
  "    }\n"
  "    if (str_starts(p++, substr)) {\n"
  "      r = c;\n"
  "    };\n"
  "    ++c;\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "int str_len (char *str) {\n"
  "  return strlen(str);\n"
  "}\n"
  "\n"
  "char *str_sub(char *str, int begin, int end) {\n"
  "  int l = strlen(str);\n"
  "  int df = -1;\n"
  "  if (begin < 0) begin = l + begin;\n"
  "  if (begin >= l) return \"\";\n"
  "  if (begin < 0) begin = 0;\n"
  "\n"
  "  if (end < 0) end = l + end;\n"
  "  if (end > l) end = l;\n"
  "  if (end <= 0) return \"\";\n"
  "\n"
  "  df = end - begin;\n"
  "\n"
  "  char *r;\n"
  "  if (df < 0) return \"\";\n"
  "\n"
  "  r = ATOMIC(df + 1);\n"
  "  r[df] = 0;\n"
  "  memcpy(r, str + begin, df);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "char *str_left(char *str, int end) {\n"
  "  return str_sub(str, 0, end);\n"
  "}\n"
  "\n"
  "char *str_right(char *str, int begin) {\n"
  "  return str_sub(str, begin, strlen(str));\n"
  "}\n"
  "\n"
  "char *str_ltrim(char *str) {\n"
  "  unsigned char ch = *str;\n"
  "  while (ch && ch <= ' ') ch = *++str;\n"
  "  return str_new(str);\n"
  "}\n"
  "\n"
  "char *str_rtrim(char *str) {\n"
  "  char *p = str + (strlen(str) - 1);\n"
  "  while (p >= str && ((unsigned char)*p) <= ' ') {\n"
  "    --p;\n"
  "  }\n"
  "  return str_left(str, (p - str) + 1);\n"
  "}\n"
  "\n"
  "char *str_trim(char *str) {\n"
  "  unsigned char ch = *str;\n"
  "  while (ch && ch <= ' ') ch = *++str;\n"
  "  return str_rtrim(str);\n"
  "}\n"
  "\n"
  "// <char>\n"
  "Arr *str_csplit(char *s, char sep) {\n"
  "  // <char>\n"
  "  Arr *r = arr_new();\n"
  "  int i = str_cindex(s, sep);\n"
  "  while (i != -1) {\n"
  "    char *sub = ATOMIC(i + 1);\n"
  "    sub[i] = 0;\n"
  "    memcpy(sub, s, i);\n"
  "    arr_push(r, sub);\n"
  "    s = s + i + 1;\n"
  "    i = str_cindex(s, sep);\n"
  "  }\n"
  "  arr_push(r, str_new(s));\n"
  "  return r;\n"
  "}\n"
  "\n"
  "// <char>\n"
  "Arr *str_csplit_trim(char *str, char sep) {\n"
  "  // <char>\n"
  "  Arr *r = str_csplit(str, sep);\n"
  "  char **p = (char **)arr_begin(r);\n"
  "  while (p < (char **)arr_end(r)) {\n"
  "    *p = str_trim(*p);\n"
  "    ++p;\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "// <char>\n"
  "Arr *str_split(char *s, char *sep) {\n"
  "  // <char>\n"
  "  Arr *r = arr_new();\n"
  "  int len = strlen(sep);\n"
  "  if (!len) {\n"
  "    char *rune;\n"
  "    s = str_next_rune(&rune, s);\n"
  "    while (*rune) {\n"
  "      arr_push(r, rune);\n"
  "      s = str_next_rune(&rune, s);\n"
  "    }\n"
  "    return r;\n"
  "  }\n"
  "\n"
  "  int i = str_index(s, sep);\n"
  "  while (i != -1) {\n"
  "    char *sub = ATOMIC(i + 1);\n"
  "    sub[i] = 0;\n"
  "    memcpy(sub, s, i);\n"
  "    arr_push(r, sub);\n"
  "    s = s + i + len;\n"
  "    i = str_index(s, sep);\n"
  "  }\n"
  "  arr_push(r, str_new(s));\n"
  "  return r;\n"
  "}\n"
  "\n"
  "// <char>\n"
  "Arr *str_split_trim(char *str, char *sep) {\n"
  "  // <char>\n"
  "  Arr *r = str_split(str, sep);\n"
  "  char **p = (char **)arr_begin(r);\n"
  "  while (p < (char **)arr_end(r)) {\n"
  "    *p = str_trim(*p);\n"
  "    ++p;\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "char *str_creplace(char *s, char old, char new) {\n"
  "  char *r = str_new(s);\n"
  "  char *p = r;\n"
  "  while (*p) {\n"
  "    if (*p == old)\n"
  "      *p = new;\n"
  "    ++p;\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "char *str_replace(char *s, char *old, char *new) {\n"
  "  if (!*old) return str_new(s);\n"
  "\n"
  "  Buf *bf = buf_new();\n"
  "  int len = strlen(old);\n"
  "  int i = str_index(s, old);\n"
  "  while (i != -1) {\n"
  "    buf_add(bf, str_left(s, i));\n"
  "    buf_add(bf, new);\n"
  "    s = s + i + len;\n"
  "    i = str_index(s, old);\n"
  "  }\n"
  "  buf_add(bf, s);\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "\n"
  "char *str_vf(char *format, va_list args) {\n"
  "  char *tmp;\n"
  "  int len = vasprintf(&tmp, format, args);\n"
  "  if (len < 0)\n"
  "    exc_throw(\n"
  "      exc_illegal_argument_t, \"Wrong format\",\n"
  "      __FILE__, (char *)__func__, __LINE__);\n"
  "  char *msg = ATOMIC(len + 1);\n"
  "  strcpy(msg, tmp);\n"
  "  free(tmp);\n"
  "  return msg;\n"
  "}\n"
  "\n"
  "char *str_f(char *format, ...) {\n"
  "  va_list args;\n"
  "  va_start(args, format);\n"
  "  char *r = str_vf(format, args);\n"
  "  va_end(args);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "int str_runes_len(char *s) {\n"
  "  unsigned char b1, b2, b3, b4;\n"
  "  int r = 0;\n"
  "  while (*s) {\n"
  "    ++r;\n"
  "    b1 = *s++;\n"
  "    if (b1 < 0x80) continue;\n"
  "    else if (b1 < 0xC2) return -1;\n"
  "    else if (b1 < 0xE0) {\n"
  "      b2 = *s++;\n"
  "      if ((b2 & 0xC0) != 0x80) return -1;\n"
  "    } else if (b1 < 0xF0) {\n"
  "      b2 = *s++;\n"
  "      if ((b2 & 0xC0) != 0x80) return -1;\n"
  "      if (b1 == 0xE0 && b2 < 0xA0) return -1;\n"
  "      b3 = *s++;\n"
  "      if ((b3 & 0xC0) != 0x80) return -1;\n"
  "    } else if (b1 < 0xF5) {\n"
  "      b2 = *s++;\n"
  "      if ((b2 & 0xC0) != 0x80) return -1;\n"
  "      if (b1 == 0xF0 && b2 < 0x90) return -1;\n"
  "      if (b1 == 0xF4 && b2 >= 0x90) return -1;\n"
  "      b3 = *s++;\n"
  "      if ((b3 & 0xC0) != 0x80) return -1;\n"
  "      b4 = *s++;\n"
  "      if ((b4 & 0xC0) != 0x80) return -1;\n"
  "    } else return -1;\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "static char *error = \"??\";\n"
  "static char *replace_error = \"�\";\n"
  "static char *_str_next_rune(char *s) {\n"
  "  unsigned char b1, b2, b3, b4;\n"
  "  b1 = *s++;\n"
  "  if (b1) {\n"
  "    if (b1 < 0xC2) {\n"
  "      return str_f(\"%c\", b1);\n"
  "    } else if (b1 < 0xE0) {\n"
  "      b2 = *s++;\n"
  "      if ((b2 & 0xC0) != 0x80) {\n"
  "        return error;\n"
  "      }\n"
  "      return str_f(\"%c%c\", b1, b2);\n"
  "    } else if (b1 < 0xF0) {\n"
  "      b2 = *s++;\n"
  "      if ((b2 & 0xC0) != 0x80 ||\n"
  "          (b1 == 0xE0 && b2 < 0xA0)\n"
  "      ) {\n"
  "        return error;\n"
  "      }\n"
  "      b3 = *s++;\n"
  "      if ((b3 & 0xC0) != 0x80) {\n"
  "        return error;\n"
  "      }\n"
  "      return str_f(\"%c%c%c\", b1, b2, b3);\n"
  "    } else if (b1 < 0xF5) {\n"
  "      b2 = *s++;\n"
  "      if (((b2 & 0xC0) != 0x80) ||\n"
  "          (b1 == 0xF0 && b2 < 0x90) ||\n"
  "          (b1 == 0xF4 && b2 >= 0x90)\n"
  "      ) {\n"
  "        return error;\n"
  "      }\n"
  "      b3 = *s++;\n"
  "      if ((b3 & 0xC0) != 0x80) {\n"
  "        return error;\n"
  "      }\n"
  "      b4 = *s++;\n"
  "      if ((b4 & 0xC0) != 0x80) {\n"
  "        return error;\n"
  "      }\n"
  "      return str_f(\"%c%c%c%c\", b1, b2, b3, b4);\n"
  "    } else {\n"
  "      return error;\n"
  "    }\n"
  "  }\n"
  "  return \"\";\n"
  "}\n"
  "\n"
  "char *str_next_rune(char **rune, char *s) {\n"
  "  char *r = _str_next_rune(s);\n"
  "  if (r[0] == '?' && r[1] == '?') {\n"
  "    *rune = str_new(replace_error);\n"
  "    return s + 1;\n"
  "  }\n"
  "  *rune = r;\n"
  "  return s + strlen(r);\n"
  "}\n"
  "\n"
  "Arr *str_runes(char *s) {\n"
  "  //<char>\n"
  "  Arr *r = arr_new();\n"
  "  char *rune;\n"
  "  while (*s) {\n"
  "    s = str_next_rune(&rune, s);\n"
  "    arr_push(r, rune);\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "static unsigned error2 = 65533;\n"
  "unsigned *str_to_unicode(char *s0) {\n"
  "  unsigned char *s = (unsigned char *)s0;\n"
  "  unsigned b1, b2, b3, b4;\n"
  "  int lg = str_runes_len(s0) + 1;\n"
  "  unsigned *r = ATOMIC(lg * sizeof(unsigned));\n"
  "  unsigned *pr = r;\n"
  "  while (*s) {\n"
  "    b1 = *s++;\n"
  "    if (b1 < 0x80) *pr++ = b1;\n"
  "    else if (b1 < 0xC2) *pr++ = error2;\n"
  "    else if (b1 < 0xE0) {\n"
  "      b2 = *s++;\n"
  "      if ((b2 & 0xC0) != 0x80) *pr++ = error2;\n"
  "      *pr++ = (b1 << 6) + b2 - 0x3080;\n"
  "    } else if (b1 < 0xF0) {\n"
  "      b2 = *s++;\n"
  "      if ((b2 & 0xC0) != 0x80) *pr++ = error2;\n"
  "      if (b1 == 0xE0 && b2 < 0xA0) *pr++ = error2;\n"
  "      b3 = *s++;\n"
  "      if ((b3 & 0xC0) != 0x80) *pr++ = error2;\n"
  "      *pr++ = (b1 << 12) + (b2 << 6) + b3 - 0xE2080;\n"
  "    } else if (b1 < 0xF5) {\n"
  "      b2 = *s++;\n"
  "      if ((b2 & 0xC0) != 0x80) *pr++ = error2;\n"
  "      if (b1 == 0xF0 && b2 < 0x90) *pr++ = error2;\n"
  "      if (b1 == 0xF4 && b2 >= 0x90) *pr++ = error2;\n"
  "      b3 = *s++;\n"
  "      if ((b3 & 0xC0) != 0x80) *pr++ = error2;\n"
  "      b4 = *s++;\n"
  "      if ((b4 & 0xC0) != 0x80) *pr++ = error2;\n"
  "      *pr++ = (b1 << 18) + (b2 << 12) + (b3 << 6) + b4 - 0x3C82080;\n"
  "    } else {\n"
  "      *pr++ = error2;\n"
  "    }\n"
  "  }\n"
  "  *pr = 0;\n"
  "  return r;\n"
  "}\n"
  "\n"
  "char *str_from_unicode(unsigned *u) {\n"
  "  Buf *bf = buf_new();\n"
  "\n"
  "  while (*u) {\n"
  "    unsigned code_point = *u++;\n"
  "    if (code_point < 0x80) {\n"
  "      buf_cadd(bf, (unsigned char)code_point);\n"
  "    } else if (code_point <= 0x7FF) {\n"
  "      buf_cadd(bf, (unsigned char)(code_point >> 6) + 0xC0);\n"
  "      buf_cadd(bf, (unsigned char)(code_point & 0x3F) + 0x80);\n"
  "    } else if (code_point <= 0xFFFF) {\n"
  "      buf_cadd(bf, (unsigned char)(code_point >> 12) + 0xE0);\n"
  "      buf_cadd(bf, (unsigned char)((code_point >> 6) & 0x3F) + 0x80);\n"
  "      buf_cadd(bf, (unsigned char)(code_point & 0x3F) + 0x80);\n"
  "    } else if (code_point <= 0x10FFFF) {\n"
  "      buf_cadd(bf, (unsigned char)(code_point >> 18) + 0xF0);\n"
  "      buf_cadd(bf, (unsigned char)((code_point >> 12) & 0x3F) + 0x80);\n"
  "      buf_cadd(bf, (unsigned char)((code_point >> 6) & 0x3F) + 0x80);\n"
  "      buf_cadd(bf, (unsigned char)(code_point & 0x3F) + 0x80);\n"
  "    } else {\n"
  "      buf_add(bf, replace_error);\n"
  "    }\n"
  "  }\n"
  "\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "\n"
  "char *str_from_iso(char *s) {\n"
  "  Buf *bf = buf_new();\n"
  "  unsigned char ch = *s++;\n"
  "  while (ch) {\n"
  "    if(ch < 0x80) {\n"
  "      buf_cadd(bf, ch);\n"
  "    } else {\n"
  "      buf_cadd(bf, 0xc0 | (ch & 0xc0) >> 6);\n"
  "      buf_cadd(bf, 0x80 | (ch & 0x3f));\n"
  "    }\n"
  "    ch = *s++;\n"
  "  }\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "\n"
  "char *str_to_upper (char *s) {\n"
  "  unsigned *ws = str_to_unicode(s);\n"
  "  unsigned *p = ws;\n"
  "  while (*p) {\n"
  "    *p = (unsigned)towupper(*p);\n"
  "    ++p;\n"
  "  }\n"
  "\n"
  "  return str_from_unicode(ws);\n"
  "}\n"
  "\n"
  "char *str_to_lower (char *s) {\n"
  "  unsigned *ws = str_to_unicode(s);\n"
  "  unsigned *p = ws;\n"
  "  while (*p) {\n"
  "    *p = (unsigned)towlower(*p);\n"
  "    ++p;\n"
  "  }\n"
  "\n"
  "  return str_from_unicode(ws);\n"
  "}\n"
  "\n"
  "char *str_to_escape (char *s) {\n"
  "  Buf *bf = buf_new();\n"
  "  buf_cadd(bf, '\"');\n"
  "  while (*s) {\n"
  "    char ch = *s++;\n"
  "    if (ch == '\"' || ch == '\\\\') {\n"
  "      buf_cadd(bf, '\\\\');\n"
  "    }\n"
  "    buf_cadd(bf, ch);\n"
  "  }\n"
  "  buf_cadd(bf, '\"');\n"
  "\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "\n"
  "char *str_from_escape (char *s) {\n"
  "  int len = strlen(s);\n"
  "  if (len < 2) {\n"
  "    return str_new(s);\n"
  "  }\n"
  "\n"
  "  ++s;\n"
  "  Buf *bf = buf_new();\n"
  "  while (*s) {\n"
  "    char ch = *s++;\n"
  "    if (ch != '\\\\') {\n"
  "      buf_cadd(bf, ch);\n"
  "    } else {\n"
  "      buf_cadd(bf, *s++);\n"
  "    }\n"
  "  }\n"
  "\n"
  "  return str_left(buf_str(bf), buf_len(bf) - 1);\n"
  "}\n"
  "\n"
  "\n"
  "//\n"
  "// sys.c ---------------------------------\n"
  "//\n"
  "// Copyright 21-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "#define _GNU_SOURCE // Need for environ\n"
  "\n"
  "static int initialized = FALSE;\n"
  "\n"
  "void sys_init(void) {\n"
  "  if (initialized)\n"
  "    EXC_ILLEGAL_STATE(\"module 'sys' already initialized\");\n"
  "\n"
  "  initialized = TRUE;\n"
  "  setlocale(LC_ALL, \"C\");\n"
  "\n"
  "  srand(time(0));\n"
  "  exc_init();\n"
  "  signal(SIGPIPE, SIG_IGN); // Control over tcp_write.\n"
  "}\n"
  "\n"
  "// <char>\n"
  "Map *sys_environ(void) {\n"
  "  //<char>\n"
  "  Map *r = map_new();\n"
  "  char **penv = environ;\n"
  "  while (*penv) {\n"
  "    // <char>\n"
  "    Arr *parts = str_csplit_trim(*penv++, '=');\n"
  "    map_put(r, arr_get(parts, 0), arr_get(parts, 1));\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "void sys_sleep (int millis) {\n"
  "  Time end = time_now() + millis;\n"
  "  struct timespec t;\n"
  "  struct timespec rem;\n"
  "\n"
  "  for (;;) {\n"
  "    t.tv_sec = millis / 1000;\n"
  "    t.tv_nsec = (millis % 1000) * 1000000;\n"
  "    if (nanosleep(&t, &rem)) {\n"
  "      millis = end - time_now();\n"
  "      if (millis <= 0) break;\n"
  "    } else {\n"
  "      break;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "\n"
  "void sys_set_locale (char *language) {\n"
  "  setlocale (LC_ALL, language);\n"
  "}\n"
  "\n"
  "char *sys_get_locale (void) {\n"
  "  return setlocale (LC_ALL, NULL);\n"
  "}\n"
  "\n"
  "double sys_rnd_d (void) {\n"
  "  return (double)rand() / (double)RAND_MAX;\n"
  "}\n"
  "\n"
  "int sys_rnd_i (int top) {\n"
  "  return (int)(sys_rnd_d() * top);\n"
  "}\n"
  "\n"
  "int sys_user_id(void) {\n"
  "  return getuid();\n"
  "}\n"
  "\n"
  "char *sys_user_name() {\n"
  "  char *name = opt_get(map_get(sys_environ(), \"USER\"));\n"
  "  if (name) return name;\n"
  "  return \"\";\n"
  "}\n"
  "\n"
  "char *sys_user_home(void) {\n"
  "  char *home = opt_get(map_get(sys_environ(), \"HOME\"));\n"
  "  if (home) return home;\n"
  "  return \"\";\n"
  "}\n"
  "\n"
  "\n"
  "static char *cmd_error(char *command, char *error) {\n"
  "  return str_f(\"'%s' error:\\n  %s\", command, error);\n"
  "}\n"
  "\n"
  "// <char>\n"
  "Rs *sys_cmd(char *command) {\n"
  "  Tp *tp = sys_cmd2(command);\n"
  "  return (*(char *)tp_e2(tp)) ? rs_fail(tp_e2(tp)) : rs_ok(tp_e1(tp));\n"
  "}\n"
  "\n"
  "// <<char>, <char>>\n"
  "Tp *sys_cmd2(char *command) {\n"
  "  char *cmd2 = str_new(command);\n"
  "  char *p = cmd2;\n"
  "  while (*p) {\n"
  "    char ch = *p;\n"
  "    if (!(\n"
  "      (ch >= 'A' && ch <= 'Z') ||\n"
  "      (ch >= 'a' && ch <= 'z') ||\n"
  "      (ch >= '0' && ch <= '9')\n"
  "    )) *p = '_';\n"
  "\n"
  "    ++p;\n"
  "  }\n"
  "  Tp *r;\n"
  "  char *ferr = file_tmp(\n"
  "    \"/tmp\",\n"
  "    str_f(\"cmd_%s_\", str_left(cmd2, 50))\n"
  "  );\n"
  "  TRY {\n"
  "    char *cmd = str_f(\"%s 2>%s\", command, ferr);\n"
  "\n"
  "    FILE *fp = popen(cmd, \"r\");\n"
  "    if (!fp) EXC_GENERIC(cmd_error(command, \"Command could no be run\"));\n"
  "\n"
  "    Buf *bf = buf_new();\n"
  "    char *line = NULL;\n"
  "    size_t len = 0;\n"
  "    for (;;) {\n"
  "      line = NULL;\n"
  "      len = 0;\n"
  "      int rs = getline(&line, &len, fp);\n"
  "      if (rs == -1) {\n"
  "        if (feof(fp)) break;\n"
  "        EXC_GENERIC(cmd_error(command, \"Error while running\"));\n"
  "      }\n"
  "      len = strlen(line);\n"
  "      if (len != rs) {\n"
  "        free(line);\n"
  "        EXC_GENERIC(cmd_error(command, str_f(\n"
  "          \"getline result (%d) and line length(%d) do not match (ceros?)\",\n"
  "          rs, len\n"
  "        )));\n"
  "      }\n"
  "\n"
  "      buf_add(bf, line);\n"
  "      free(line);\n"
  "    }\n"
  "    free(line);\n"
  "    pclose(fp);\n"
  "\n"
  "    char *err = file_exists(ferr) ? file_read(ferr) : \"\";\n"
  "    r = tp_new(str_new(buf_str(bf)), err);\n"
  "  } CATCH (e) {\n"
  "    r = tp_new(\"\", exc_msg(e));\n"
  "  }_TRY\n"
  "\n"
  "  file_del(ferr);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "char *sys_read_line (void) {\n"
  "  char *s = malloc(150);\n"
  "  size_t n = 150;\n"
  "  if (getline(&s, &n, stdin) == -1) {\n"
  "    free(s); // correct\n"
  "    EXC_IO(\"Fail reading on console\");\n"
  "  }\n"
  "  char *r = str_left(s, -1);\n"
  "  free(s);  // correct\n"
  "  return r;\n"
  "}\n"
  "\n"
  "\n"
  "//\n"
  "// tcp.c ---------------------------------\n"
  "//\n"
  "// Copyright 23-Jan-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "\n"
  "struct tcp_TcpServer {\n"
  "  int id;\n"
  "};\n"
  "\n"
  "struct tcp_TcpConn {\n"
  "  int id;\n"
  "};\n"
  "\n"
  "TcpServer *tcp_server (int port, int conns) {\n"
  "  TcpServer *this = MALLOC(TcpServer);\n"
  "\n"
  "  struct sockaddr_in server;\n"
  "  int id = socket(AF_INET , SOCK_STREAM , 0);\n"
  "  if (id == -1)\n"
  "    EXC_IO(\"Could not create socket\");\n"
  "\n"
  "  server.sin_family = AF_INET;\n"
  "  server.sin_addr.s_addr = INADDR_ANY;\n"
  "  server.sin_port = htons(port);\n"
  "\n"
  "  if(bind(id,(struct sockaddr *)&server , sizeof(server)) < 0)\n"
  "    EXC_IO(\"bind failed. Error\");\n"
  "\n"
  "  listen(id, conns);\n"
  "\n"
  "  this->id = id;\n"
  "\n"
  "  return this;\n"
  "}\n"
  "\n"
  "// <TcpConn>\n"
  "Rs *tcp_accept (TcpServer *sv) {\n"
  "  TcpConn *r = MALLOC(TcpConn);\n"
  "\n"
  "  struct sockaddr_in client;\n"
  "  int c = sizeof(struct sockaddr_in);\n"
  "  int id = accept(sv->id, (struct sockaddr *)&client, (socklen_t*)&c);\n"
  "  if (id < 0)\n"
  "    return rs_fail(\"accept failed\");\n"
  "\n"
  "  r->id = id;\n"
  "  return rs_ok(r);\n"
  "}\n"
  "\n"
  "// <Bytes>\n"
  "Rs *tcp_read (TcpConn *conn, int len, int seconds) {\n"
  "  fd_set set;\n"
  "  struct timeval timeout;\n"
  "  FD_ZERO (&set);\n"
  "  FD_SET (conn->id, &set);\n"
  "  timeout.tv_sec = seconds;\n"
  "  timeout.tv_usec = 0;\n"
  "\n"
  "  int rsel;\n"
  "  for (;;) {\n"
  "    rsel = select (FD_SETSIZE, &set, NULL, NULL, &timeout);\n"
  "    if (rsel < 0 && errno == EINTR) continue;\n"
  "    break;\n"
  "  }\n"
  "  if (rsel < 0)\n"
  "    return rs_fail(str_f(\n"
  "      \"Fail reading on connection (select): %s\", strerror(errno)\n"
  "    ));\n"
  "  if (rsel == 0)\n"
  "    return rs_fail(\"Time out\");\n"
  "\n"
  "  unsigned char bs[len];\n"
  "  int rlen;\n"
  "  for (;;) {\n"
  "    rlen = (int)read(conn->id, bs, len);\n"
  "    if (rlen < 0 && errno == EINTR) continue;\n"
  "    break;\n"
  "  }\n"
  "  if (rlen < 0) {\n"
  "    close(conn->id);\n"
  "    return rs_fail(str_f(\n"
  "      \"Fail reading on connection (recv): %s\", strerror(errno)\n"
  "    ));\n"
  "  }\n"
  "\n"
  "  int tt = rlen;\n"
  "  if (!memcmp(\"POST \", bs, 5)) {\n"
  "    unsigned char *pbs = bs;\n"
  "    int ix = -1;\n"
  "    int ibody = -1;\n"
  "    for (int i = 0; i < 5000; ++i, ++pbs) {\n"
  "      if (!memcmp(\"Content-Length: \", pbs, 16)) {\n"
  "        ix = i + 16;\n"
  "      } else if (!memcmp(\"\\r\\n\\r\\n\", pbs, 4)) {\n"
  "        ibody = i + 4;\n"
  "      }\n"
  "    }\n"
  "    if (ix != -1 && ibody != -1) {\n"
  "      char sn[9];\n"
  "      memcpy(sn, bs + ix, 8);\n"
  "      sn[8] = 0;\n"
  "      int post_len = atoi(sn) + ibody;\n"
  "      if (post_len > len)\n"
  "        return rs_fail(str_f(\n"
  "          \"Post request length (%d) > maximum (%d\", post_len, len\n"
  "        ));\n"
  "\n"
  "      while (tt < post_len) {\n"
  "        for (;;) {\n"
  "          rlen = (int)read(conn->id, bs + tt, len - tt);\n"
  "          if (rlen < 0 && errno == EINTR) continue;\n"
  "          break;\n"
  "        }\n"
  "        if (rlen < 0) {\n"
  "          close(conn->id);\n"
  "          return rs_fail(str_f(\n"
  "            \"Fail reading on connection (recv): %s\", strerror(errno)\n"
  "          ));\n"
  "        }\n"
  "        if (rlen == 0)\n"
  "          return rs_fail(\"Incomplete POST request\");\n"
  "        tt += rlen;\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "\n"
  "  Bytes *r = bytes_new();\n"
  "  bytes_add_bytes(r, bs, tt);\n"
  "  return rs_ok(r);\n"
  "}\n"
  "\n"
  "char *tcp_write (TcpConn *conn, Bytes *bs) {\n"
  "  int rs;\n"
  "  for (;;) {\n"
  "    rs = send(conn->id, bytes_bs(bs), bytes_len(bs), 0);\n"
  "    if (rs == -1 && errno == EINTR) continue;\n"
  "    break;\n"
  "  }\n"
  "  if (rs == -1) {\n"
  "    close(conn->id);\n"
  "    return str_f(\"Fail sending on connection: %s\", strerror(errno));\n"
  "  }\n"
  "  fsync(conn->id);\n"
  "  return \"\";\n"
  "}\n"
  "\n"
  "// <TcpConn>\n"
  "Rs *tcp_dial (char *sv, int port) {\n"
  "  struct sockaddr_in server;\n"
  "  int id = socket(AF_INET , SOCK_STREAM , 0);\n"
  "  if (id == -1) return rs_fail(\"Could not create socket\");\n"
  "  int oldflags = fcntl (id, F_GETFL, 0);\n"
  "  if (oldflags == -1) return rs_fail(\"Could not create socket\");\n"
  "  if (fcntl (id, F_SETFL, oldflags) == -1)\n"
  "    return rs_fail(\"Could not create socket\");\n"
  "\n"
  "  server.sin_family = AF_INET;\n"
  "  server.sin_port = htons(port);\n"
  "  if (!inet_aton(sv, &server.sin_addr)) {\n"
  "    struct hostent *he;\n"
  "    if ((he = gethostbyname(sv)) == NULL)\n"
  "      return rs_fail(str_f(\"Host '%s' not found\", sv));\n"
  "    server.sin_addr = *(struct in_addr *) he->h_addr;\n"
  "  }\n"
  "\n"
  "  if (connect(id , (struct sockaddr *)&server , sizeof(server)) < 0)\n"
  "    return rs_fail(str_f(\"Fail connection with '%s'\", sv));\n"
  "\n"
  "  TcpConn *r = MALLOC(TcpConn);\n"
  "  r->id = id;\n"
  "  return rs_ok(r);\n"
  "}\n"
  "\n"
  "void tcp_close_server (TcpServer *sv) {\n"
  "  close(sv->id);\n"
  "}\n"
  "\n"
  "void tcp_close_conn (TcpConn *conn) {\n"
  "  close(conn->id);\n"
  "}\n"
  "\n"
  "\n"
  "// INTERFACE ----------------------------------------\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//02-built_in\n"
  "// -------------------------------------\n"
  "\n"
  "void ___built_jump (int reference) {\n"
  "Exc *exc = exc_get();\n"
  "longjmp(*((jmp_buf *)arr_pop(exc->buf)), reference);\n"
  "}\n"
  "char *___built_mpos(char *module_ln) {\n"
  "char *mpath(char *module_id) {\n"
  "char *data = file_read(path_cat(__sys_compilerRoot().s, \"index.tb\", NULL));\n"
  "Arr *tb = js_ra(data);\n"
  "EACH(tb, char, e) {\n"
  "Arr *fs = js_ra(e);\n"
  "if (!strcmp(js_rs(arr_get(fs, 1)), module_id))\n"
  "return js_rs(arr_get(fs, 0));\n"
  "}_EACH\n"
  "return str_f(\"?(%s)\", module_id);\n"
  "}\n"
  "int ix = str_cindex(module_ln, ':');\n"
  "return str_f(\"%s%s:\", mpath(str_left(module_ln, ix)), module_ln + ix);\n"
  "}\n"
  "char *___built_stack_line (char *e) {\n"
  "char *path = path_cat(__sys_compilerRoot().s, \"compilationDb\", NULL);\n"
  "int ix1 = str_last_cindex(e, ')');\n"
  "if (ix1 == -1) return \"\";\n"
  "e = str_left(e, ix1);\n"
  "ix1 = str_cindex(e, '(');\n"
  "if (ix1 == -1) return \"\";\n"
  "e = str_right(e, ix1 + 1);\n"
  "ix1 = str_cindex(e, '_');\n"
  "if (ix1 == -1) return \"\";\n"
  "ix1 = str_cindex_from(e, '_', ix1 + 1);\n"
  "if (ix1 == -1) return \"\";\n"
  "int ix2 = str_cindex_from(e, '_', ix1 + 1);\n"
  "if (ix2 == -1) {\n"
  "if (str_starts(str_right(e, ix1), \"_main+\")) ix2 = ix1 + 5;\n"
  "else return \"\";\n"
  "}\n"
  "char *mdId = str_left(e, ix1);\n"
  "char *fn = str_sub(e, ix1 + 1, ix2);\n"
  "char *mdPath = path_cat(path, str_f(\"%s.mod\", mdId), NULL);\n"
  "if (!file_exists(mdPath)) return \"\";\n"
  "Arr *tb = js_ra(file_read(mdPath));\n"
  "char *fpath = js_rs(arr_get(tb, 0));\n"
  "if (!strcmp(fn, \"main\")) return str_f(\"  %s:[main]\", fpath);\n"
  "Arr *fn_tb = js_ra(arr_get(tb, 3));\n"
  "int n = -1;\n"
  "EACH(fn_tb, char, e) {\n"
  "Arr *fields = js_ra(e);\n"
  "if (!strcmp(js_rs(arr_get(fields, 1)), fn)) {\n"
  "n = js_ri(arr_get(fields, 0));\n"
  "break;\n"
  "}\n"
  "}_EACH\n"
  "if (n != -1) return str_f(\"  %s:%d:\", fpath, n);\n"
  "return \"\";\n"
  "}\n"
  "Val ___built_divi(char *pos, Val n1, Val n2) {\n"
  "if (n2.i == 0) ___built_throw(pos, (Val)\"Division by 0\");\n"
  "return (Val) (n1.i / n2.i);\n"
  "}\n"
  "Val ___built_divf(char *pos, Val n1, Val n2) {\n"
  "if (math_eq(n2.f, 0)) ___built_throw(pos, (Val)\"Division by 0\");\n"
  "return (Val) (n1.f / n2.f);\n"
  "}\n"
  "Val ___built_eq (Val type, Val value1, Val value2) {\n"
  "char *t = __arr_get(type, (Val)0).s;\n"
  "if (*t == 'b') return (Val)(value1.b == value2.b);\n"
  "if (*t == 'i') return (Val)(value1.i == value2.i);\n"
  "if (*t == 'f') return (Val)(math_eq(value1.f, value2.f));\n"
  "if (*t == 's') return (Val)(!strcmp(value1.s, value2.s));\n"
  "if (*t == 'a') {\n"
  "if (__arr_size(value1).i != __arr_size(value2).i) return (Val)FALSE;\n"
  "Val atp = __arr_get(__arr_get(type, (Val)1), (Val)0);\n"
  "Varr *a1 = value1.a;\n"
  "Varr *a2 = value2.a;\n"
  "Val *e1 = a1->begin;\n"
  "Val *e2 = a2->begin;\n"
  "Val *end = a1->end;\n"
  "while (e1 < end) {\n"
  "if (!___built_eq(atp, *e1++, *e2++).b) return (Val)FALSE;\n"
  "}\n"
  "return (Val)TRUE;\n"
  "}\n"
  "if (*t == 'd') {\n"
  "if (__arr_size(value1).i != __arr_size(value2).i) return (Val)FALSE;\n"
  "Val dtp = __arr_get(__arr_get(type, (Val)1), (Val)0);\n"
  "Varr *a = value1.a;\n"
  "Val *e = a->begin;\n"
  "Val *end = a->end;\n"
  "while (e < end) {\n"
  "Varr *kv = (*e++).a;\n"
  "Val rs = __dic_get(value2, kv->begin[0]);\n"
  "if (\n"
  "!__arr_size(rs).i |\n"
  "!___built_eq(dtp, kv->begin[1], rs.a->begin[0]).b\n"
  ") return (Val)FALSE;\n"
  "}\n"
  "return (Val)TRUE;\n"
  "}\n"
  "if (*t == 't') {\n"
  "Varr *atp = __arr_get(type, (Val)1).a;\n"
  "Val *etp = atp->begin;\n"
  "Val *endtp = atp->end;\n"
  "Varr *a1 = value1.a;\n"
  "Varr *a2 = value2.a;\n"
  "Val *e1 = a1->begin;\n"
  "Val *e2 = a2->begin;\n"
  "while (etp < endtp) {\n"
  "if (!___built_eq(*etp++, *e1++, *e2++).b) return (Val)FALSE;\n"
  "}\n"
  "return (Val)TRUE;\n"
  "}\n"
  "return (Val)(value1.o == value2.o);\n"
  "}\n"
  "Val ___built_to_str_trace (Val type, Val value) {\n"
  "char *t = __arr_get(type, (Val)0).s;\n"
  "return (*t == 's')\n"
  "? __js_ws(value)\n"
  ": ___built_to_str(type, value)\n"
  ";\n"
  "}\n"
  "Val ___built_to_str (Val type, Val value) {\n"
  "char *t = __arr_get(type, (Val)0).s;\n"
  "if (*t == 'b') return value.b ? (Val)\"true\" : (Val)\"false\";\n"
  "if (*t == 'i') return __math_itos(value);\n"
  "if (*t == 'f') {\n"
  "char *r = math_ftos(value.f, 9);\n"
  "if (str_cindex(r, '.') == -1) r = str_f(\"%s.0\", r);\n"
  "return (Val)r;\n"
  "}\n"
  "if (*t == 's') return value;\n"
  "if (*t == 'a') {\n"
  "Val atp = __arr_get(__arr_get(type, (Val)1), (Val)0);\n"
  "Arr *bf = arr_new(); // [s.]\n"
  "Varr *a = value.a;\n"
  "Val *e = a->begin;\n"
  "Val *end = a->end;\n"
  "while (e < end) {\n"
  "arr_push(bf, ___built_to_str_trace(atp, *e++).s);\n"
  "}\n"
  "return (Val)str_f(\"[%s]\", arr_join(bf, \",\"));\n"
  "}\n"
  "if (*t == 'd') {\n"
  "Val dtp = __arr_get((__arr_get(type, (Val)1)), (Val)0);\n"
  "Arr *bf = arr_new(); // [s.]\n"
  "Varr *a = value.a;\n"
  "Val *e = a->begin;\n"
  "Val *end = a->end;\n"
  "while (e < end) {\n"
  "Varr *a2 = e++->a;\n"
  "Val *e2 = a2->begin;\n"
  "char *key = js_ws((*e2++).s);\n"
  "char *value = ___built_to_str_trace(dtp, *e2).s;\n"
  "arr_push(bf, str_f(\"%s:%s\", key, value));\n"
  "}\n"
  "return (Val)str_f(\"{%s}\", arr_join(bf, \",\"));\n"
  "}\n"
  "if (*t == 't') {\n"
  "Arr *bf = arr_new(); // [s.]\n"
  "Varr *atp = __arr_get(type, (Val)1).a;\n"
  "Val *etp = atp->begin;\n"
  "Val *endtp = atp->end;\n"
  "Varr *a = value.a;\n"
  "Val *e = a->begin;\n"
  "while (etp < endtp) {\n"
  "arr_push(bf, ___built_to_str_trace(*etp++, *e++).s);\n"
  "}\n"
  "return (Val)str_f(\"[. %s]\", arr_join(bf, \",\"));\n"
  "}\n"
  "if (*t == 'r') {\n"
  "Val atp = __arr_get(__arr_get(type, (Val)1), (Val)0);\n"
  "Arr *bf = arr_new(); // [s.]\n"
  "while (__iter_hasNext(value).b)\n"
  "arr_push(bf, ___built_to_str_trace(atp, __iter_next(value)).s);\n"
  "return (Val)str_f(\"[! %s]\", arr_join(bf, \",\"));\n"
  "}\n"
  "return (Val)str_f(\"%s(%ld)\", t, (long)value.o);\n"
  "}\n"
  "void ___built_throw (char *pos, Val msg) {\n"
  "Exc *exc = exc_get();\n"
  "void *array[30];\n"
  "size_t size;\n"
  "char **strings;\n"
  "size = backtrace(array, 30);\n"
  "strings = backtrace_symbols(array, size);\n"
  "Arr *stack = arr_new();\n"
  "RANGE0(i, size) {\n"
  "char *e = ___built_stack_line(strings[i]);\n"
  "if (*e) arr_push(stack, e);\n"
  "}_RANGE\n"
  "free(strings);\n"
  "exc->stack = stack;\n"
  "exc->msg = str_f(\"%s %s\", ___built_mpos(pos), msg.s);\n"
  "exc->type = \"\";\n"
  "longjmp(*((jmp_buf *)arr_pop(exc->buf)), 1);\n"
  "}\n"
  "void ___built_trace (Val isComplete, char *pos, Val type, Val value) {\n"
  "char *r = ___built_to_str_trace(type, value).s;\n"
  "if (!(isComplete.b)) r = arr_join(arr_take(str_runes(r), 50), \"\");\n"
  "puts(str_f(\"%s %s\", ___built_mpos(pos), r));\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//arr\n"
  "// -------------------------------------\n"
  "\n"
  "Val __arr_all (Val a, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "int r = TRUE;\n"
  "while (p < end) {\n"
  "Val v = *p++;\n"
  "r = r && (((Val (*)(Val))fn.o)(v)).b;\n"
  "}\n"
  "return (Val)r;\n"
  "}\n"
  "Val __arr_any (Val a, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "int r = FALSE;\n"
  "while (p < end) {\n"
  "Val v = *p++;\n"
  "r = r || (((Val (*)(Val))fn.o)(v)).b;\n"
  "}\n"
  "return (Val)r;\n"
  "}\n"
  "void __arr_clear (Val a) {\n"
  "a.a->end = a.a->begin;\n"
  "}\n"
  "void __arr_cat (Val a, Val a2) {\n"
  "int64_t other_size = __arr_size(a2).i;\n"
  "if (other_size) {\n"
  "int64_t this_size = __arr_size(a).i;\n"
  "int64_t this_buffer = a.a->end_bf - a.a->begin;\n"
  "if (this_size + other_size >= this_buffer){\n"
  "int64_t new_buffer = this_buffer + other_size + 15;\n"
  "a.a->begin = GC_REALLOC(a.a->begin, new_buffer * sizeof(Val));\n"
  "a.a->end = a.a->begin + this_size;\n"
  "a.a->end_bf = a.a->begin + new_buffer;\n"
  "}\n"
  "Val *s = a2.a->begin;\n"
  "Val *s_end = a2.a->end;\n"
  "Val *t = a.a->end;\n"
  "while (s < s_end) *t++ = *s++;\n"
  "a.a->end = t;\n"
  "}\n"
  "}\n"
  "Val __arr_cat2 (Val a, Val a2) {\n"
  "Val r = __arr_copy(a);\n"
  "__arr_cat(r, a2);\n"
  "return r;\n"
  "}\n"
  "Val __arr_copy (Val a) {\n"
  "Varr *this = a.a;\n"
  "int64_t size = this->end - this->begin;\n"
  "int64_t buffer = this->end_bf - this->begin;\n"
  "Varr *r = MALLOC(Varr);\n"
  "Val *begin = GC_MALLOC(buffer * sizeof(Val));\n"
  "memcpy(begin, this->begin, size * sizeof(Val));\n"
  "r->begin = begin;\n"
  "r->end = begin + size;\n"
  "r->end_bf = begin + buffer;\n"
  "return (Val)r;\n"
  "}\n"
  "Val __arr_drop (Val a, Val n) {\n"
  "if (n.i < 0) return __arr_copy(a);\n"
  "if (n.i >= __arr_size(a).i) return __arr_new();\n"
  "Val r = __arr_new();\n"
  "Val *p = a.a->begin + n.i;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) __arr_push(r, *p++);\n"
  "return r;\n"
  "}\n"
  "Val __arr_dropWhile (Val a, Val fn) {\n"
  "Val r = __arr_new();\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) {\n"
  "if (!(((Val (*)(Val))fn.o)(*p)).b) break;\n"
  "++p;\n"
  "}\n"
  "while (p < end) __arr_push(r, *p++);\n"
  "return r;\n"
  "}\n"
  "Val __arr_duplicates (Val a, Val fn) {\n"
  "Val r = __arr_new();\n"
  "Val dup = __arr_new();\n"
  "Val *ap = a.a->begin;\n"
  "Val *aend = a.a->end;\n"
  "while (ap < aend) {\n"
  "Val e = *ap++;\n"
  "Val *rp = r.a->begin;\n"
  "Val *rend = r.a->end;\n"
  "int missing = TRUE;\n"
  "while (rp < rend) {\n"
  "Val e2 = *rp++;\n"
  "if ((((Val (*)(Val,Val))fn.o)(e, e2)).b) {\n"
  "missing = FALSE;\n"
  "Val *dp = dup.a->begin;\n"
  "Val *dend = dup.a->end;\n"
  "int missing2 = TRUE;\n"
  "while (dp < dend) {\n"
  "Val e2 = *dp++;\n"
  "if ((((Val (*)(Val,Val))fn.o)(e, e2)).b) {\n"
  "missing2 = FALSE;\n"
  "break;\n"
  "}\n"
  "}\n"
  "if (missing2) __arr_push(dup, e);\n"
  "break;\n"
  "}\n"
  "}\n"
  "if (missing) __arr_push(r, e);\n"
  "}\n"
  "return __arr_new_from_carr((Val)2, (Val[]){r, dup});\n"
  "}\n"
  "void __arr_each (Val a, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) ((void (*)(Val))fn.o)(*p++);\n"
  "}\n"
  "void __arr_eachIx (Val a, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "int64_t i = 0;\n"
  "while (p < end) ((void (*)(Val,Val))fn.o)(*p++, ((Val)i++));\n"
  "}\n"
  "Val __arr_filter (Val a, Val fn) {\n"
  "Val r = __arr_new();\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) {\n"
  "Val e = *p++;\n"
  "if ((((Val (*)(Val))fn.o)(e)).b) __arr_push(r, e);\n"
  "}\n"
  "return (Val)r;\n"
  "}\n"
  "void __arr_filterIn (Val a, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "Val *new_end = p;\n"
  "while (p < end) {\n"
  "Val e = *p++;\n"
  "if ((((Val (*)(Val))fn.o)(e)).b) *new_end++ = e;\n"
  "}\n"
  "a.a->end = new_end;\n"
  "}\n"
  "Val __arr_find (Val a, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) {\n"
  "Val e = *p++;\n"
  "if ((((Val (*)(Val))fn.o)(e)).b)\n"
  "return __arr_new_from_carr((Val)1, (Val[]){e});\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __arr_fromIter (Val it) {\n"
  "Val a = __arr_new();\n"
  "while (__iter_hasNext(it).b) __arr_push(a, __iter_next(it));\n"
  "return a;\n"
  "}\n"
  "Val __arr_fromJs (Val s, Val fn) {\n"
  "return __arr_map(__js_ra(s), fn);\n"
  "}\n"
  "Val __arr_from_sarr (Arr *a) {\n"
  "Val r = __arr_new();\n"
  "EACH(a, char, el) {\n"
  "__arr_push(r, (Val)el);\n"
  "}_EACH\n"
  "return r;\n"
  "}\n"
  "Val __arr_get (Val a, Val ix) {\n"
  "return a.a->begin[ix.i];\n"
  "}\n"
  "Val __arr_get2 (char *pos, Val a, Val ix) {\n"
  "Varr *arr = a.a;\n"
  "int64_t sz = arr->end - arr->begin;\n"
  "int64_t i = ix.i;\n"
  "if (i < 0 || i >= sz)\n"
  "___built_throw(pos, (Val)str_f(\"Index %d out of [0,%d]\", i, sz - 1));\n"
  "return arr->begin[i];\n"
  "}\n"
  "Val __arr_index (Val a, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "int64_t i = 0;\n"
  "while (p < end) {\n"
  "if ((((Val (*)(Val))fn.o)(*p++)).b) return (Val)i;\n"
  "++i;\n"
  "}\n"
  "return (Val)(int64_t)-1;\n"
  "}\n"
  "void __arr_insert (char *pos, Val a, Val ix, Val e) {\n"
  "int64_t size = __arr_size(a).i;\n"
  "if (ix.i < 0 || ix.i > size)\n"
  "___built_throw(pos, (Val)str_f(\"index %d out of [0,%d]\", ix.i, size));\n"
  "__arr_push(a, e);\n"
  "Val *p = a.a->end;\n"
  "Val *pix = a.a->begin + ix.i;\n"
  "while (p > pix) {\n"
  "*p = *(p - 1);\n"
  "--p;\n"
  "}\n"
  "*p = e;\n"
  "}\n"
  "void __arr_insertArr (char *pos, Val a, Val ix, Val other) {\n"
  "__arr_insertRange(pos, a, ix, other, (Val)0, __arr_size(other));\n"
  "}\n"
  "void __arr_insertRange (char *pos, Val this, Val ix, Val other, Val begin, Val end) {\n"
  "int64_t this_len = __arr_size(this).i;\n"
  "if (ix.i < 0 || ix.i > this_len)\n"
  "___built_throw(pos, (Val)str_f(\"index %d out of [0,%d]\", ix.i, this_len));\n"
  "int64_t other_size = __arr_size(other).i;\n"
  "if (end.i < begin.i)\n"
  "___built_throw(pos, (Val)str_f(\"end(%d) < begin(%d)\", end.i, begin.i));\n"
  "if (begin.i < 0)\n"
  "___built_throw(pos, (Val)str_f(\"begin(%d) < 0\", begin.i));\n"
  "if (end.i > other_size)\n"
  "___built_throw(pos, (Val)str_f(\"end(%d) > size(%d)\", end.i, other_size));\n"
  "int64_t other_len = end.i - begin.i;\n"
  "if (!other_len) return;\n"
  "int64_t new_len = this_len + other_len;\n"
  "int64_t new_size = new_len + 15;\n"
  "Val *new_begin = GC_MALLOC(new_size * sizeof(Val));\n"
  "memcpy(new_begin, this.a->begin, sizeof(Val) * ix.i);\n"
  "memcpy(new_begin + ix.i, other.a->begin + begin.i, sizeof(Val) * other_len);\n"
  "memcpy(\n"
  "new_begin + (ix.i + other_len),\n"
  "this.a->begin + ix.i,\n"
  "sizeof(Val) * (__arr_size(this).i - ix.i)\n"
  ");\n"
  "this.a->begin = new_begin;\n"
  "this.a->end = new_begin + new_len;\n"
  "this.a->end_bf = new_begin + new_size;\n"
  "}\n"
  "Val __arr_join(Val a, Val sep) {\n"
  "Buf *bf = buf_new();\n"
  "int first = 1;\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) {\n"
  "if (first) {\n"
  "first = 0;\n"
  "} else {\n"
  "buf_add(bf, sep.s);\n"
  "}\n"
  "buf_add(bf, (*p++).s);\n"
  "}\n"
  "return (Val)str_new(buf_str(bf));\n"
  "}\n"
  "Val __arr_map(Val a, Val fn) {\n"
  "Val r = __arr_new();\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) __arr_push(r, ((Val (*)(Val))fn.o)(*p++));\n"
  "return r;\n"
  "}\n"
  "Val __arr_new (void) {\n"
  "Varr *this = MALLOC(Varr);\n"
  "this->begin = GC_MALLOC(15 * sizeof(Val));\n"
  "this->end = this->begin;\n"
  "this->end_bf = this->begin + 15;\n"
  "return (Val)this;\n"
  "}\n"
  "Val __arr_new_fill (Val el, Val n) {\n"
  "int64_t size = n.i < 0 ? 0 : n.i;\n"
  "int64_t bf_size = size + 15;\n"
  "Varr *this = MALLOC(Varr);\n"
  "this->begin = GC_MALLOC(bf_size * sizeof(Val));\n"
  "this->end = this->begin + size;\n"
  "this->end_bf = this->begin + bf_size;\n"
  "Val *p = this->begin;\n"
  "Val *end = this->end;\n"
  "while (p < end) *p++ = el;\n"
  "return (Val)this;\n"
  "}\n"
  "Val __arr_new_from_carr (Val n, Val *els) {\n"
  "Val r = __arr_new();\n"
  "REPEAT(n.i) {\n"
  "__arr_push(r, *els++);\n"
  "}_REPEAT\n"
  "return r;\n"
  "}\n"
  "Val __arr_peek (char *pos, Val a) {\n"
  "int64_t size = __arr_size(a).i;\n"
  "if (size == 0) ___built_throw(pos, (Val)\"Array is empty\");\n"
  "return *(a.a->end - 1);\n"
  "}\n"
  "Val __arr_pop (char *pos, Val a) {\n"
  "int64_t size = __arr_size(a).i;\n"
  "if (size == 0) ___built_throw(pos, (Val)\"Array is empty\");\n"
  "return *(a.a->end-- - 1);\n"
  "}\n"
  "void __arr_push (Val a, Val el) {\n"
  "Varr *this = a.a;\n"
  "if (this->end == this->end_bf) {\n"
  "int size = this->end_bf - this->begin;\n"
  "int new_size = size + size;\n"
  "this->begin = GC_REALLOC(this->begin, new_size * sizeof(Val));\n"
  "this->end = this->begin + size;\n"
  "this->end_bf = this->begin + new_size;\n"
  "}\n"
  "*this->end++ = el;\n"
  "}\n"
  "Val __arr_reduce (Val a, Val seed, Val fn) {\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) seed = ((Val (*)(Val,Val))fn.o)(seed, *p++);\n"
  "return seed;\n"
  "}\n"
  "Val __arr_remove (char *pos, Val a, Val ix) {\n"
  "int64_t sz = __arr_size(a).i;\n"
  "int64_t i = ix.i;\n"
  "if (i < 0 || i >= sz)\n"
  "___built_throw(pos, (Val)str_f(\"index %d out of [0,%d]\", i, sz - 1));\n"
  "Val *p = a.a->begin + ix.i;\n"
  "Val r = *p;\n"
  "Val *p1 = p + 1;\n"
  "Val *end = a.a->end--;\n"
  "while (p1 < end) *p++ = *p1++;\n"
  "return r;\n"
  "}\n"
  "Val __arr_removeRange (char *pos, Val a, Val begin, Val end) {\n"
  "int64_t sz = __arr_size(a).i;\n"
  "int64_t b = begin.i;\n"
  "int64_t e = end.i;\n"
  "if (b < 0 || b >= sz)\n"
  "___built_throw(pos, (Val)str_f(\"begin index %d out of [0,%d]\", b, sz - 1));\n"
  "if (e < b || e > sz)\n"
  "___built_throw(pos, (Val)str_f(\"end index %d out of [%d,%d]\", e, b, sz));\n"
  "int64_t len = e - b;\n"
  "Val r = __arr_take(__arr_drop(a, begin), (Val)len);\n"
  "Val *p = a.a->begin + b;\n"
  "Val *p1 = a.a->begin + e;\n"
  "Val *pend = a.a->end;\n"
  "a.a->end -= len;\n"
  "while (p1 < pend) *p++ = *p1++;\n"
  "return r;\n"
  "}\n"
  "Val __arr_reverse (Val a) {\n"
  "Val r = __arr_copy(a);\n"
  "__arr_reverseIn(r);\n"
  "return r;\n"
  "}\n"
  "void __arr_reverseIn (Val a) {\n"
  "int64_t sz = __arr_size(a).i;\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end - 1;\n"
  "Val tmp;\n"
  "for (int i = 0; i < sz / 2; ++i) {\n"
  "tmp = *p;\n"
  "*p++ = *end;\n"
  "*end-- = tmp;\n"
  "}\n"
  "}\n"
  "void __arr_set (Val a, Val ix, Val el) {\n"
  "a.a->begin[ix.i] = el;\n"
  "}\n"
  "void __arr_set2 (char *pos, Val a, Val ix, Val el) {\n"
  "Varr *arr = a.a;\n"
  "int64_t sz = arr->end - arr->begin;\n"
  "int64_t i = ix.i;\n"
  "if (i < 0 || i >= sz)\n"
  "___built_throw(pos, (Val)str_f(\"index %d out of [0,%d]\", i, sz - 1));\n"
  "arr->begin[i] = el;\n"
  "}\n"
  "void __arr_setArr (char *pos, Val a, Val ix, Val other) {\n"
  "__arr_setRange(pos, a, ix, other, (Val)0, __arr_size(other));\n"
  "}\n"
  "void __arr_setRange (char *pos, Val this, Val ix, Val other, Val begin, Val end) {\n"
  "int64_t this_len = __arr_size(this).i;\n"
  "int64_t other_size = __arr_size(other).i;\n"
  "if (ix.i < 0 || ix.i > this_len - other_size)\n"
  "___built_throw(\n"
  "pos, (Val)str_f(\"index %d out of [0,%d]\", ix.i, this_len - other_size)\n"
  ");\n"
  "if (end.i < begin.i)\n"
  "___built_throw(pos, (Val)str_f(\"end(%d) < begin(%d)\", end.i, begin.i));\n"
  "if (begin.i < 0)\n"
  "___built_throw(pos, (Val)str_f(\"begin(%d) < 0\", begin.i));\n"
  "if (end.i > other_size)\n"
  "___built_throw(pos, (Val)str_f(\"end(%d) > size(%d)\", end.i, other_size));\n"
  "int64_t other_len = end.i - begin.i;\n"
  "if (!other_len) return;\n"
  "Val *target = this.a->begin + ix.i;\n"
  "Val *source = other.a->begin + begin.i;\n"
  "memcpy(target, source, sizeof(Val *) * other_len);\n"
  "}\n"
  "Val __arr_shift (char *pos, Val a) {\n"
  "int64_t size = __arr_size(a).i;\n"
  "if (size == 0) ___built_throw(pos, (Val)\"Array is empty\");\n"
  "Val *p = a.a->begin;\n"
  "Val r = *p;\n"
  "Val *p1 = p + 1;\n"
  "Val *end = a.a->end--;\n"
  "while (p1 < end) *p++ = *p1++;\n"
  "return r;\n"
  "}\n"
  "void __arr_shuffle (Val a) {\n"
  "int64_t size = __arr_size(a).i;\n"
  "Val *begin = a.a->begin;\n"
  "Val *p = a.a->end - 1;\n"
  "Val *pix, tmp;\n"
  "while (p > begin) {\n"
  "pix = begin + sys_rnd_i(size--);\n"
  "tmp = *p;\n"
  "*p-- = *pix;\n"
  "*pix = tmp;\n"
  "}\n"
  "}\n"
  "Val __arr_size (Val a) {\n"
  "return (Val)(a.a->end - a.a->begin);\n"
  "}\n"
  "void __arr_sort (Val a, Val fn) {\n"
  "Val (*less0)(Val, Val) = (Val (*)(Val, Val))fn.o;\n"
  "int less (Val e1, Val e2) {\n"
  "return less0(e1, e2).b;\n"
  "}\n"
  "void sort(Val *a, int64_t size) {\n"
  "if (size < 2) {\n"
  "return;\n"
  "}\n"
  "if (size == 2) {\n"
  "if (less(a[1], a[0])) { Val tmp = a[0]; a[0] = a[1]; a[1] = tmp; }\n"
  "return;\n"
  "}\n"
  "if (size == 3) {\n"
  "if (less(a[1], a[0])) { Val tmp = a[0]; a[0] = a[1]; a[1] = tmp; }\n"
  "if (less(a[2], a[0])) { Val tmp = a[0]; a[0] = a[2]; a[2] = tmp; }\n"
  "if (less(a[2], a[1])) { Val tmp = a[1]; a[1] = a[2]; a[2] = tmp; }\n"
  "}\n"
  "int64_t mid1 = size >> 1;\n"
  "int64_t mid2 = size - mid1;\n"
  "Val a1[mid1];\n"
  "Val a2[mid2];\n"
  "Val *pa = a;\n"
  "Val *pa1 = a1;\n"
  "Val *pa2 = a2;\n"
  "for (int64_t i = 0; i < mid1; ++i) *pa1++ = *pa++;\n"
  "for (int64_t i = 0; i < mid2; ++i) *pa2++ = *pa++;\n"
  "sort(a1, mid1);\n"
  "sort(a2, mid2);\n"
  "pa = a;\n"
  "pa1 = a1;\n"
  "Val *pa1_end = a1 + mid1;\n"
  "pa2 = a2;\n"
  "Val *pa2_end = a2 + mid2;\n"
  "for(;;) {\n"
  "if (pa1 == pa1_end) {\n"
  "while (pa2 < pa2_end) *pa++ = *pa2++;\n"
  "break;\n"
  "}\n"
  "if (pa2 == pa2_end) {\n"
  "while (pa1 < pa1_end) *pa++ = *pa1++;\n"
  "break;\n"
  "}\n"
  "if (less(*pa2, *pa1)) *pa++ = *pa2++;\n"
  "else *pa++ = *pa1++;\n"
  "}\n"
  "}\n"
  "sort(a.a->begin, __arr_size(a).i);\n"
  "}\n"
  "Val __arr_sub (Val a, Val begin, Val end) {\n"
  "if (begin.i < 0) begin = (Val)(__arr_size(a).i + begin.i);\n"
  "if (end.i < 0) end = (Val)(__arr_size(a).i + end.i);\n"
  "return __arr_drop(__arr_take(a, end), begin);\n"
  "}\n"
  "Val __arr_sub0 (Val a, Val begin) {\n"
  "if (begin.i < 0) begin = (Val)(__arr_size(a).i + begin.i);\n"
  "return __arr_drop(a, begin);\n"
  "}\n"
  "Val __arr_take (Val a, Val n) {\n"
  "if (n.i > __arr_size(a).i) return __arr_copy(a);\n"
  "Val r = __arr_new();\n"
  "Val *p = a.a->begin;\n"
  "for (int64_t i = 0; i < n.i; ++i) __arr_push(r, *p++);\n"
  "return r;\n"
  "}\n"
  "Val __arr_takeWhile (Val a, Val fn) {\n"
  "Val r = __arr_new();\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) {\n"
  "if (!(((Val (*)(Val))fn.o)(*p)).b) break;\n"
  "__arr_push(r, *p++);\n"
  "}\n"
  "return r;\n"
  "}\n"
  "Val __arr_toIter_next (Val obj) {\n"
  "Val *p = obj.a->begin;\n"
  "Val a = *p;\n"
  "int64_t sz = (p+1)->i;\n"
  "int64_t c = (p+2)->i;\n"
  "if (c < sz) {\n"
  "Val r = *(a.a->begin+c);\n"
  "*(p+2) = (Val)(c + 1);\n"
  "return __arr_new_from_carr((Val)1, (Val[]){r});\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __arr_toIter (Val a) {\n"
  "return __iter_new(__arr_new_from_carr((Val)2, (Val[]){\n"
  "__arr_new_from_carr((Val)3, (Val[]){a, __arr_size(a), (Val)0}),\n"
  "(Val)(void *)__arr_toIter_next\n"
  "}));\n"
  "}\n"
  "Val __arr_toJs (Val a, Val fn) {\n"
  "return __js_wa(__arr_map(a, fn));\n"
  "}\n"
  "Arr *__arr_to_sarr (Val a) {\n"
  "Arr *r = arr_new();\n"
  "Varr *va = a.a;\n"
  "Val *p = va->begin;\n"
  "Val *end = va->end;\n"
  "while (p < end) arr_push(r, (*p++).s);\n"
  "return r;\n"
  "}\n"
  "void __arr_unshift (Val a, Val e) {\n"
  "__arr_push(a, e);\n"
  "Val *p = a.a->end;\n"
  "Val *pix = a.a->begin;\n"
  "while (p > pix) {\n"
  "*p = *(p - 1);\n"
  "--p;\n"
  "}\n"
  "*p = e;\n"
  "}\n"
  "Val __arr_unzip (Val a) {\n"
  "Val a1 = __arr_new();\n"
  "Val a2 = __arr_new();\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) {\n"
  "Val t = *p++;\n"
  "__arr_push(a1, *(t.a->begin));\n"
  "__arr_push(a2, *(t.a->begin + 1));\n"
  "}\n"
  "return __arr_new_from_carr((Val)2, (Val[]){a1, a2});\n"
  "}\n"
  "Val __arr_unzip3 (Val a) {\n"
  "Val a1 = __arr_new();\n"
  "Val a2 = __arr_new();\n"
  "Val a3 = __arr_new();\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) {\n"
  "Val t = *p++;\n"
  "__arr_push(a1, *(t.a->begin));\n"
  "__arr_push(a2, *(t.a->begin + 1));\n"
  "__arr_push(a3, *(t.a->begin + 2));\n"
  "}\n"
  "return __arr_new_from_carr((Val)3, (Val[]){a1, a2, a3});\n"
  "}\n"
  "Val __arr_zip (Val a1, Val a2) {\n"
  "Val r = __arr_new();\n"
  "int64_t sz = __arr_size(a1).i < __arr_size(a2).i\n"
  "? __arr_size(a1).i\n"
  ": __arr_size(a2).i\n"
  ";\n"
  "int64_t c = 0;\n"
  "Val *p1 = a1.a->begin;\n"
  "Val *p2 = a2.a->begin;\n"
  "while (c < sz) {\n"
  "__arr_push(r, __arr_new_from_carr((Val)2, (Val[]){*p1++, *p2++}));\n"
  "++c;\n"
  "}\n"
  "return r;\n"
  "}\n"
  "Val __arr_zip3 (Val a1, Val a2, Val a3) {\n"
  "Val r = __arr_new();\n"
  "int64_t sz = __arr_size(a1).i < __arr_size(a2).i\n"
  "? __arr_size(a1).i\n"
  ": __arr_size(a2).i\n"
  ";\n"
  "sz = sz < __arr_size(a3).i\n"
  "? sz\n"
  ": __arr_size(a2).i < __arr_size(a3).i\n"
  "? __arr_size(a2).i\n"
  ": __arr_size(a3).i\n"
  ";\n"
  "int64_t c = 0;\n"
  "Val *p1 = a1.a->begin;\n"
  "Val *p2 = a2.a->begin;\n"
  "Val *p3 = a3.a->begin;\n"
  "while (c < sz) {\n"
  "__arr_push(r, __arr_new_from_carr((Val)3, (Val[]){*p1++, *p2++, *p3++}));\n"
  "++c;\n"
  "}\n"
  "return r;\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//b64\n"
  "// -------------------------------------\n"
  "\n"
  "Val __b64_decode (char *pos, Val b64) {\n"
  "char *r;\n"
  "TRY {\n"
  "r = b64_decode(b64.s);\n"
  "} CATCH(e) {\n"
  "___built_throw(pos, (Val)exc_msg(e));\n"
  "}_TRY\n"
  "return (Val) r;\n"
  "}\n"
  "Val __b64_decodeBytes (char *pos, Val b64) {\n"
  "Bytes *r;\n"
  "TRY {\n"
  "r = b64_decode_bytes(b64.s);\n"
  "} CATCH(e) {\n"
  "___built_throw(pos, (Val)exc_msg(e));\n"
  "}_TRY\n"
  "return (Val) (void *)r;\n"
  "}\n"
  "Val __b64_encode (Val s) {\n"
  "return (Val)b64_encode(s.s);\n"
  "}\n"
  "Val __b64_encodeBytes (Val bs) {\n"
  "return (Val)b64_encode_bytes(bs.o);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//bytes\n"
  "// -------------------------------------\n"
  "\n"
  "Val __bytes_add (Val bs1, Val bs2) {\n"
  "bytes_add((Bytes *)bs1.o, (Bytes *)bs2.o);\n"
  "return bs1;\n"
  "}\n"
  "Val __bytes_drop (Val bts, Val begin) {\n"
  "Bytes *bs = (Bytes *)bts.o;\n"
  "int64_t ix = begin.i;\n"
  "int64_t sz = bytes_len(bs);\n"
  "Bytes *bs2 = sz > ix\n"
  "? ix <= 0\n"
  "? bytes_from_bytes(bytes_bs(bs), sz)\n"
  ": bytes_from_bytes(bytes_bs(bs) + ix, sz - ix)\n"
  ": bytes_new()\n"
  ";\n"
  "return (Val)(void *)bs2;\n"
  "}\n"
  "Val __bytes_fromArr (Val a) {\n"
  "int64_t sz = __arr_size(a).i;\n"
  "Bytes *bs = bytes_new_bf(sz);\n"
  "unsigned char *pu = bytes_bs(bs);\n"
  "Val *p = a.a->begin;\n"
  "Val *end = a.a->end;\n"
  "while (p < end) *pu++ = (unsigned char)(*p++).i;\n"
  "return (Val)(void *)bs;\n"
  "}\n"
  "Val __bytes_fromStr (Val str) {\n"
  "return (Val)(void *)bytes_from_str(str.s);\n"
  "}\n"
  "Val __bytes_get (char *pos, Val bs, Val ix) {\n"
  "int64_t sz = __bytes_size(bs).i;\n"
  "int64_t i = ix.i;\n"
  "if (i < 0 || i >= sz)\n"
  "___built_throw(pos, (Val)str_f(\"Index %d out of [0,%d]\", i, sz - 1));\n"
  "return (Val)(int64_t)(bytes_bs((Bytes *)bs.o)[ix.i]);\n"
  "}\n"
  "Val __bytes_new (Val size) {\n"
  "int64_t bf = size.i;\n"
  "if (bf < 0) bf = 0;\n"
  "Bytes *bs = bytes_new_bf(bf);\n"
  "unsigned char *p = bytes_bs(bs);\n"
  "while (bf) {\n"
  "*p++ = 0;\n"
  "--bf;\n"
  "}\n"
  "return (Val)(void *)bs;\n"
  "}\n"
  "void __bytes_set (char *pos, Val bs, Val ix, Val byte) {\n"
  "int64_t sz = __bytes_size(bs).i;\n"
  "int64_t i = ix.i;\n"
  "if (i < 0 || i >= sz)\n"
  "___built_throw(pos, (Val)str_f(\"Index %d out of [0,%d]\", i, sz - 1));\n"
  "bytes_bs((Bytes *)bs.o)[ix.i] = (unsigned char)byte.i;\n"
  "}\n"
  "Val __bytes_size (Val bs) {\n"
  "return (Val)(int64_t)bytes_len((Bytes *)bs.o);\n"
  "}\n"
  "Val __bytes_take (Val bts, Val end) {\n"
  "Bytes *bs = (Bytes *)bts.o;\n"
  "int64_t ix = end.i;\n"
  "int64_t sz = bytes_len(bs);\n"
  "Bytes *bs2 = ix <= 0\n"
  "? bytes_new()\n"
  ": ix >= sz\n"
  "? bytes_from_bytes(bytes_bs(bs), sz)\n"
  ": bytes_from_bytes(bytes_bs(bs), ix)\n"
  ";\n"
  "return (Val)(void *)bs2;\n"
  "}\n"
  "Val __bytes_toArr (Val bts) {\n"
  "Bytes *bs = (Bytes *)bts.o;\n"
  "int sz = bytes_len(bs);\n"
  "Val a = __arr_new();\n"
  "unsigned char *p = bytes_bs(bs);\n"
  "while (sz) {\n"
  "__arr_push(a, (Val)(int64_t)*p++);\n"
  "--sz;\n"
  "}\n"
  "return a;\n"
  "}\n"
  "Val __bytes_toStr (Val bs) {\n"
  "return (Val)bytes_to_str((Bytes *)bs.o);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//cryp\n"
  "// -------------------------------------\n"
  "\n"
  "Val __cryp_decode (Val k, Val c) {\n"
  "return (Val) cryp_decode(k.s, c.s);\n"
  "}\n"
  "Val __cryp_decodeBytes (Val k, Val c) {\n"
  "return (Val)(void *)cryp_decode_bytes(k.s, c.s);\n"
  "}\n"
  "Val __cryp_encode (Val k, Val tx) {\n"
  "return (Val)cryp_encode(k.s, tx.s);\n"
  "}\n"
  "Val __cryp_encodeBytes (Val k, Val bs) {\n"
  "return (Val)cryp_encode_bytes(k.s, bs.o);\n"
  "}\n"
  "Val __cryp_genK (Val lg) {\n"
  "return (Val)cryp_genk(lg.i);\n"
  "}\n"
  "Val __cryp_key (Val s, Val lg) {\n"
  "return (Val)cryp_key(s.s, lg.i);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//dic\n"
  "// -------------------------------------\n"
  "\n"
  "Val __dic_copy (Val d) {\n"
  "Val *p = d.a->begin;\n"
  "Val *end = d.a->end;\n"
  "int64_t bf_size = end - p;\n"
  "Varr *this = MALLOC(Varr);\n"
  "this->begin = GC_MALLOC(bf_size * sizeof(Val));\n"
  "this->end = this->begin + bf_size;\n"
  "this->end_bf = this->end;\n"
  "Val *pt = this->begin;\n"
  "while (p < end) *pt++ = __arr_copy(*p++);\n"
  "return (Val) this;\n"
  "}\n"
  "Val __dic_fromArr (Val a) {\n"
  "Val r = __arr_new();\n"
  "Varr *arr = a.a;\n"
  "Val *p = arr->begin;\n"
  "Val *end = arr->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "__dic_put(r, *(kv->begin), kv->begin[1]);\n"
  "}\n"
  "return r;\n"
  "}\n"
  "Val __dic_fromIter (Val it) {\n"
  "return __dic_fromArr(__arr_fromIter(it));\n"
  "}\n"
  "Val __dic_fromJs (Val s, Val fn) {\n"
  "Val d = __js_ro(s);\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "kv->begin[1] = ((Val (*)(Val))fn.o)(kv->begin[1]);\n"
  "}\n"
  "return d;\n"
  "}\n"
  "Val __dic_from_smap (Map *m) {\n"
  "Val r = __arr_new();\n"
  "EACH(m, Kv, el) {\n"
  "Val e = __arr_new();\n"
  "__arr_push(e, (Val)kv_key(el));\n"
  "__arr_push(e, (Val)((char *)kv_value(el)));\n"
  "__arr_push(r, e);\n"
  "}_EACH\n"
  "return r;\n"
  "}\n"
  "Val __dic_get(Val d, Val key) {\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "if (!strcmp((*(kv->begin)).s, key.s)) return __rs_some(kv->begin[1]);\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __dic_get2(char *pos, Val d, Val key) {\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "if (!strcmp((*(kv->begin)).s, key.s)) return kv->begin[1];\n"
  "}\n"
  "___built_throw(pos, (Val)str_f(\"Key %s not found\", key.s));\n"
  "return (Val)0; // Unreachable\n"
  "}\n"
  "Val __dic_hasKey(Val d, Val key) {\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "if (!strcmp((*(kv->begin)).s, key.s)) return (Val)1;\n"
  "}\n"
  "return (Val)0;\n"
  "}\n"
  "Val __dic_keys (Val d) {\n"
  "Val r = __arr_new();\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "__arr_push(r, *(kv->begin));\n"
  "}\n"
  "return r;\n"
  "}\n"
  "Val __dic_map (Val d, Val fn) {\n"
  "Val dr = __dic_copy(d);\n"
  "Varr *r = dr.a;\n"
  "Val *p = r->begin;\n"
  "Val *end = r->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "kv->begin[1] = ((Val (*)(Val))fn.o)(kv->begin[1]);\n"
  "}\n"
  "return dr;\n"
  "}\n"
  "Val __dic_new_from_carr (Val n, Val *els) {\n"
  "Val r = __arr_new();\n"
  "REPEAT(n.i) {\n"
  "Varr *kv = (*els++).a;\n"
  "__dic_put(r, *(kv->begin), kv->begin[1]);\n"
  "}_REPEAT\n"
  "return r;\n"
  "}\n"
  "void __dic_put(Val d, Val key, Val value) {\n"
  "int new = TRUE;\n"
  "char *k = key.s;\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "if (!strcmp(k, (*(kv->begin)).s)) {\n"
  "kv->begin[1] = value;\n"
  "new = FALSE;\n"
  "break;\n"
  "}\n"
  "}\n"
  "if (new) __arr_push(d, __arr_new_from_carr((Val)2, (Val[]){key, value}));\n"
  "}\n"
  "void __dic_remove(Val d, Val key) {\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "Val *target = NULL;\n"
  "while (p < end) {\n"
  "if (target) {\n"
  "*target++ = *p++;\n"
  "} else {\n"
  "Val *t = p++;\n"
  "Varr *kv = t->a;\n"
  "if (!strcmp((*(kv->begin)).s, key.s)) target = t;\n"
  "}\n"
  "}\n"
  "if (target) --(a->end);\n"
  "}\n"
  "void __dic_set(char *pos, Val d, Val key, Val value) {\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "if (!strcmp((*(kv->begin)).s, key.s)) {\n"
  "kv->begin[1] = value;\n"
  "return;\n"
  "}\n"
  "}\n"
  "___built_throw(pos, (Val)str_f(\"Key %s not found\", key.s));\n"
  "}\n"
  "Val __dic_size(Val d) {\n"
  "return __arr_size(d);\n"
  "}\n"
  "Val __dic_toArr (Val d) {\n"
  "return __dic_copy(d);\n"
  "}\n"
  "Val __dic_toIter (Val d) {\n"
  "return __arr_toIter(d);\n"
  "}\n"
  "Val __dic_toJs (Val d, Val fn) {\n"
  "Map *r = map_new();\n"
  "Varr *va = d.a;\n"
  "Val *p = va->begin;\n"
  "Val *end = va->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "arr_push((Arr *)r, kv_new(\n"
  "(*(kv->begin)).s,\n"
  "((Val (*)(Val))fn.o)(kv->begin[1]).s\n"
  "));\n"
  "}\n"
  "return __js_wo(__dic_from_smap(r));\n"
  "}\n"
  "Map *__dic_to_smap (Val a) {\n"
  "Map *r = map_new();\n"
  "Varr *va = a.a;\n"
  "Val *p = va->begin;\n"
  "Val *end = va->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "arr_push((Arr *)r, kv_new((*(kv->begin)).s, (kv->begin[1]).s));\n"
  "}\n"
  "return r;\n"
  "}\n"
  "Val __dic_values (Val d){\n"
  "Val r = __arr_new();\n"
  "Varr *a = d.a;\n"
  "Val *p = a->begin;\n"
  "Val *end = a->end;\n"
  "while (p < end) {\n"
  "Varr *kv = (*p++).a;\n"
  "__arr_push(r, kv->begin[1]);\n"
  "}\n"
  "return r;\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//file\n"
  "// -------------------------------------\n"
  "\n"
  "Val __file_aopen (Val path) {\n"
  "return (Val)(void *)file_aopen(path.s);\n"
  "}\n"
  "Val __file_base (Val path) {\n"
  "return (Val)path_base (path.s);\n"
  "}\n"
  "Val __file_canonical (char *pos, Val path) {\n"
  "char *r = opt_get(path_canonical(path.s));\n"
  "if (!r)\n"
  "___built_throw(pos, (Val)(str_f(\"'%s' can not be canonicalized\", path.s)));\n"
  "return (Val)r;\n"
  "}\n"
  "Val __file_cat (Val path, Val rpaths) {\n"
  "__arr_unshift(rpaths, *(path.s) ? path : (Val)\".\");\n"
  "return __file_clean(__arr_join(rpaths, (Val)\"/\"));\n"
  "}\n"
  "void __file_cd (Val path) {\n"
  "file_cd(path.s);\n"
  "}\n"
  "Val __file_clean (Val path) {\n"
  "return (Val)path_clean(path.s);\n"
  "}\n"
  "void __file_close (Val file) {\n"
  "file_close(file.o);\n"
  "}\n"
  "void __file_copy (char *pos, Val source, Val target) {\n"
  "void copy (char *source, char *target) {\n"
  "if (file_is_directory(source)) {\n"
  "if (file_exists(target) && !file_is_directory(target))\n"
  "___built_throw(pos, (Val)str_f(\"'%s' is not a directory\", target));\n"
  "char *tdir = path_cat(target, path_base(source), NULL);\n"
  "file_del(tdir);\n"
  "file_mkdir(tdir);\n"
  "EACH(file_dir(source), char, fname) {\n"
  "copy(path_cat(source, fname, NULL), tdir);\n"
  "}_EACH\n"
  "return;\n"
  "}\n"
  "if (file_is_directory(target))\n"
  "target = path_cat(target, path_base(source), NULL);\n"
  "file_copy(source, target);\n"
  "}\n"
  "return copy(source.s, target.s);\n"
  "}\n"
  "void __file_del (Val path) {\n"
  "file_del(path.s);\n"
  "}\n"
  "Val __file_dir (Val path) {\n"
  "Val r = __arr_new();\n"
  "EACH(file_dir(path.s), char, name) {\n"
  "__arr_push(r, (Val)name);\n"
  "}_EACH\n"
  "return r;\n"
  "}\n"
  "Val __file_exists (Val path) {\n"
  "return (Val)file_exists(path.s);\n"
  "}\n"
  "Val __file_extension (Val path) {\n"
  "return (Val)path_extension(path.s);\n"
  "}\n"
  "Val __file_isDirectory (Val path) {\n"
  "return (Val)file_is_directory(path.s);\n"
  "}\n"
  "Val __file_isLink (Val path) {\n"
  "return (Val)file_is_link(path.s);\n"
  "}\n"
  "Val __file_isRegular (Val path) {\n"
  "return (Val)file_is_regular(path.s);\n"
  "}\n"
  "void __file_mkdir (Val path) {\n"
  "file_mkdir(path.s);\n"
  "}\n"
  "void __file_mklink (Val path, Val link) {\n"
  "file_link(path.s, link.s);\n"
  "}\n"
  "Val __file_parent (Val path) {\n"
  "return (Val)path_parent(path.s);\n"
  "}\n"
  "Val __file_read (Val path) {\n"
  "return (Val)file_read(path.s);\n"
  "}\n"
  "Val __file_readBin (Val file, Val buf) {\n"
  "return (Val)(void *)file_read_bin_buf(file.o, buf.i);\n"
  "}\n"
  "Val __file_readLine (Val file) {\n"
  "char *l = file_read_line(file.o);\n"
  "if (*l) {\n"
  "if (l[strlen(l) - 1] == '\\n') l = str_left(l, -1);\n"
  "return __rs_some((Val)l);\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "void __file_rename (Val old_path, Val new_path) {\n"
  "file_rename(old_path.s, new_path.s);\n"
  "}\n"
  "Val __file_ropen (Val path) {\n"
  "return (Val)(void *)file_ropen(path.s);\n"
  "}\n"
  "Val __file_size (Val path) {\n"
  "return (Val)(int64_t)file_size(path.s);\n"
  "}\n"
  "Val __file_tm (Val path) {\n"
  "return (Val)file_modified(path.s);\n"
  "}\n"
  "Val __file_tmp (Val dir, Val name) {\n"
  "return (Val)file_tmp(dir.s, name.s);\n"
  "}\n"
  "Val __file_wd (void) {\n"
  "return (Val)file_wd();\n"
  "}\n"
  "Val __file_wopen (Val path) {\n"
  "return (Val)(void *)file_wopen(path.s);\n"
  "}\n"
  "void __file_write (Val path, Val tx) {\n"
  "file_write(path.s, tx.s);\n"
  "}\n"
  "void __file_writeBin (Val file, Val bs) {\n"
  "file_write_bin(file.o, bs.o);\n"
  "}\n"
  "void __file_writeText (Val file, Val tx) {\n"
  "file_write_text(file.o, tx.s);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//iter\n"
  "// -------------------------------------\n"
  "\n"
  "Val __iter_all (Val it, Val fn) {\n"
  "int r = TRUE;\n"
  "while (__iter_hasNext(it).b) {\n"
  "Val v = __iter_next(it);\n"
  "r = r && (((Val (*)(Val))fn.o)(v)).b;\n"
  "}\n"
  "return (Val)r;\n"
  "}\n"
  "Val __iter_any (Val it, Val fn) {\n"
  "int r = FALSE;\n"
  "while (__iter_hasNext(it).b) {\n"
  "Val v = __iter_next(it);\n"
  "r = r || (((Val (*)(Val))fn.o)(v)).b;\n"
  "}\n"
  "return (Val)r;\n"
  "}\n"
  "Val __iter_cat_next (Val obj) {\n"
  "Val *p = obj.a->begin;\n"
  "if (p->b) {\n"
  "Val it = *(p+1);\n"
  "if (__iter_hasNext(it).b) return __rs_some(__iter_next(it));\n"
  "*p = (Val) FALSE;\n"
  "}\n"
  "Val it = *(p+2);\n"
  "return (__iter_hasNext(it).b) ? __rs_some(__iter_next(it)) : __arr_new();\n"
  "}\n"
  "Val __iter_cat (Val it1, Val it2) {\n"
  "Val obj = __arr_new_from_carr((Val)3, (Val[]){(Val)TRUE, it1, it2});\n"
  "return __iter_new_aux(obj, __iter_cat_next);\n"
  "}\n"
  "Val __iter_count (Val it) {\n"
  "int64_t c = 0;\n"
  "while (__iter_hasNext(it).b) {\n"
  "__iter_next(it);\n"
  "++c;\n"
  "}\n"
  "return (Val)c;\n"
  "}\n"
  "Val __iter_drop (Val it, Val n) {\n"
  "int64_t nv = n.i;\n"
  "int64_t c = 0;\n"
  "for(;;) {\n"
  "if (c >= nv || !__iter_hasNext(it).b) break;\n"
  "++c;\n"
  "__iter_next(it);\n"
  "}\n"
  "return it;\n"
  "}\n"
  "Val __iter_dropWhile (Val it, Val fn) {\n"
  "while (__iter_hasNext(it).b && (((Val (*)(Val))fn.o)(__iter_peek(it))).b)\n"
  "__iter_next(it);\n"
  "return it;\n"
  "}\n"
  "void __iter_each (Val it, Val fn) {\n"
  "while (__iter_hasNext(it).b)\n"
  "((void (*)(Val))fn.o)(__iter_next(it));\n"
  "}\n"
  "void __iter_eachIx (Val it, Val fn) {\n"
  "int64_t c = 0;\n"
  "while (__iter_hasNext(it).b)\n"
  "((void (*)(Val, Val))fn.o)(__iter_next(it), (Val)c++);\n"
  "}\n"
  "Val __iter_empty_next (Val fake) {\n"
  "return __arr_new();\n"
  "}\n"
  "Val __iter_empty (Val fake) {\n"
  "return __iter_new_aux(fake, __iter_empty_next);\n"
  "}\n"
  "Val __iter_filter_next (Val obj) {\n"
  "Val *p = obj.a->begin;\n"
  "Val it = *p;\n"
  "Val fn = *(p+1);\n"
  "while (__iter_hasNext(it).b) {\n"
  "Val r = __iter_next(it);\n"
  "if ((((Val (*)(Val))fn.o)(r)).b) return __rs_some(r);\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __iter_filter (Val it, Val fn) {\n"
  "return __iter_new_aux(\n"
  "__arr_new_from_carr((Val)2, (Val[]){it, fn}),\n"
  "__iter_filter_next\n"
  ");\n"
  "}\n"
  "Val __iter_find (Val it, Val fn) {\n"
  "while (__iter_hasNext(it).b) {\n"
  "Val r = __iter_next(it);\n"
  "if ((((Val (*)(Val))fn.o)(r)).b) return __rs_some(r);\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __iter_fromJs (Val s, Val fn) {\n"
  "return __iter_map(__arr_toIter(__js_ra(s)), fn);\n"
  "}\n"
  "Val __iter_hasNext (Val it) {\n"
  "return (Val)(__arr_size(*(it.a->begin)).i > 0);\n"
  "}\n"
  "Val __iter_index (Val it, Val fn) {\n"
  "int64_t c = 0;\n"
  "while (__iter_hasNext(it).b) {\n"
  "Val e = __iter_next(it);\n"
  "int64_t r = c++;\n"
  "if ((((Val (*)(Val))fn.o)(e)).b) return (Val)r;\n"
  "}\n"
  "return (Val)(int64_t)-1;\n"
  "}\n"
  "Val __iter_map_next (Val obj) {\n"
  "Val *p = obj.a->begin;\n"
  "Val it = *p;\n"
  "Val fn = *(p+1);\n"
  "while (__iter_hasNext(it).b)\n"
  "return __rs_some(((Val (*)(Val))fn.o)(__iter_next(it)));\n"
  "return __arr_new();\n"
  "}\n"
  "Val __iter_map (Val it, Val fn) {\n"
  "return __iter_new_aux(\n"
  "__arr_new_from_carr((Val)2, (Val[]){it, fn}),\n"
  "__iter_map_next\n"
  ");\n"
  "}\n"
  "Val __iter_next (Val it) {\n"
  "Val r = *(it.a->begin);\n"
  "if (__arr_size(r).i == 0)\n"
  "___built_throw(\"Built-in:0\", (Val)\"Iterator is empty\");\n"
  "Val tuple = *(it.a->begin + 1);\n"
  "Val *p = tuple.a->begin;\n"
  "*(it.a->begin) = ((Val (*)(Val))(*(p+1)).o)(*p);\n"
  "return *r.a->begin;\n"
  "}\n"
  "Val __iter_new (Val tuple) {\n"
  "Val *p = tuple.a->begin;\n"
  "Val a = ((Val (*)(Val))(*(p+1)).o)(*p);\n"
  "return __arr_new_from_carr((Val)2, (Val[]){a, tuple});\n"
  "}\n"
  "Val __iter_new_aux (Val obj, Val (*fn) (Val)) {\n"
  "return __iter_new(__arr_new_from_carr((Val)2, (Val[]){\n"
  "obj, (Val)(void *)fn\n"
  "}));\n"
  "}\n"
  "Val __iter_peek (Val it) {\n"
  "Val r = *(it.a->begin);\n"
  "if (__arr_size(r).i == 0)\n"
  "___built_throw(\"Built-in:0\", (Val)\"Iterator is empty\");\n"
  "return *r.a->begin;\n"
  "}\n"
  "Val __iter_range_next (Val obj) {\n"
  "Val *p = obj.a->begin;\n"
  "int64_t begin = p->i;\n"
  "int64_t end = (p+1)->i;\n"
  "int withStep = (p+3)->i;\n"
  "if (withStep) {\n"
  "int64_t step = (p+2)->i;\n"
  "if (step > 0) {\n"
  "if (begin <= end) {\n"
  "*p = (Val)(begin + step);\n"
  "return __arr_new_from_carr((Val)1, (Val[]){(Val)begin});\n"
  "}\n"
  "} else {\n"
  "if (begin >= end) {\n"
  "*p = (Val)(begin + step);\n"
  "return __arr_new_from_carr((Val)1, (Val[]){(Val)begin});\n"
  "}\n"
  "}\n"
  "} else {\n"
  "if (begin < end) {\n"
  "*p = (Val)(begin + 1);\n"
  "return __arr_new_from_carr((Val)1, (Val[]){(Val)begin});\n"
  "}\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __iter_range (char *pos, Val vs) {\n"
  "Val obj = __arr_new();\n"
  "Val *p = vs.a->begin;\n"
  "int64_t sz = __arr_size(vs).i;\n"
  "if (sz == 1) {\n"
  "__arr_push(obj, (Val) 0);\n"
  "__arr_push(obj, *p);\n"
  "__arr_push(obj, (Val) 1);\n"
  "__arr_push(obj, (Val) 0);\n"
  "} else if (sz == 2) {\n"
  "__arr_push(obj, *p++);\n"
  "__arr_push(obj, *p);\n"
  "__arr_push(obj, (Val) 1);\n"
  "__arr_push(obj, (Val) 0);\n"
  "} else {\n"
  "__arr_push(obj, *p++);\n"
  "__arr_push(obj, *p++);\n"
  "if (p->i == 0)\n"
  "___built_throw(pos, (Val)\"Range step is 0\");\n"
  "__arr_push(obj, *p);\n"
  "__arr_push(obj, (Val) 1);\n"
  "}\n"
  "return __iter_new_aux(obj, __iter_range_next);\n"
  "}\n"
  "Val __iter_reduce (Val it, Val seed, Val fn) {\n"
  "while (__iter_hasNext(it).b)\n"
  "seed = ((Val (*)(Val, Val))fn.o)(seed, __iter_next(it));\n"
  "return seed;\n"
  "}\n"
  "Val __iter_take_next (Val obj) {\n"
  "Val *p = obj.a->begin;\n"
  "Val it = *p;\n"
  "int64_t n = (p+1)->i;\n"
  "int64_t c = (p+2)->i;\n"
  "if (c < n) {\n"
  "if (__iter_hasNext(it).b) {\n"
  "*(p+2) = (Val)(c + 1);\n"
  "return __rs_some(__iter_next(it));\n"
  "}\n"
  "*(p+2) = *(p+1);\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __iter_take (Val it, Val n){\n"
  "return __iter_new_aux(\n"
  "__arr_new_from_carr((Val)3, (Val[]){it, n, (Val)0}),\n"
  "__iter_take_next\n"
  ");\n"
  "}\n"
  "Val __iter_takeWhile_next (Val obj) {\n"
  "Val *p = obj.a->begin;\n"
  "Val it = *p;\n"
  "Val fn = *(p+1);\n"
  "return __iter_hasNext(it).b && (((Val (*)(Val))fn.o)(__iter_peek(it))).b\n"
  "? __rs_some(__iter_next(it))\n"
  ": __arr_new()\n"
  ";\n"
  "}\n"
  "Val __iter_takeWhile (Val it, Val fn) {\n"
  "return __iter_new_aux(\n"
  "__arr_new_from_carr((Val)2, (Val[]){it, fn}),\n"
  "__iter_takeWhile_next\n"
  ");\n"
  "}\n"
  "Val __iter_toJs (Val it, Val fn) {\n"
  "return __js_wa(__arr_fromIter(__iter_map(it, fn)));\n"
  "}\n"
  "Val __iter_unary_next (Val obj) {\n"
  "if (__arr_size(obj).i) {\n"
  "Val r = __arr_copy(obj);\n"
  "__arr_clear(obj);\n"
  "return r;\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __iter_unary (Val value) {\n"
  "return __iter_new_aux(__rs_some(value), __iter_unary_next);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//js\n"
  "// -------------------------------------\n"
  "\n"
  "Val __js_isNull (Val json) {\n"
  "return (Val)js_is_null(json.s);\n"
  "}\n"
  "Val __js_ra (Val json) {\n"
  "return __arr_from_sarr(js_ra(json.s));\n"
  "}\n"
  "Val __js_rb (Val json) {\n"
  "return (Val)js_rb(json.s);\n"
  "}\n"
  "Val __js_rf (Val json) {\n"
  "return (Val)js_rd(json.s);\n"
  "}\n"
  "Val __js_ri (Val json) {\n"
  "return (Val)js_rl(json.s);\n"
  "}\n"
  "Val __js_ro (Val json) {\n"
  "return __dic_from_smap(js_ro(json.s));\n"
  "}\n"
  "Val __js_rs (Val json) {\n"
  "return (Val)js_rs(json.s);\n"
  "}\n"
  "Val __js_wa(Val a) {\n"
  "return (Val)js_wa(__arr_to_sarr(a));\n"
  "}\n"
  "Val __js_wb(Val value) {\n"
  "return (Val)js_wb(value.b);\n"
  "}\n"
  "Val __js_wf(Val n) {\n"
  "return (Val)math_ftos(n.f, 9);\n"
  "}\n"
  "Val __js_wf2(Val n, Val dec) {\n"
  "return (Val)math_ftos(n.f, dec.i);\n"
  "}\n"
  "Val __js_wi(Val n) {\n"
  "return (Val)math_itos(n.i);\n"
  "}\n"
  "Val __js_wn(void) {\n"
  "return (Val)js_wn();\n"
  "}\n"
  "Val __js_wo(Val m) {\n"
  "return (Val)js_wo(__dic_to_smap(m));\n"
  "}\n"
  "Val __js_ws(Val s) {\n"
  "return (Val)js_ws(s.s);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//math\n"
  "// -------------------------------------\n"
  "\n"
  "Val __math_abs (Val n) {\n"
  "return (Val)math_abs(n.f);\n"
  "}\n"
  "Val __math_acos (Val n) {\n"
  "return (Val)acos(n.f);\n"
  "}\n"
  "Val __math_acosh (Val n) {\n"
  "return (Val)acosh(n.f);\n"
  "}\n"
  "Val __math_asin (Val n) {\n"
  "return (Val)asin(n.f);\n"
  "}\n"
  "Val __math_asinh (Val n) {\n"
  "return (Val)asinh(n.f);\n"
  "}\n"
  "Val __math_atan (Val n) {\n"
  "return (Val)atan(n.f);\n"
  "}\n"
  "Val __math_atanh (Val n) {\n"
  "return (Val)atanh(n.f);\n"
  "}\n"
  "Val __math_ceil (Val n) {\n"
  "return (Val)ceil(n.f);\n"
  "}\n"
  "Val __math_cos (Val n) {\n"
  "return (Val)cos(n.f);\n"
  "}\n"
  "Val __math_cosh (Val n) {\n"
  "return (Val)cosh(n.f);\n"
  "}\n"
  "Val __math_e (void) {\n"
  "return (Val)M_E;\n"
  "}\n"
  "Val __math_eq (Val n1, Val n2, Val gap) {\n"
  "return (Val)math_eq_gap(n1.f, n2.f, gap.f);\n"
  "}\n"
  "Val __math_exp (Val n) {\n"
  "return (Val)exp(n.f);\n"
  "}\n"
  "Val __math_exp2 (Val n) {\n"
  "return (Val)exp2(n.f);\n"
  "}\n"
  "Val __math_floor (Val n) {\n"
  "return (Val)floor(n.f);\n"
  "}\n"
  "Val __math_fromEn (Val s) {\n"
  "return __math_stof((Val)str_replace(s.s, \",\", \"\"));\n"
  "}\n"
  "Val __math_fromHex (Val s) {\n"
  "char *n = str_trim(s.s);\n"
  "if (!*n) return __arr_new();\n"
  "char *tmp;\n"
  "int64_t r = strtol(n, &tmp, 16);\n"
  "if (*tmp) return __arr_new();\n"
  "return __rs_some((Val)r);\n"
  "}\n"
  "Val __math_fromIso (Val s) {\n"
  "return __math_stof((Val)str_replace(str_replace(s.s, \".\", \"\"), \",\", \".\"));\n"
  "}\n"
  "Val __math_ftoi (Val n) {\n"
  "return (Val)(int64_t)(n.f);\n"
  "}\n"
  "Val __math_ftos (Val n) {\n"
  "return (Val)math_ftos(n.f, 9);\n"
  "}\n"
  "Val __math_ftos2 (Val n, Val dec) {\n"
  "return (Val)math_ftos(n.f, dec.i);\n"
  "}\n"
  "Val __math_isDigits (Val n) {\n"
  "return (Val)math_digits(n.s);\n"
  "}\n"
  "Val __math_itof (Val n) {\n"
  "return (Val)(double)(n.i);\n"
  "}\n"
  "Val __math_itoh (Val n) {\n"
  "return (Val)str_f(\"%x\", n.i);\n"
  "}\n"
  "Val __math_itos (Val n) {\n"
  "return (Val)math_itos(n.i);\n"
  "}\n"
  "Val __math_log (Val n) {\n"
  "return (Val)log(n.f);\n"
  "}\n"
  "Val __math_log10 (Val n) {\n"
  "return (Val)log10(n.f);\n"
  "}\n"
  "Val __math_log2 (Val n) {\n"
  "return (Val)log2(n.f);\n"
  "}\n"
  "Val __math_max (Val n1, Val n2) {\n"
  "return n1.f >= n2.f ? n1 : n2;\n"
  "}\n"
  "Val __math_maxFloat (void) {\n"
  "return (Val)DBL_MAX;\n"
  "}\n"
  "Val __math_maxInt (void) {\n"
  "return (Val)(int64_t)\n"
  "(sizeof(int64_t) == sizeof(long long int) ? LLONG_MAX : LONG_MAX);\n"
  "}\n"
  "Val __math_min (Val n1, Val n2) {\n"
  "return n1.f <= n2.f ? n1 : n2;\n"
  "}\n"
  "Val __math_minInt (void) {\n"
  "return (Val)(int64_t)\n"
  "(sizeof(int64_t) == sizeof(long long int) ? LLONG_MIN : LONG_MIN);\n"
  "}\n"
  "Val __math_pi (void) {\n"
  "return (Val)M_PI;\n"
  "}\n"
  "Val __math_pow (Val base, Val exp) {\n"
  "return (Val)pow(base.f, exp.f);\n"
  "}\n"
  "Val __math_pow10 (Val exp) {\n"
  "int64_t n = exp.i;\n"
  "double r = 1;\n"
  "double mul = n > 0 ? 10 : 0.1;\n"
  "n = n >= 0 ? n : -n;\n"
  "REPEAT(n) {\n"
  "r *= mul;\n"
  "}_REPEAT\n"
  "return (Val)r;\n"
  "}\n"
  "Val __math_rnd (void) {\n"
  "return (Val)((double)rand() / (double)RAND_MAX);\n"
  "}\n"
  "Val __math_rndi (Val top) {\n"
  "return (Val)(int64_t)(((double)rand() / (double)RAND_MAX) * top.i);\n"
  "}\n"
  "Val __math_round (Val n, Val dec) {\n"
  "return (Val)math_round(n.f, dec.i);\n"
  "}\n"
  "Val __math_sin (Val n) {\n"
  "return (Val)sin(n.f);\n"
  "}\n"
  "Val __math_sinh (Val n) {\n"
  "return (Val)sinh(n.f);\n"
  "}\n"
  "Val __math_sqrt (Val n) {\n"
  "return (Val)sqrt(n.f);\n"
  "}\n"
  "Val __math_stof (Val s) {\n"
  "char *n = str_trim(s.s);\n"
  "if (!*n) return __arr_new();\n"
  "struct lconv *lc = localeconv();\n"
  "int ix = str_cindex(n, '.');\n"
  "if (ix != -1) n[ix] = *lc->decimal_point;\n"
  "char *tmp;\n"
  "double r = strtod(n, &tmp);\n"
  "if (*tmp) return __arr_new();\n"
  "return __rs_some((Val)r);\n"
  "}\n"
  "Val __math_stoi (Val s) {\n"
  "char *n = str_trim(s.s);\n"
  "if (!*n) return __arr_new();\n"
  "char *tmp;\n"
  "int64_t r = strtol(n, &tmp, 10);\n"
  "if (*tmp) return __arr_new();\n"
  "return __rs_some((Val)r);\n"
  "}\n"
  "Val __math_tan (Val n) {\n"
  "return (Val)tan(n.f);\n"
  "}\n"
  "Val __math_tanh (Val n) {\n"
  "return (Val)tanh(n.f);\n"
  "}\n"
  "Val __math_trunc (Val n) {\n"
  "return (Val)trunc(n.f);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//regex\n"
  "// -------------------------------------\n"
  "\n"
  "Val __regex_matches (char *pos, Val s, Val rg) {\n"
  "char *ss = s.s;\n"
  "Arr *ms = opt_get(regex_matches(rg.s, ss));\n"
  "if (!ms)\n"
  "___built_throw(pos, (Val)str_f(\"Fail compiling regular expression:\\n%s\", rg));\n"
  "Val r = __arr_new();\n"
  "int ix = 0;\n"
  "EACH(ms, RegexOffset, of) {\n"
  "int begin = regexOffset_begin(of);\n"
  "int end = regexOffset_end(of);\n"
  "__arr_push(r, (Val)str_sub(ss, ix, begin));\n"
  "__arr_push(r, (Val)str_sub(ss, begin, end));\n"
  "ix = end;\n"
  "}_EACH\n"
  "__arr_push(r, (Val)str_right(ss, ix));\n"
  "return r;\n"
  "}\n"
  "Val __regex_replace (char *pos, Val s, Val rg, Val repl) {\n"
  "char *r = opt_get(regex_replace(rg.s, s.s, repl.s));\n"
  "if (r) return (Val)r;\n"
  "___built_throw(pos, (Val)str_f(\"Fail of regular expression:\\n%s\", rg));\n"
  "return (Val)0; // Unreachable\n"
  "}\n"
  "Val __regex_replacef (char *pos, Val s, Val rg, Val frpl) {\n"
  "char *fn(char *match) {\n"
  "return (((Val (*)(Val))frpl.o)((Val)match)).s;\n"
  "}\n"
  "char *r = opt_get(regex_replacef(rg.s, s.s, fn));\n"
  "if (r) return (Val)r;\n"
  "___built_throw(pos, (Val)str_f(\"Fail of regular expression:\\n%s\", rg));\n"
  "return (Val)0; // Unreachable\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//rs\n"
  "// -------------------------------------\n"
  "\n"
  "Val __rs_some (Val v) {\n"
  "return __arr_new_from_carr((Val) 1, (Val[]){v});\n"
  "}\n"
  "Val __rs_ok (Val v) {\n"
  "return __arr_new_from_carr((Val) 2, (Val[]){__rs_some(v), (Val)\"\"});\n"
  "}\n"
  "Val __rs_fail (Val v) {\n"
  "return __arr_new_from_carr((Val) 2, (Val[]){__arr_new(), v});\n"
  "}\n"
  "Val __rs_get (Val rs) {\n"
  "return *((*rs.a->begin).a->begin);\n"
  "}\n"
  "Val __rs_error (Val rs) {\n"
  "return rs.a->begin[1];\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//str\n"
  "// -------------------------------------\n"
  "\n"
  "Val __str_cmp (Val s1, Val s2) {\n"
  "return (Val)(int64_t)strcoll(s1.s, s2.s);\n"
  "}\n"
  "Val __str_ends (Val str, Val substr) {\n"
  "return (Val)str_ends(str.s, substr.s);\n"
  "}\n"
  "Val __str_fmt (char *pos, Val format, Val args) {\n"
  "char *fmt = format.s;\n"
  "Varr *as = args.a;\n"
  "Arr *pts = arr_new();\n"
  "Buf *bf = buf_new();\n"
  "char *p = fmt;\n"
  "while (*p) {\n"
  "char ch = *p++;\n"
  "if (ch == '%') {\n"
  "ch = *p;\n"
  "if (ch == 'v') {\n"
  "++p;\n"
  "arr_push(pts, buf_str(bf));\n"
  "bf = buf_new();\n"
  "continue;\n"
  "}\n"
  "if (ch == '%') ++p;\n"
  "}\n"
  "buf_cadd(bf, ch);\n"
  "}\n"
  "arr_push(pts, buf_str(bf));\n"
  "if (arr_size(pts) != __arr_size(args).i + 1)\n"
  "___built_throw(pos, (Val)str_f(\n"
  "\"Wrong arguments number (expected %d, fund %d)\",\n"
  "arr_size(pts) - 1, __arr_size(args).i\n"
  "));\n"
  "Arr *rs = arr_new();\n"
  "void **ps = arr_begin(pts);\n"
  "arr_push(rs, *ps++);\n"
  "Val *pas = as->begin;\n"
  "Val *pend = as->end;\n"
  "while (pas < pend) {\n"
  "arr_push(rs, pas++->s);\n"
  "arr_push(rs, *ps++);\n"
  "}\n"
  "return (Val)arr_join(rs, \"\");\n"
  "}\n"
  "Val __str_fromIso (Val s) {\n"
  "return (Val)str_from_iso(s.s);\n"
  "}\n"
  "Val __str_fromRunes (Val a) {\n"
  "return __arr_join(a, (Val)\"\");\n"
  "}\n"
  "Val __str_fromUtf16 (Val codepoints) {\n"
  "int64_t sz = __arr_size(codepoints).i;\n"
  "unsigned *u = ATOMIC(sizeof(unsigned) * (sz + 1));\n"
  "Val *p = codepoints.a->begin;\n"
  "Val *end = codepoints.a->end;\n"
  "unsigned *pu = u;\n"
  "while (p < end) *pu++ = (unsigned)(*p++).i;\n"
  "*pu = 0;\n"
  "return (Val)str_from_unicode(u);\n"
  "};\n"
  "Val __str_get(char *pos, Val s, Val ix) {\n"
  "if (ix.i < 0 || ix.i >= strlen(s.s))\n"
  "___built_throw(pos, (Val)str_f(\"Index %d out of [0,%d]\", ix.i, strlen(s.s) - 1));\n"
  "return (Val)str_new_c(s.s[ix.i]);\n"
  "}\n"
  "Val __str_index(Val str, Val substr) {\n"
  "return (Val)(int64_t)str_index(str.s, substr.s);\n"
  "}\n"
  "Val __str_indexFrom (Val str, Val substr, Val start) {\n"
  "return (Val)(int64_t)str_index_from(str.s, substr.s, start.i);\n"
  "}\n"
  "Val __str_lastIndex (Val str, Val substr) {\n"
  "return (Val)(int64_t)str_last_index(str.s, substr.s);\n"
  "}\n"
  "Val __str_left (Val str, Val end) {\n"
  "Val r = __str_toRunes(str);\n"
  "int64_t sz = __arr_size(r).i;\n"
  "end = end.i < 0 ? (Val)(sz + end.i) : end;\n"
  "return __arr_join(__arr_take(r, end), (Val)\"\");\n"
  "}\n"
  "Val __str_left_slice(Val str, Val begin) {\n"
  "return (Val)str_left(str.s, begin.i);\n"
  "}\n"
  "Val __str_len (Val str) {\n"
  "return (Val)(int64_t)strlen(str.s);\n"
  "}\n"
  "Val __str_ltrim (Val str) {\n"
  "return (Val)str_ltrim(str.s);\n"
  "}\n"
  "Val __str_replace (Val s, Val old, Val new) {\n"
  "return (Val)str_replace(s.s, old.s, new.s);\n"
  "}\n"
  "Val __str_right (Val str, Val begin) {\n"
  "Val r = __str_toRunes(str);\n"
  "int64_t sz = __arr_size(r).i;\n"
  "begin = begin.i < 0 ? (Val)(sz + begin.i) : begin;\n"
  "return __arr_join(__arr_drop(r, begin), (Val)\"\");\n"
  "}\n"
  "Val __str_right_slice(Val str, Val begin) {\n"
  "return (Val)str_right(str.s, begin.i);\n"
  "}\n"
  "Val __str_rtrim (Val str) {\n"
  "return (Val)str_rtrim(str.s);\n"
  "}\n"
  "Val __str_split (Val str, Val sep) {\n"
  "char *s = str.s;\n"
  "char *ssep = sep.s;\n"
  "Val r = __arr_new();\n"
  "int len = strlen(ssep);\n"
  "if (!len) {\n"
  "char *rune;\n"
  "s = str_next_rune(&rune, s);\n"
  "while (*rune) {\n"
  "__arr_push(r, (Val)rune);\n"
  "s = str_next_rune(&rune, s);\n"
  "}\n"
  "return r;\n"
  "}\n"
  "if (len == 1) {\n"
  "char csep = *ssep;\n"
  "int i = str_cindex(s, csep);\n"
  "while (i != -1) {\n"
  "char *sub = ATOMIC(i + 1);\n"
  "sub[i] = 0;\n"
  "memcpy(sub, s, i);\n"
  "__arr_push(r, (Val)sub);\n"
  "s = s + i + len;\n"
  "i = str_cindex(s, csep);\n"
  "}\n"
  "__arr_push(r, (Val)str_new(s));\n"
  "return r;\n"
  "}\n"
  "int i = str_index(s, ssep);\n"
  "while (i != -1) {\n"
  "char *sub = ATOMIC(i + 1);\n"
  "sub[i] = 0;\n"
  "memcpy(sub, s, i);\n"
  "__arr_push(r, (Val)sub);\n"
  "s = s + i + len;\n"
  "i = str_index(s, ssep);\n"
  "}\n"
  "__arr_push(r, (Val)str_new(s));\n"
  "return r;\n"
  "}\n"
  "Val __str_splitTrim (Val str, Val sep) {\n"
  "Val r = __str_split(str, sep);\n"
  "Val *p = r.a->begin;\n"
  "Val *end = r.a->end;\n"
  "while (p < end) {\n"
  "*p = __str_trim(*p);\n"
  "++p;\n"
  "}\n"
  "return r;\n"
  "}\n"
  "Val __str_starts(Val str, Val substr) {\n"
  "return (Val)str_starts(str.s, substr.s);\n"
  "}\n"
  "Val __str_sub (Val str, Val begin, Val end) {\n"
  "Val r = __str_toRunes(str);\n"
  "int64_t sz = __arr_size(r).i;\n"
  "begin = begin.i < 0 ? (Val)(sz + begin.i) : begin;\n"
  "end = end.i < 0 ? (Val)(sz + end.i) : end;\n"
  "return __arr_join(__arr_drop(__arr_take(r, end), begin), (Val)\"\");\n"
  "}\n"
  "Val __str_sub_slice(Val str, Val begin, Val end) {\n"
  "return (Val)str_sub(str.s, begin.i, end.i);\n"
  "}\n"
  "Val __str_toLower(Val s) {\n"
  "return (Val)str_to_lower(s.s);\n"
  "}\n"
  "Val __str_toUpper(Val s) {\n"
  "return (Val)str_to_upper(s.s);\n"
  "}\n"
  "Val __str_toRunes (Val str) {\n"
  "char *s = str.s;\n"
  "Val r = __arr_new();\n"
  "char *rune;\n"
  "s = str_next_rune(&rune, s);\n"
  "while (*rune) {\n"
  "__arr_push(r, (Val)rune);\n"
  "s = str_next_rune(&rune, s);\n"
  "}\n"
  "return r;\n"
  "}\n"
  "Val __str_toUtf16 (Val str) {\n"
  "unsigned *u = str_to_unicode(str.s);\n"
  "Val a = __arr_new();\n"
  "unsigned *pu = u;\n"
  "while (*pu) __arr_push(a, (Val)(int64_t)*pu++);\n"
  "return a;\n"
  "}\n"
  "Val __str_trim (Val str) {\n"
  "return (Val)str_trim(str.s);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//sys\n"
  "// -------------------------------------\n"
  "\n"
  "static Val __sys_compiler_root_v = (Val) \"\";\n"
  "static Val __sys_mainPath_v = (Val) \"\";\n"
  "static Val __sys_args_v = (Val) \"\";\n"
  "static void __sys_shandler (int sig) {\n"
  "___built_throw(\"built-in:0\", (Val)\"Arithmetic exception\");\n"
  "}\n"
  "static void __sys_sshandler (int sig) {\n"
  "___built_throw(\"built-in:0\", (Val)\"Segmentation violation\");\n"
  "}\n"
  "void __sys_init(int argc, char **argv, char *compiler_root) {\n"
  "sys_init();\n"
  "signal (SIGFPE, __sys_shandler);\n"
  "signal (SIGSEGV, __sys_sshandler);\n"
  "__sys_compiler_root_v = (Val)compiler_root;\n"
  "__sys_mainPath_v = (Val)*argv;\n"
  "__sys_args_v = __arr_new();\n"
  "for (int i = 1; i < argc; ++i) __arr_push(__sys_args_v, (Val)argv[i]);\n"
  "}\n"
  "Val __sys_args (void) {\n"
  "return __arr_copy(__sys_args_v);\n"
  "}\n"
  "Val __sys_cmd (Val command, Val args) {\n"
  "Val rs = __sys_cmd2(command, args);\n"
  "Val *ok = rs.a->begin;\n"
  "Val *err = ok + 1;\n"
  "Val r = __arr_new();\n"
  "if (*(err->s)) __arr_push(r, __arr_new());\n"
  "else __arr_push(r, __rs_some(*ok));\n"
  "__arr_push(r, *err);\n"
  "return r;\n"
  "}\n"
  "Val __sys_cmd2 (Val command, Val args) {\n"
  "Arr *acmd = arr_new();\n"
  "arr_push(acmd, command.s);\n"
  "Val *p = args.a->begin;\n"
  "Val *end = args.a->end;\n"
  "while (p < end) arr_push(acmd, str_to_escape((*p++).s));\n"
  "Tp *tp = sys_cmd2(arr_cjoin(acmd, ' '));\n"
  "Val r = __arr_new();\n"
  "__arr_push(r, (Val)tp->e1);\n"
  "__arr_push(r, (Val)tp->e2);\n"
  "return r;\n"
  "}\n"
  "Val __sys_compilerRoot (void) {\n"
  "return __sys_compiler_root_v;\n"
  "}\n"
  "Val __sys_environ (void) {\n"
  "return __dic_from_smap(sys_environ());\n"
  "}\n"
  "void __sys_exit (Val code) {\n"
  "exit(code.i);\n"
  "}\n"
  "Val __sys_exec (char *pos, Val command, Val args) {\n"
  "Arr *acmd = arr_new();\n"
  "arr_push(acmd, command.s);\n"
  "Val *p = args.a->begin;\n"
  "Val *end = args.a->end;\n"
  "while (p < end) arr_push(acmd, str_to_escape((*p++).s));\n"
  "return (Val)(int64_t)system(arr_cjoin(acmd, ' '));\n"
  "}\n"
  "Val __sys_getLocale (void) {\n"
  "return (Val)sys_get_locale();\n"
  "}\n"
  "Val __sys_home (void) {\n"
  "return (Val)sys_user_home();\n"
  "}\n"
  "Val __sys_mainPath (void) {\n"
  "return __sys_mainPath_v;\n"
  "}\n"
  "Val __sys_pid (void) {\n"
  "return (Val)getpid();\n"
  "}\n"
  "void __sys_printError (Val text) {\n"
  "fprintf(stderr, \"%s\", text.s);\n"
  "}\n"
  "Val __sys_readLine (void) {\n"
  "return (Val)sys_read_line();\n"
  "}\n"
  "void __sys_setLocale (Val charset) {\n"
  "return sys_set_locale(charset.s);\n"
  "}\n"
  "void __sys_sleep (Val millis) {\n"
  "sys_sleep(millis.i);\n"
  "}\n"
  "Val __sys_user (void) {\n"
  "return (Val)sys_user_name();\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//tcp\n"
  "// -------------------------------------\n"
  "\n"
  "Val __tcp_accept (Val server) {\n"
  "Rs *rs = tcp_accept(server.o);\n"
  "void *conn = rs_get(rs);\n"
  "if (!conn) return __rs_fail((Val)rs_error(rs));\n"
  "return __rs_ok((Val)conn);\n"
  "}\n"
  "void __tcp_closeConnection (Val conn) {\n"
  "tcp_close_conn(conn.o);\n"
  "}\n"
  "void __tcp_closeServer (Val server) {\n"
  "tcp_close_server(server.o);\n"
  "}\n"
  "Val __tcp_dial (Val server_name) {\n"
  "char *sv = server_name.s;\n"
  "int ok = TRUE;\n"
  "Arr *ps = str_csplit(sv, ':');\n"
  "if (arr_size(ps) != 2) ok = FALSE;\n"
  "if (ok && !math_digits(arr_get(ps, 1))) ok = FALSE;\n"
  "if (!ok)\n"
  "return __rs_fail((Val)str_f(\"Bad sever:port (%s)\", sv));\n"
  "Rs *rs = tcp_dial(arr_get(ps, 0), math_stoi(arr_get(ps, 1)));\n"
  "void *conn = rs_get(rs);\n"
  "if (!conn) return __rs_fail((Val)rs_error(rs));\n"
  "return __rs_ok((Val)conn);\n"
  "}\n"
  "Val __tcp_read (Val conn, Val lim, Val seconds) {\n"
  "Rs *rs = tcp_read(conn.o, lim.i, seconds.i);\n"
  "void *bs = rs_get(rs);\n"
  "if (!bs) return __rs_fail((Val)rs_error(rs));\n"
  "return __rs_ok((Val)bs);\n"
  "}\n"
  "Val __tcp_server (Val port, Val nconns) {\n"
  "return (Val)(void *)tcp_server(port.i, nconns.i);\n"
  "}\n"
  "Val __tcp_write (Val conn, Val data) {\n"
  "return (Val)tcp_write(conn.o, data.o);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//thread\n"
  "// -------------------------------------\n"
  "\n"
  "void __thread_join (Val th) {\n"
  "thread_join(th.o);\n"
  "}\n"
  "void __thread_run (Val fn) {\n"
  "thread_run ((void (*)(void))fn.o);\n"
  "}\n"
  "Val __thread_start (Val fn) {\n"
  "return (Val)(void *)thread_start((void (*)(void))fn.o);\n"
  "}\n"
  "void __thread_sync (Val fn) {\n"
  "thread_sync ((void (*)(void))fn.o);\n"
  "}\n"
  "\n"
  "\n"
  "// -------------------------------------\n"
  "//time\n"
  "// -------------------------------------\n"
  "\n"
  "Val __time_addDays (Val tm, Val days) {\n"
  "return (Val)time_add(tm.i, (int)days.i);\n"
  "}\n"
  "Val __time_day (Val tm) {\n"
  "return (Val)(int64_t)time_day(tm.i);\n"
  "}\n"
  "Val __time_dfDays (Val tm1, Val tm2) {\n"
  "return (Val)(int64_t)time_df(tm1.i, tm2.i);\n"
  "}\n"
  "Val __time_eqDay (Val tm1, Val tm2) {\n"
  "return (Val)time_eq(tm1.i, tm2.i);\n"
  "}\n"
  "Val __time_fmt (Val tm_val, Val template) {\n"
  "char *time_fmt (int64_t tm, char *template) {\n"
  "char *s, *rs;\n"
  "time_t tthis = (time_t)(tm / 1000);\n"
  "struct tm *t = localtime(&tthis);\n"
  "int size = 126;\n"
  "while (1) {\n"
  "rs = (char *)calloc(size, 1); // calloc ok\n"
  "if (strftime (rs, size, template, t)) {\n"
  "s = str_new(rs);\n"
  "free(rs); // free ok\n"
  "break;\n"
  "}\n"
  "free(rs); // free ok\n"
  "size += size;\n"
  "}\n"
  "return s;\n"
  "}\n"
  "int64_t tm = tm_val.i;\n"
  "char *s = template.s;\n"
  "int len = strlen(s);\n"
  "int p = 0;\n"
  "Buf *r = buf_new();\n"
  "for (;;) {\n"
  "int i = str_cindex_from(s, '%', p);\n"
  "if (i == -1) break;\n"
  "buf_add(r, str_sub(s, p, i));\n"
  "++i;\n"
  "if (i == len)\n"
  "___built_throw(\n"
  "\"built-in(time.fmt):0\",\n"
  "(Val)\"Bad '%' sequence at end of string\"\n"
  ");\n"
  "char ch = s[i];\n"
  "if (ch == '%') {\n"
  "buf_cadd(r, ch);\n"
  "p = i + 1;\n"
  "continue;\n"
  "}\n"
  "if (\n"
  "ch == 'd' || ch == 'D' || ch == 'm' || ch == 'M' || ch == 'y' ||\n"
  "ch == 'Y' || ch == 't' || ch == 'T'\n"
  ") {\n"
  "switch (ch) {\n"
  "case 'd' :\n"
  "buf_add(r, str_ltrim(time_fmt(tm, \"%e\")));\n"
  "break;\n"
  "case 'D':\n"
  "buf_add(r, time_fmt(tm, \"%d\"));\n"
  "break;\n"
  "case 'm': {\n"
  "char *v = time_fmt(tm, \"%m\");\n"
  "if (*v == '0') v = v + 1;\n"
  "buf_add(r, v);\n"
  "break;\n"
  "}\n"
  "case 'M':\n"
  "buf_add(r, time_fmt(tm, \"%m\"));\n"
  "break;\n"
  "case 'y':\n"
  "buf_add(r, time_fmt(tm, \"%y\"));\n"
  "break;\n"
  "case 'Y':\n"
  "buf_add(r, time_fmt(tm, \"%Y\"));\n"
  "break;\n"
  "case 't':\n"
  "buf_add(r, time_fmt(tm, \"%T\"));\n"
  "break;\n"
  "default: { // 'T'\n"
  "char *millis = str_f(\"%ld\", tm % 1000);\n"
  "buf_add(r, str_f(\"%s.%s\", time_fmt(tm, \"%T\"), millis));\n"
  "}\n"
  "}\n"
  "p = i + 1;\n"
  "continue;\n"
  "}\n"
  "___built_throw(\"built-in(time.fmt):0\", (Val)\"Bad '%' sequence\");\n"
  "}\n"
  "buf_add(r, str_right(s, p));\n"
  "return (Val)str_new(buf_str(r));\n"
  "}\n"
  "Val __time_fromClock (Val tm, Val template) {\n"
  "int to_time_number (char *n, int max) {\n"
  "if (strlen(n) != 2) return -1;\n"
  "if (!math_digits(n)) return -1;\n"
  "int nn = math_stoi(n);\n"
  "if (nn >= max) return -1;\n"
  "return nn;\n"
  "}\n"
  "char *tms = template.s;\n"
  "Arr *ps = str_csplit(tms, ':');\n"
  "if (arr_size(ps) == 3) {\n"
  "int h = to_time_number(arr_get(ps, 0), 24);\n"
  "if (h != 1) {\n"
  "int m = to_time_number(arr_get(ps, 1), 60);\n"
  "if (m != -1) {\n"
  "int s = to_time_number(arr_get(ps, 2), 60);\n"
  "if (s != -1) {\n"
  "return __rs_some(__time_new(\n"
  "__time_day(tm), __time_month(tm), __time_year(tm),\n"
  "(Val)(int64_t)h, (Val)(int64_t)m, (Val)(int64_t)s\n"
  "));\n"
  "}\n"
  "}\n"
  "}\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __time_from_str_op_aux(char *date) {\n"
  "if (strlen(date) != 8 && !math_digits(date)) return __arr_new();\n"
  "char tpl[5];\n"
  "memset (tpl, 0, 5);\n"
  "memcpy(tpl, date + 6, 2);\n"
  "int d = atoi(tpl);\n"
  "memcpy(tpl, date + 4, 2);\n"
  "int m = atoi(tpl);\n"
  "memcpy(tpl, date, 4);\n"
  "int y = atoi(tpl);\n"
  "return __rs_some(__time_newDate(\n"
  "(Val)(int64_t)d, (Val)(int64_t)m, (Val)(int64_t)y\n"
  "));\n"
  "}\n"
  "Val __time_from_iso_en_op (int is_iso, char *date, char sep) {\n"
  "Arr *parts = str_csplit(date, sep);\n"
  "if (arr_size(parts) == 3) {\n"
  "char *d = arr_get(parts, (is_iso) ? 0 : 1);\n"
  "char *m = arr_get(parts, (is_iso) ? 1 : 0);\n"
  "char *y = arr_get(parts, 2);\n"
  "if (strlen(d) == 1) d = str_f(\"%s%s\", \"0\", d);\n"
  "if (strlen(m) == 1) m = str_f(\"%s%s\", \"0\", m);\n"
  "if (strlen(y) == 2) y = str_f(\"%s%s\", \"20\", y);\n"
  "if (strlen(d) == 2 && strlen(m) == 2 && strlen(y) == 4)\n"
  "return __time_from_str_op_aux(str_f(\"%s%s%s\", y, m, d));\n"
  "}\n"
  "return __arr_new();\n"
  "}\n"
  "Val __time_fromEn (Val s, Val sep) {\n"
  "return __time_from_iso_en_op(FALSE, s.s, *sep.s);\n"
  "}\n"
  "Val __time_fromIso (Val s, Val sep) {\n"
  "return __time_from_iso_en_op(TRUE, s.s, *sep.s);\n"
  "}\n"
  "Val __time_fromStr (Val s) {\n"
  "return __time_from_str_op_aux(s.s);\n"
  "}\n"
  "Val __time_hour (Val tm) {\n"
  "return (Val)(int64_t)time_hour(tm.i);\n"
  "}\n"
  "Val __time_millisecond (Val tm) {\n"
  "return (Val)(int64_t)time_millisecond(tm.i);\n"
  "}\n"
  "Val __time_minute (Val tm) {\n"
  "return (Val)(int64_t)time_minute(tm.i);\n"
  "}\n"
  "Val __time_month (Val tm) {\n"
  "return (Val)(int64_t)(time_month(tm.i) + 1);\n"
  "}\n"
  "Val __time_new (Val day, Val month, Val year, Val hour, Val minute, Val second) {\n"
  "return (Val)time_new_time(\n"
  "(int)day.i, (int)(month.i - 1), (int)year.i,\n"
  "(int)hour.i, (int)minute.i, (int)second.i\n"
  ");\n"
  "}\n"
  "Val __time_newDate (Val day, Val month, Val year) {\n"
  "return (Val)time_new((int)day.i, (int)(month.i - 1), (int)year.i);\n"
  "}\n"
  "Val __time_now (void) {\n"
  "return (Val)time_now();\n"
  "}\n"
  "Val __time_second (Val tm) {\n"
  "return (Val)(int64_t)time_second(tm.i);\n"
  "}\n"
  "Val __time_toEn (Val tm) {\n"
  "return (Val)time_to_us(tm.i);\n"
  "}\n"
  "Val __time_toIso (Val tm) {\n"
  "return (Val)time_to_iso(tm.i);\n"
  "}\n"
  "Val __time_toStr (Val tm) {\n"
  "return (Val)time_to_str(tm.i);\n"
  "}\n"
  "Val __time_weekday (Val tm) {\n"
  "return (Val)(int64_t)time_week_day(tm.i);\n"
  "}\n"
  "Val __time_year (Val tm) {\n"
  "return (Val)(int64_t)time_year(tm.i);\n"
  "}\n"
  "Val __time_yearDay (Val tm) {\n"
  "return (Val)(int64_t)(time_year_day(tm.i) + 1);\n"
  "}\n"
  "\n"
  "\n"
;
}
