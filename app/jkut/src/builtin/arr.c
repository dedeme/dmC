// Copyright 30-Jul-2023 ºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

char *arr_bget (void) {return
  "// Copyright 28-Apr-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "import * as sys from './sys.js';\n"
  "import * as iter from './iter.js';\n"
  "\n"
  "// \\a, (\\*->b) -> b\n"
  "export function all (a, fn) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  sys.$fparams(fn, 1);\n"
  "  return a.every(e => fn(e));\n"
  "}\n"
  "\n"
  "// \\a, (\\*->b) -> b\n"
  "export function any (a, fn) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  sys.$fparams(fn, 1);\n"
  "  return a.some(e => fn(e));\n"
  "}\n"
  "\n"
  "// \\a, a -> ()\n"
  "export function cat (a1, a2) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  a1.push(...a2);\n"
  "}\n"
  "\n"
  "// \\a -> ()\n"
  "export function clear (a) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  a.length = 0;\n"
  "}\n"
  "\n"
  "// \\[a...] -> a\n"
  "export function concat (a) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  let r = [];\n"
  "  for (const e of a) r = r.concat(e);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "// \\a -> a\n"
  "export function copy (a) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return a.slice();\n"
  "}\n"
  "\n"
  "// \\a, n -> a\n"
  "export function drop (a, n) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  if (n < 0) n = 0;\n"
  "  return a.slice(n);\n"
  "}\n"
  "\n"
  "// \\a, (\\*->b) -> a\n"
  "export function dropWhile (a, fn) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  sys.$fparams(fn, 1);\n"
  "  const n = a.findIndex((e) => !fn(e));\n"
  "  return n == -1 ? [] : a.slice(n);\n"
  "}\n"
  "\n"
  "// \\a, (\\*,*->b) -> [a, a]\n"
  "export function duplicates (a, fn) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  sys.$fparams(fn, 2);\n"
  "  const rs = [];\n"
  "  const dup = [];\n"
  "  for (const e1 of a)\n"
  "    if (rs.some(e2 => fn(e1, e2))) {\n"
  "      if (!dup.some(e3 => fn(e1, e3))) dup.push(e1);\n"
  "    } else {\n"
  "      rs.push(e1);\n"
  "    }\n"
  "  return [rs, dup];\n"
  "}\n"
  "\n"
  "// \\a, (\\*->()) -> ()\n"
  "export function each (a, fn) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  sys.$fparams(fn, 1);\n"
  "  a.forEach(e => fn(e));\n"
  "}\n"
  "\n"
  "// \\a, (\\*,n->()) -> ()\n"
  "export function eachIx (a, fn) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  sys.$fparams(fn, 2);\n"
  "  a.forEach((e, i) => fn(e, i));\n"
  "}\n"
  "\n"
  "// \\a, (\\*->()) -> ()\n"
  "export function filter (a, fn) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  sys.$fparams(fn, 1);\n"
  "  return a.filter(e => fn(e));\n"
  "}\n"
  "\n"
  "// \\a, (\\*->()) -> ()\n"
  "export function filterIn (a, fn) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  sys.$fparams(fn, 1);\n"
  "  let ni = 0;\n"
  "  for (let i = 0; i < a.length; ++i) {\n"
  "    if (fn(a[i])) {\n"
  "      a[ni] = a[i];\n"
  "      ++ni;\n"
  "    }\n"
  "  }\n"
  "  a.length = ni;\n"
  "}\n"
  "\n"
  "// \\a, (\\*->()) -> ([*] | [])\n"
  "export function find (a, fn) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  sys.$fparams(fn, 1);\n"
  "  return sys.$null(a.find(e => fn(e)));\n"
  "}\n"
  "\n"
  "// \\<iter> -> a\n"
  "export function fromIter (it) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  const r = [];\n"
  "  while (iter.hasNext(it)) r.push(iter.next(it));\n"
  "  return r;\n"
  "}\n"
  "\n"
  "// \\a, (\\*->b) -> n\n"
  "export function index (a, fn) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  sys.$fparams(fn, 1);\n"
  "  return a.findIndex(e => fn(e));\n"
  "}\n"
  "\n"
  "// \\[s...], s -> s\n"
  "export function join (a, sp) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  return a.join(sp);\n"
  "}\n"
  "\n"
  "// \\a, (\\*->*) -> a\n"
  "export function map (a, fn) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  sys.$fparams(fn, 1);\n"
  "  const r = [];\n"
  "  r.length = a.length;\n"
  "  for (let i = 0; i < a.length; ++i) r[i] = fn(a[i]);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "// \\n, * -> a\n"
  "export function mk (n, e) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  if (n < 0) n == 0;\n"
  "  const r = [];\n"
  "  r.length = n;\n"
  "  if (typeof(e) === \"object\") {\n"
  "    if (Array.isArray(e))\n"
  "      for (let i = 0; i < n; ++i) r[i] = e.slice();\n"
  "    else\n"
  "      throw new Error(\n"
  "        '\\nExpected: boolean, number, string or Array.\\n   Found: ' + o\n"
  "      );\n"
  "  } else {\n"
  "    for (let i = 0; i < n; ++i) r[i] = e;\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "\n"
  "// \\a -> *\n"
  "export function peek (a) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  if (a.length == 0) throw new Error(\"Array is empty\");\n"
  "  return a[a.length - 1];\n"
  "}\n"
  "\n"
  "// \\a -> *\n"
  "export function pop (a) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  if (a.length == 0) throw new Error(\"Array is empty\");\n"
  "  return a.pop();\n"
  "}\n"
  "\n"
  "// \\a, * -> ()\n"
  "export function push (a, e) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  a.push(e);\n"
  "}\n"
  "\n"
  "// \\a, *, (\\*,*->*) -> *\n"
  "export function reduce (a, seed, fn) {\n"
  "  sys.$params(arguments.length, 3);\n"
  "  sys.$fparams(fn, 2);\n"
  "  return a.reduce((r, e, v1, v2) => fn(r,e), seed);\n"
  "}\n"
  "\n"
  "// \\a, n -> *\n"
  "export function remove (a, ix) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  const r = a[ix];\n"
  "  if (r !== undefined) a.splice(ix, 1);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "// \\a -> a\n"
  "export function reverse (a) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return a.slice().reverse();\n"
  "}\n"
  "\n"
  "// \\a -> ()\n"
  "export function reverseIn (a) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  a.reverse();\n"
  "}\n"
  "\n"
  "// \\a -> *\n"
  "export function shift (a) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  if (a.length == 0) throw new Error(\"Array is empty\");\n"
  "  return a.shift();\n"
  "}\n"
  "\n"
  "// \\a -> ()\n"
  "export function shuffle (a) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  for (let i = a.length - 1; i > 0; i--) {\n"
  "    const j = Math.floor(Math.random() * (i + 1));\n"
  "    [a[i], a[j]] = [a[j], a[i]];\n"
  "  }\n"
  "}\n"
  "\n"
  "// \\a -> n\n"
  "export function size (a) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return a.length;\n"
  "}\n"
  "\n"
  "// (\\a, \\*,*->b) -> ()\n"
  "export function sort (a, fn) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  sys.$fparams(fn, 2);\n"
  "  a.sort((a, b) => fn(a, b) ? -1 : 1);\n"
  "}\n"
  "\n"
  "// \\a, n -> a\n"
  "export function take (a, n) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  if (n < 0) n = 0;\n"
  "  return a.slice(0, n);\n"
  "}\n"
  "\n"
  "// \\a, (\\*->b) -> a\n"
  "export function takeWhile (a, fn) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  sys.$fparams(fn, 1);\n"
  "  const n = a.findIndex((e) => !fn(e));\n"
  "  return n == -1 ? a.slice() : a.slice(0, n);\n"
  "}\n"
  "\n"
  "// \\a -> <iter>\n"
  "export function toIter (a) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  let ix = 0;\n"
  "  return iter.mk(\n"
  "    () => ix < a.length,\n"
  "    () => a[ix++]\n"
  "  );\n"
  "}\n"
  "\n"
  "// \\a, * -> ()\n"
  "export function unshift (a, e) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  a.unshift(e);\n"
  "}\n"
  "\n"
  "\n"
;}
