// Copyright 24-Jun-2023 ºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

char *client_bget (void) {return
  "// Copyright 05-May-2023 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "import * as sys from './sys.js';\n"
  "import * as js from './js.js';\n"
  "import * as str from './str.js';\n"
  "import * as dic from './dic.js';\n"
  "import * as b64 from './b64.js';\n"
  "import * as cryp from './cryp.js';\n"
  "import * as timer from './timer.js';\n"
  "import * as storage from './storage.js';\n"
  "\n"
  "const klen = 300;\n"
  "let isDmCgi = true;\n"
  "let appName = \"\";\n"
  "let user = \"\";\n"
  "let sessionKey = \"0\";\n"
  "let connectionKey = \"\";\n"
  "let levelV = \"\";\n"
  "let fExpired = () => {};\n"
  "\n"
  "// \\s -> <promise>s\n"
  "function sendServer (jsRq) {\n"
  "  return new Promise(function (resolve, reject) {\n"
  "    const request = new XMLHttpRequest();\n"
  "    request.open(\n"
  "      \"POST\",\n"
  "      \"http://\" + location.host + (isDmCgi ? \"/cgi-bin/ccgi.sh\" : \"\"),\n"
  "      true\n"
  "    );\n"
  "    request.onload = () => {\n"
  "      if (request.status >= 200 && request.status < 300)\n"
  "        resolve(request.responseText.trim());\n"
  "      else reject(new Error(request.statusText));\n"
  "    };\n"
  "    request.onerror = () => reject(new Error(\"Network error: \" + request.statusText));\n"
  "    request.onabort = () => reject(new Error(\"Network error: \" + request.statusText));\n"
  "    request.setRequestHeader(\n"
  "      \"Content-Type\",\n"
  "      \"text/plain\"\n"
  "    );\n"
  "    request.send(appName + \":\" + jsRq);\n"
  "  });\n"
  "}\n"
  "\n"
  "// \\b, {*...} -> <promise>{*...}\n"
  "async function sendCommon (isSecure, rq) {\n"
  "  let rp = \"<without response>\";\n"
  "  try {\n"
  "    rp = await sendServer(isSecure\n"
  "      ? sessionId() + \":\" + connectionKey + \":\" + cryp.encode(sessionKey, js.w(rq))\n"
  "      : sessionId() + \":\" + cryp.encode(sessionKey, js.w(rq))\n"
  "    );\n"
  "    return js.r(cryp.decode(sessionKey, rp));\n"
  "  } catch (e) {\n"
  "    try {\n"
  "      const data = js.r(cryp.decode(\"nosession\", rp));\n"
  "      if (dic.hasKey(data, \"expired\")) {\n"
  "        fExpired();\n"
  "        return {};\n"
  "      }\n"
  "      throw(e);\n"
  "    } catch (e2) {\n"
  "      throw new Error(str.fmt(\n"
  "        \"RAW SERVER RESPONSE:\\n%v\\nCLIENT ERROR:\\n%v\", [rp, e2.message]\n"
  "      ));\n"
  "    }\n"
  "  }\n"
  "}\n"
  "\n"
  "// \\s, s, b -> <promise>b\n"
  "export async function authentication (userName, pass, withExpiration) {\n"
  "  sys.$params(arguments.length, 3);\n"
  "\n"
  "  sessionKey = cryp.key(appName, klen);\n"
  "  const p = crypPass(pass);\n"
  "  const exp = withExpiration ? \"1\" : \"0\";\n"
  "  let rp = \"<without response>\";\n"
  "  try {\n"
  "    rp = await sendServer(\n"
  "      \":\" + cryp.encode(sessionKey, str.fmt(\"%v:%v:%v\", [userName, p, exp]))\n"
  "    );\n"
  "    const data = js.r(cryp.decode(sessionKey, rp));\n"
  "    const sessionId = data[\"sessionId\"];\n"
  "    if (sessionId === \"\") return false;\n"
  "\n"
  "    storage.put(\"Client_sessionId_\" + appName, sessionId);\n"
  "    user = userName;\n"
  "    sessionKey = data[\"key\"];\n"
  "    levelV = data[\"level\"];\n"
  "    connectionKey = [\"conKey\"];\n"
  "    return true;\n"
  "  } catch (e) {\n"
  "    throw new Error(str.fmt(\n"
  "      \"RAW SERVER RESPONSE:\\n%v\\nCLIENT ERROR:\\n%v\", [rp, e.message]\n"
  "    ));\n"
  "  }\n"
  "}\n"
  "\n"
  "// \\-> <promise>b\n"
  "export async function connect () {\n"
  "  sys.$params(arguments.length, 0);\n"
  "\n"
  "  let rp = \"<without response>\";\n"
  "  try {\n"
  "    rp = await sendServer(sessionId());\n"
  "    const data = js.r(cryp.decode(sessionId(), rp));\n"
  "    sessionKey = data[\"key\"];\n"
  "    if (sessionKey === \"\") return false;\n"
  "\n"
  "    user = data[\"user\"];\n"
  "    levelV = data[\"level\"];\n"
  "    connectionKey = data[\"conKey\"];\n"
  "    return true;\n"
  "  } catch (e) {\n"
  "    throw new Error(str.fmt(\n"
  "      \"RAW SERVER RESPONSE:\\n%v\\nCLIENT ERROR:\\n%v\", [rp, e.message]\n"
  "    ));\n"
  "  }\n"
  "}\n"
  "\n"
  "// \\s -> s\n"
  "export function crypPass (pass) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return cryp.key(pass, klen);\n"
  "}\n"
  "\n"
  "// \\b, s, (\\->()) -> ()\n"
  "export function init (isDmCgiP, appNameP, fExpiredP) {\n"
  "  sys.$params(arguments.length, 3);\n"
  "  isDmCgi = isDmCgiP;\n"
  "  appName = appNameP;\n"
  "  fExpired = fExpiredP;\n"
  "}\n"
  "\n"
  "// \\-> i\n"
  "export function level () {\n"
  "  sys.$params(arguments.length, 0);\n"
  "  return levelV;\n"
  "}\n"
  "\n"
  "// \\{*...} -> <promise>{*...}\n"
  "export async function longRun (rq) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "\n"
  "  const tm = timer.mk(1000);\n"
  "  let count = 0;\n"
  "  rq[\"longRunFile\"] = \"\";\n"
  "  let rp = await send(rq);\n"
  "\n"
  "  if (dic.hasKey(rp, \"longRunEnd\") && rp[\"longRunEnd\"]) return rp;\n"
  "\n"
  "  timer.run(tm, async () => {\n"
  "    rp = await send(rq);\n"
  "    ++count;\n"
  "\n"
  "    if (dic.hasKey(rp, \"longRunEnd\") && rp[\"longRunEnd\"]) timer.stop(tm);\n"
  "    else if (count >= 60) throw new Error(\"Long run time over\");\n"
  "    return rp;\n"
  "  });\n"
  "}\n"
  "\n"
  "// \\-> s\n"
  "export function sessionId () {\n"
  "  sys.$params(arguments.length, 0);\n"
  "  const r = storage.get(\"Client_sessionId_\" + appName);\n"
  "  return sys.asBool(r) ? r[0] : b64.encode(\"0\");\n"
  "}\n"
  "\n"
  "// \\{*...} -> <promise>{*...}\n"
  "export async function send (rq) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return await sendCommon(false, rq);\n"
  "}\n"
  "\n"
  "// \\{*...} -> <promise>{*...}\n"
  "export async function ssend (rq) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return await sendCommon(true, rq);\n"
  "}\n"
  "\n"
  "// \\-> s\n"
  "export function userName () {\n"
  "  sys.$params(arguments.length, 0);\n"
  "  return user;\n"
  "}\n"
  "\n"
  "\n"
;}
