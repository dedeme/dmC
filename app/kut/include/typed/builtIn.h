// Copyright 22-Aug-2024 ÂºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

/// Built-in base.

#ifndef TYPED_BUILT_IN_H
  #define TYPED_BUILT_IN_H

/// Header.
char *builtIn_head =
  "// 0base.h ----------\n"
  "#define _GNU_SOURCE\n"
  "#define GC_THREADS\n"
  "#include <stdlib.h>\n"
  "#include <stdint.h>\n"
  "#include <stdio.h>\n"
  "#include <string.h>\n"
  "#include <stdarg.h>\n"
  "#include <locale.h>\n"
  "#include <math.h>\n"
  "#include <limits.h>\n"
  "#include <float.h>\n"
  "#include <ctype.h>\n"
  "#include <wctype.h>\n"
  "#include <time.h>\n"
  "#include <sys/time.h>\n"
  "#include <errno.h>\n"
  "#include <setjmp.h>\n"
  "#include <regex.h>\n"
  "#include <dirent.h>\n"
  "#include <unistd.h>\n"
  "#include <errno.h>\n"
  "#include <sys/stat.h>\n"
  "#include <fcntl.h>\n"
  "#include <gc.h>\n"
  "#define TRUE 1\n"
  "#define FALSE 0\n"
  "#define MALLOC(type) (type *)GC_MALLOC(sizeof(type))\n"
  "#define ATOMIC(size) GC_MALLOC_ATOMIC(size)\n"
  "\n"
  "typedef struct tarr_Arri Arri;\n"
  "typedef struct tarr_Arrf Arrf;\n"
  "typedef struct tarr_Arrs Arrs;\n"
  "typedef struct obj_Obj Obj;\n"
  "\n"
  "static void (*built_exc_fns) (char, void *);\n"
  "\n"
  "static int built_eqb (int v1, int v2);\n"
  "static int built_eqi (int64_t v1, int64_t v2);\n"
  "static int built_eqf (double v1, double v2);\n"
  "static int built_eqs (char *v1, char *v2);\n"
  "static int built_eqo (Obj *v1, Obj *v2);\n"
  "static int built_eqI (Arri *v1, Arri *v2);\n"
  "static int built_eqF (Arrf *v1, Arrf *v2);\n"
  "static int built_eqS (Arrs *v1, Arrs *v2);\n"
  "static int built_eqD (Arrs *v1, Arrs *v2);\n"
  "static int built_neqb (int v1, int v2);\n"
  "static int built_neqi (int64_t v1, int64_t v2);\n"
  "static int built_neqf (double v1, double v2);\n"
  "static int built_neqs (char *v1, char *v2);\n"
  "static int built_neqo (Obj *v1, Obj *v2);\n"
  "static int built_neqI (Arri *v1, Arri *v2);\n"
  "static int built_neqF (Arrf *v1, Arrf *v2);\n"
  "static int built_neqS (Arrs *v1, Arrs *v2);\n"
  "static int built_neqD (Arrs *v1, Arrs *v2);\n"
  "static char *built_to_strb (int v);\n"
  "static char *built_to_stri (int64_t v);\n"
  "static char *built_to_strf (double s);\n"
  "static char *built_to_strs (char *s);\n"
  "static char *built_to_stro (Obj *o);\n"
  "static char *built_to_strI (Arri *a);\n"
  "static char *built_to_strF (Arrf *a);\n"
  "static char *built_to_strS (Arrs *a);\n"
  "static char *built_to_strD (Arrs *m);\n"
  "static void built_trace(int is_short, char *position, char *exp);\n"
  "\n"
"// b64.h ----------\n"
  "static char *b64_table =\n"
  "    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n"
  "static char *b64_decode(char *b64);\n"
  "static Obj *b64_decode_bytes(char *b64);\n"
  "static char *b64_encode(char *s);\n"
  "static char *b64_encode_bytes(Obj *bs);\n"
  "\n"
"// buf.h ----------\n"
  "typedef struct buf_Buf Buf;\n"
  "\n"
  "static Buf *buf_new ();\n"
  "static Buf *buf_new_bf (int buffer_size);\n"
  "static char *buf_str (Buf *this);\n"
  "static int buf_len (Buf *this);\n"
  "static void buf_add_buf (Buf *this, char *data, int length);\n"
  "static void buf_add(Buf *this, char *data);\n"
  "static void buf_cadd(Buf *this, char data);\n"
  "static void buf_reset(Buf *this);\n"
  "\n"
"// bytes.h ----------\n"
  "typedef struct bytes_Bytes {\n"
  "  unsigned char *bs;\n"
  "  int64_t length;\n"
  "} Bytes;\n"
  "static Obj *bytes_add (Obj *this, Obj *other);\n"
  "static Obj *bytes_drop (Obj *this, int64_t n);\n"
  "static Obj *bytes_from_arr (Arri *a);\n"
  "static Obj *bytes_from_bytes(unsigned char *bs, int length);\n"
  "static Obj *bytes_from_str (char *s);\n"
  "static int64_t bytes_get (Obj *this, int64_t ix);\n"
  "static Obj *bytes_new (int64_t length);\n"
  "static void bytes_set (Obj *this, int64_t ix, int64_t v);\n"
  "static int64_t bytes_size (Obj *this);\n"
  "static Obj *bytes_take (Obj *this, int64_t n);\n"
  "static Arri *bytes_to_arr (Obj *this);\n"
  "static char *bytes_to_str (Obj *this);\n"
  "\n"
"// cryp.h ----------\n"
  "static char *cryp_genk (int lg);\n"
  "static char *cryp_key (char *k, int lg);\n"
  "static char *cryp_encode (char *k, char *s);\n"
  "static char *cryp_decode (char *k, char *b64);\n"
  "\n"
"// dic.h ----------\n"
  "typedef struct tarr_Arrs Arrs;\n"
  "static void dic_add(Arrs *this, char *key, char *value);\n"
  "static Arrs *dic_from_arr (Arrs *a);\n"
  "static Arrs *dic_get(Arrs *this, char *key);\n"
  "static char *dic_get_or_exc(Arrs *this, char *key);\n"
  "static char *dic_get_or_null(Arrs *this, char *key);\n"
  "static int dic_has_key(Arrs *this, char *key);\n"
  "static Arrs *dic_keys(Arrs *this);\n"
  "static Arrs *dic_new();\n"
  "static void dic_put(Arrs *this, char *key, char *value);\n"
  "static void dic_remove(Arrs *this, char *key);\n"
  "static void dic_set(Arrs *this, char *key, char *value);\n"
  "static int dic_size(Arrs *this);\n"
  "static Arrs *dic_values(Arrs *this);\n"
  "\n"
"// file.h ----------\n"
  "static Obj *file_aopen (char *path);\n"
  "static char *file_base (char *path);\n"
  "static char *file_canonical (char *path);\n"
  "static char *file_cat (Arrs *parts);\n"
  "static void file_cd (char *path);\n"
  "static char *file_clean (char *path);\n"
  "static void file_close (Obj *file);\n"
  "static void file_copy (char *source, char *target);\n"
  "static void file_del (char *path);\n"
  "static Arrs *file_dir (char *path);\n"
  "static int file_exists (char *path);\n"
  "static char *file_extension (char *path);\n"
  "struct stat *file_info (char *path);\n"
  "static int file_is_directory (char *path);\n"
  "static int file_is_link (char *path);\n"
  "static int file_is_regular (char *path);\n"
  "static Obj *file_lck_new(FILE *file);\n"
  "static void file_mkdir (char *path);\n"
  "static void file_mklink (char *path, char *link);\n"
  "static char *file_normalize(char *path);\n"
  "static char *file_parent (char *path);\n"
  "static char *file_read (char *path);\n"
  "static Obj *file_read_bin (Obj *file, int64_t buf);\n"
  "static Arrs *file_read_line (Obj *file);\n"
  "static void file_rename (char *old, char *new);\n"
  "static Obj *file_ropen (char *path);\n"
  "static int64_t file_size (char *path);\n"
  "static int64_t file_tm (char *path);\n"
  "static char *file_tmp (char *dir, char *prefix);\n"
  "static char *file_wd (void);\n"
  "static Obj *file_wopen (char *path);\n"
  "static void file_write (char *path, char *text);\n"
  "static void file_write_bin (Obj *file, Obj *bs);\n"
  "static void file_write_text (Obj *file, char *text);\n"
  "\n"
"// js.h ----------\n"
  "typedef struct tarr_Arrs Arrs;\n"
  "\n"
  "static int js_is_null (char *json);\n"
  "static int js_rb (char *json);\n"
  "static int64_t js_ri (char *json);\n"
  "static double js_rf (char *json);\n"
  "static char *js_rs (char *json);\n"
  "static Arrs *js_ra (char *json);\n"
  "static Arrs *js_ro (char *json);\n"
  "static char *js_wb(int value);\n"
  "static char *js_wi(int64_t n);\n"
  "static char *js_wf(double n);\n"
  "static char *js_wf2(double n, int64_t scale);\n"
  "static char *js_ws(char *s);\n"
  "static char *js_wa(Arrs *a);\n"
  "static char *js_wo(Arrs *m);\n"
  "\n"
"// math.h ----------\n"
  "static double math_abs (double n);\n"
  "static int math_digits (char *s);\n"
  "static int math_eq (double n1, double n2);\n"
  "static int math_eq_gap (double n1, double n2, double gap);\n"
  "static Arrf *math_from_en (char *s);\n"
  "static Arri *math_from_hex (char *s);\n"
  "static Arrf *math_from_iso (char *s);\n"
  "static char *math_ftos (double n);\n"
  "static char *math_ftos2 (double n, int scale);\n"
  "static char *math_itos (int64_t n);\n"
  "static double math_max (double n1, double n2);\n"
  "static double math_min (double n1, double n2);\n"
  "static double math_pow10 (int64_t ex);\n"
  "static double math_rnd (void);\n"
  "static int64_t math_rndi (int64_t top);\n"
  "static double math_round (double n, int64_t scale);\n"
  "static Arrf *math_stof (char *s);\n"
  "static Arri *math_stoi (char *s);\n"
  "static Arri *math_stoi_base (char *s, int base);\n"
  "\n"
"// obj.h ----------\n"
  "typedef struct obj_Obj {\n"
  "  char *type;\n"
  "  void *value;\n"
  "} Obj;\n"
  "Obj *obj_new(char *type, void *value);\n"
  "\n"
"// regex.h ----------\n"
  "static Arrs *regex_matches (char *s, char *rg);\n"
  "static char *regex_replace (char *source, char *rg, char *repl);\n"
  "\n"
"// str.h ----------\n"
  "static int str_cindex (char *str, char ch);\n"
  "static int str_cindex_from (char *str, char ch, int start);\n"
  "static char *str_creplace (char *s, char old, char new);\n"
  "static Arrs *str_csplit (char *s, char sep);\n"
  "static int str_ends (char *str, char  *substr);\n"
  "static char *str_f (char *format, ...);\n"
  "static char *str_fmt (char *format, Arrs *values);\n"
  "static char *str_from_escape (char *str);\n"
  "static char *str_from_iso (char *s);\n"
  "static char *str_from_unicode (unsigned *u);\n"
  "static char *str_from_utf16 (Arri *codepoints);\n"
  "static char *str_get (char *str, int64_t ix);\n"
  "static int str_index (char *str, char *substr);\n"
  "static int str_index_from (char *str, char *substr, int64_t start);\n"
  "static int str_last_cindex (char *str, char ch);\n"
  "static int str_last_index (char *str, char *substr);\n"
  "static char *str_ltrim (char *s);\n"
  "static char *str_left (char *str, int64_t end);\n"
  "static char *str_new (char *s);\n"
  "static char *str_new_c (char ch);\n"
  "static char *str_replace (char *s, char *old, char *new);\n"
  "static char *str_right (char *str, int64_t begin);\n"
  "static char *str_rtrim (char *s);\n"
  "static Arrs *str_split (char *s, char *sep);\n"
  "static Arrs *str_split_trim (char *s, char *sep);\n"
  "static int str_starts (char *str, char  *substr);\n"
  "static char *str_sub (char *str, int64_t begin, int64_t end);\n"
  "static char *str_to_escape (char *str);\n"
  "static char *str_to_lower (char *s);\n"
  "static Arrs *str_to_runes (char *s);\n"
  "static unsigned *str_to_unicode (char *s);\n"
  "static char *str_to_upper (char *s);\n"
  "static Arri *str_to_utf16 (char *s);\n"
  "static char *str_trim (char *s);\n"
  "static char *str_vf (char *format, va_list args);\n"
  "\n"
  "\n"
  "\n"
"// sys.h ----------\n"
  "static void sys_assert (int value, char *pos);\n"
  "static Arrs *sys_cmd (char *c, Arrs *params);\n"
  "static Arrs *sys_environ(void);\n"
  "static char *sys_get_locale (void);\n"
  "static char *sys_home (void);\n"
  "static void sys_printb (int v);\n"
  "static void sys_printi (int64_t v);\n"
  "static void sys_printf (double v);\n"
  "static void sys_prints (char *v);\n"
  "static void sys_printI (Arri *v);\n"
  "static void sys_printF (Arrf *v);\n"
  "static void sys_printS (Arrs *v);\n"
  "static void sys_printD (Arrs *v);\n"
  "static void sys_print_errorb (int v);\n"
  "static void sys_print_errori (int64_t v);\n"
  "static void sys_print_errorf (double v);\n"
  "static void sys_print_errors (char *v);\n"
  "static void sys_print_errorI (Arri *v);\n"
  "static void sys_print_errorF (Arrf *v);\n"
  "static void sys_print_errorS (Arrs *v);\n"
  "static void sys_print_errorD (Arrs *v);\n"
  "static void sys_printlnb (int v);\n"
  "static void sys_printlni (int64_t v);\n"
  "static void sys_printlnf (double v);\n"
  "static void sys_printlns (char *v);\n"
  "static void sys_printlnI (Arri *v);\n"
  "static void sys_printlnF (Arrf *v);\n"
  "static void sys_printlnS (Arrs *v);\n"
  "static void sys_printlnD (Arrs *v);\n"
  "static char *sys_read_line (void);\n"
  "static void sys_set_locale (char * lang);\n"
  "static void sys_sleep (int64_t millis);\n"
  "static void sys_testb (int v1, int v2, char *pos);\n"
  "static void sys_testi (int64_t v1, int64_t v2, char *pos);\n"
  "static void sys_testf (double v1, double v2, char *pos);\n"
  "static void sys_tests (char *v1, char *v2, char *pos);\n"
  "static void sys_testo (Obj *v1, Obj *v2, char *pos);\n"
  "static void sys_testI (Arri *v1, Arri *v2, char *pos);\n"
  "static void sys_testF (Arrf *v1, Arrf *v2, char *pos);\n"
  "static void sys_testS (Arrs *v1, Arrs *v2, char *pos);\n"
  "static void sys_testD (Arrs *v1, Arrs *v2, char *pos);\n"
  "static void sys_throw (char *fn, char *msg, char *pos);\n"
  "static void sys_used(void);\n"
  "static char *sys_user (void);\n"
  "\n"
"// tarr.h ----------\n"
  "typedef struct tarr_Arri Arri;\n"
  "typedef struct tarr_Arrf Arrf;\n"
  "typedef struct tarr_Arrs Arrs;\n"
  "typedef struct tarr_Arr Arr;\n"
  "\n"
  "static int64_t *tarr_beginI (Arri *this);\n"
  "static double *tarr_beginF (Arrf *this);\n"
  "static char **tarr_beginS (Arrs *this);\n"
  "\n"
  "static void tarr_catI (Arri *this, Arri *other);\n"
  "static void tarr_catF (Arrf *this, Arrf *other);\n"
  "static void tarr_catS (Arrs *this, Arrs *other);\n"
  "\n"
  "static void tarr_clearI (Arri *this);\n"
  "static void tarr_clearF (Arrf *this);\n"
  "static void tarr_clearS (Arrs *this);\n"
  "\n"
  "static Arri *tarr_concatI (Arri *this, Arri *other);\n"
  "static Arrf *tarr_concatF (Arrf *this, Arrf *other);\n"
  "static Arrs *tarr_concatS (Arrs *this, Arrs *other);\n"
  "\n"
  "static int tarr_containsI (Arri *this, int64_t e);\n"
  "static int tarr_containsF (Arrf *this, double e);\n"
  "static int tarr_containsS (Arrs *this, char *e);\n"
  "\n"
  "static Arri *tarr_copyI (Arri *this);\n"
  "static Arrf *tarr_copyF (Arrf *this);\n"
  "static Arrs *tarr_copyS (Arrs *this);\n"
  "\n"
  "static Arri *tarr_dropI (Arri *this, int64_t n);\n"
  "static Arrf *tarr_dropF (Arrf *this, int64_t n);\n"
  "static Arrs *tarr_dropS (Arrs *this, int64_t n);\n"
  "\n"
  "// Removes duplicates from 'this' and returns them.\n"
  "static Arri *tarr_duplicatesI (Arri *this);\n"
  "static Arrf *tarr_duplicatesF (Arrf *this);\n"
  "static Arrs *tarr_duplicatesS (Arrs *this);\n"
  "\n"
  "static int64_t *tarr_endI (Arri *this);\n"
  "static double *tarr_endF (Arrf *this);\n"
  "static char **tarr_endS (Arrs *this);\n"
  "\n"
  "static int tarr_empty (Arr *this);\n"
  "static int tarr_emptyI (Arri *this);\n"
  "static int tarr_emptyF (Arrf *this);\n"
  "static int tarr_emptyS (Arrs *this);\n"
  "\n"
  "static int64_t tarr_getI (Arri *this, int64_t ix);\n"
  "static double tarr_getF (Arrf *this, int64_t ix);\n"
  "static char *tarr_getS (Arrs *this, int64_t ix);\n"
  "\n"
  "static int64_t tarr_indexI (Arri *this, int64_t e);\n"
  "static int64_t tarr_indexF (Arrf *this, double e);\n"
  "static int64_t tarr_indexS (Arrs *this, char *e);\n"
  "\n"
  "static void tarr_insertI (Arri *this, int64_t ix, int64_t e);\n"
  "static void tarr_insertF (Arrf *this, int64_t ix, double e);\n"
  "static void tarr_insertS (Arrs *this, int64_t ix, char *e);\n"
  "\n"
  "static void tarr_insert_arrayI (Arri *this, int64_t ix, Arri *other);\n"
  "static void tarr_insert_arrayF (Arrf *this, int64_t ix, Arrf *other);\n"
  "static void tarr_insert_arrayS (Arrs *this, int64_t ix, Arrs *other);\n"
  "\n"
  "static void tarr_insert_rangeI (\n"
  "  Arri *this, int64_t ix, Arri *other, int64_t begin, int64_t end\n"
  ");\n"
  "static void tarr_insert_rangeF (\n"
  "  Arrf *this, int64_t ix, Arrf *other, int64_t begin, int64_t end\n"
  ");\n"
  "static void tarr_insert_rangeS (\n"
  "  Arrs *this, int64_t ix, Arrs *other, int64_t begin, int64_t end\n"
  ");\n"
  "\n"
  "// Index correction for slices.\n"
  "static int64_t tarr_ix_correctI (Arri *this, int64_t n);\n"
  "static int64_t tarr_ix_correctF (Arrf *this, int64_t n);\n"
  "static int64_t tarr_ix_correctS (Arrs *this, int64_t n);\n"
  "\n"
  "static char *tarr_join (Arrs *this, char *sep);\n"
  "\n"
  "static Arr *tarr_new_ (void);\n"
  "static Arri *tarr_new_i (void);\n"
  "static Arrf *tarr_new_f (void);\n"
  "static Arrs *tarr_new_s (void);\n"
  "\n"
  "static Arri *tarr_new_fromi (int64_t *es, int64_t n);\n"
  "static Arrf *tarr_new_fromf (double *es, int64_t n);\n"
  "static Arrs *tarr_new_froms (char **es, int64_t n);\n"
  "\n"
  "static Arri *tarr_newi (int64_t e, int64_t n);\n"
  "static Arrf *tarr_newf (double e, int64_t n);\n"
  "static Arrs *tarr_news (char *e, int64_t n);\n"
  "\n"
  "static void *tarr_peek (Arr *this);\n"
  "static int64_t tarr_peekI (Arri *this);\n"
  "static double tarr_peekF (Arrf *this);\n"
  "static char *tarr_peekS (Arrs *this);\n"
  "\n"
  "static void *tarr_pop (Arr *this);\n"
  "static int64_t tarr_popI (Arri *this);\n"
  "static double tarr_popF (Arrf *this);\n"
  "static char *tarr_popS (Arrs *this);\n"
  "\n"
  "static void tarr_push (Arr *this, void *e); // Shallow\n"
  "static void tarr_pushI (Arri *this, int64_t e);\n"
  "static void tarr_pushF (Arrf *this, double e);\n"
  "static void tarr_pushS (Arrs *this, char *e);\n"
  "\n"
  "static int64_t tarr_removeI (Arri *this, int64_t ix);\n"
  "static double tarr_removeF (Arrf *this, int64_t ix);\n"
  "static char *tarr_removeS (Arrs *this, int64_t ix);\n"
  "\n"
  "static Arri *tarr_remove_rangeI (Arri *this, int64_t begin, int64_t end);\n"
  "static Arrf *tarr_remove_rangeF (Arrf *this, int64_t begin, int64_t end);\n"
  "static Arrs *tarr_remove_rangeS (Arrs *this, int64_t begin, int64_t end);\n"
  "\n"
  "static Arri *tarr_reverseI (Arri *this);\n"
  "static Arrf *tarr_reverseF (Arrf *this);\n"
  "static Arrs *tarr_reverseS (Arrs *this);\n"
  "\n"
  "static void tarr_reverse_inI (Arri *this);\n"
  "static void tarr_reverse_inF (Arrf *this);\n"
  "static void tarr_reverse_inS (Arrs *this);\n"
  "\n"
  "static void tarr_setI (Arri *this, int64_t ix, int64_t e);\n"
  "static void tarr_setF (Arrf *this, int64_t ix, double e);\n"
  "static void tarr_setS (Arrs *this, int64_t ix, char *e);\n"
  "\n"
  "static void tarr_set_arrayI (Arri *this, int64_t ix, Arri *other);\n"
  "static void tarr_set_arrayF (Arrf *this, int64_t ix, Arrf *other);\n"
  "static void tarr_set_arrayS (Arrs *this, int64_t ix, Arrs *other);\n"
  "\n"
  "static void tarr_set_rangeI (\n"
  "  Arri *this, int64_t ix, Arri *other, int64_t begin, int64_t end\n"
  ");\n"
  "static void tarr_set_rangeF (\n"
  "  Arrf *this, int64_t ix, Arrf *other, int64_t begin, int64_t end\n"
  ");\n"
  "static void tarr_set_rangeS (\n"
  "  Arrs *this, int64_t ix, Arrs *other, int64_t begin, int64_t end\n"
  ");\n"
  "\n"
  "static int64_t tarr_shiftI (Arri *this);\n"
  "static double tarr_shiftF (Arrf *this);\n"
  "static char *tarr_shiftS (Arrs *this);\n"
  "\n"
  "static void tarr_shuffleI (Arri *this);\n"
  "static void tarr_shuffleF (Arrf *this);\n"
  "static void tarr_shuffleS (Arrs *this);\n"
  "\n"
  "static int tarr_sizeI (Arri *this);\n"
  "static int tarr_sizeF (Arrf *this);\n"
  "static int tarr_sizeS (Arrs *this);\n"
  "\n"
  "static void tarr_sortI (Arri *this, int is_ascendant);\n"
  "static void tarr_sortF (Arrf *this, int is_ascendant);\n"
  "static void tarr_sortS (Arrs *this, int is_ascendant);\n"
  "\n"
  "static Arri *tarr_takeI (Arri *this, int64_t n);\n"
  "static Arrf *tarr_takeF (Arrf *this, int64_t n);\n"
  "static Arrs *tarr_takeS (Arrs *this, int64_t n);\n"
  "\n"
  "static void tarr_unshiftI (Arri *this, int64_t e);\n"
  "static void tarr_unshiftF (Arrf *this, double e);\n"
  "static void tarr_unshiftS (Arrs *this, char *e);\n"
  "\n"
"// texc.h ----------\n"
  "static void texc_add(jmp_buf *jump);\n"
  "static void texc_remove();\n"
  "static char *texc_get();\n"
  "\n"
  "static void texc_throw_(char *message);\n"
  "static void texc_throw(char *function, char *message);\n"
  "static void texc_expect (\n"
  "  char *function, char *message, char *actual, char *expected);\n"
  "// begin inclusive, end exclusive.\n"
  "static void texc_check_range (char *function, int begin, int end, int index);\n"
  "static void texc_check_type (char *function, Obj *o, char *type);\n"
  "\n"
"// time.h ----------\n"
  "static char *_time_fmt (int64_t tm, char *template);\n"
  "static int64_t time_add_days (int64_t this, int64_t days);\n"
  "static int64_t time_day (int64_t this);\n"
  "static int time_day_light_correction (int day, int month, int year);\n"
  "static int64_t time_df_day (int64_t this, int64_t other);\n"
  "static int time_eq_day (int64_t this, int64_t other);\n"
  "static char *time_fmt (int64_t this, char *template);\n"
  "static Arri *time_from_clock (int64_t this, char *tms);\n"
  "static Arri *time_from_en (char *date, char *sep);\n"
  "static Arri *time_from_iso (char *date, char *sep);\n"
  "static Arri *time_from_iso_en_aux (int is_iso, char *date, char sep);\n"
  "static Arri *time_from_str(char *date);\n"
  "static int64_t time_from_time (time_t tm);\n"
  "static int64_t time_hour (int64_t this);\n"
  "static int64_t time_millisecond (int64_t this);\n"
  "static int64_t time_minute (int64_t this);\n"
  "static int64_t time_month (int64_t this);\n"
  "static int64_t time_new (int day, int month, int year);\n"
  "static int64_t time_new_time (\n"
  "  int day, int month, int year, int hour, int minute, int second\n"
  ");\n"
  "static int64_t time_now(void);\n"
  "static int64_t time_second (int64_t this);\n"
  "static char *time_to_en (int64_t this);\n"
  "static char *time_to_iso (int64_t this);\n"
  "static char *time_to_str (int64_t this);\n"
  "static time_t time_to_time (int64_t this);\n"
  "static int64_t time_weekday (int64_t this);\n"
  "static int64_t time_year (int64_t this);\n"
  "static int64_t time_year_day (int64_t this);\n"
  "\n"
"// ttype.h ----------\n"
  "/// Kut typed types.\n"
  "typedef enum ttype_Ttype {\n"
  "    ttype_BOOL, ttype_INT, ttype_FLOAT, ttype_STRING, ttype_OBJECT,\n"
  "    ttype_AINT, ttype_AFLOAT, ttype_ASTRING, ttype_DIC,\n"
  "    ttype_NO_RETURN, ttype_ERROR\n"
  "  } Ttype;\n"
  "\n"
"// tval.h ----------\n"
  "// Kut Typed value\n"
  "typedef union tval_Tval Tval;\n"
  "\n"
;

/// Body.
char *builtIn_body =
  "// 0base.c ----------\n"
  "// Tmp\n"
  "\n"
  "void __attribute__ ((constructor)) initLibrary(void) {\n"
  "}\n"
  "void __attribute__ ((destructor)) cleanUpLibrary(void) {\n"
  "}\n"
  "\n"
  "static void (*built_exc_fns) (char, void *) = NULL;\n"
  "void built_set_exc(void (*fn)(char, void *)) { // C-Kut connector!!!\n"
  "  built_exc_fns = fn;\n"
  "}\n"
  "\n"
  "static int built_eqb (int v1, int v2) {\n"
  "  return v1 == v2;\n"
  "}\n"
  "static int built_eqi (int64_t v1, int64_t v2) {\n"
  "  return v1 == v2;\n"
  "}\n"
  "static int built_eqf (double v1, double v2) {\n"
  "  return math_eq(v1, v2);\n"
  "}\n"
  "static int built_eqs (char *v1, char *v2) {\n"
  "  return !strcmp(v1, v2);\n"
  "}\n"
  "static int built_eqo (Obj *v1, Obj *v2) {\n"
  "  return v1->value == v2->value;\n"
  "}\n"
  "#define built_EQ(T, BEGIN, END) \\\n"
  "  T *p = BEGIN(v1); \\\n"
  "  T *end = END(v1); \\\n"
  "  T *p2 = BEGIN(v2); \\\n"
  "  if (end - p != END(v2) - p2) return 0;\n"
  "static int built_eqI (Arri *v1, Arri *v2) {\n"
  "  built_EQ(int64_t, tarr_beginI, tarr_endI);\n"
  "  while (p < end) if (*p++ != *p2++) return 0;\n"
  "  return 1;\n"
  "}\n"
  "static int built_eqF (Arrf *v1, Arrf *v2) {\n"
  "  built_EQ(double, tarr_beginF, tarr_endF);\n"
  "  while (p < end) if (!math_eq(*p++, *p2++)) return 0;\n"
  "  return 1;\n"
  "}\n"
  "static int built_eqS (Arrs *v1, Arrs *v2) {\n"
  "  built_EQ(char*, tarr_beginS, tarr_endS);\n"
  "  while (p < end) if (strcmp(*p++, *p2++)) return 0;\n"
  "  return 1;\n"
  "}\n"
  "static int built_eqD (Arrs *v1, Arrs *v2) {\n"
  "  built_EQ(char*, tarr_beginS, tarr_endS);\n"
  "  while (p < end) {\n"
  "    char *k = *p++;\n"
  "    char *val = *p++;\n"
  "    char *val2 = dic_get_or_null(v2, k);\n"
  "    if (!val2 || strcmp(val, val2)) return 0;\n"
  "  }\n"
  "  return 1;\n"
  "}\n"
  "#undef built_EQ\n"
  "static int built_neqb (int v1, int v2) {\n"
  "  return v1 != v2;\n"
  "}\n"
  "static int built_neqi (int64_t v1, int64_t v2) {\n"
  "  return v1 != v2;\n"
  "}\n"
  "static int built_neqf (double v1, double v2) {\n"
  "  return !math_eq(v1, v2);\n"
  "}\n"
  "static int built_neqs (char *v1, char *v2) {\n"
  "  return strcmp(v1, v2);\n"
  "}\n"
  "static int built_neqo (Obj *v1, Obj *v2) {\n"
  "  return v1->value != v2->value;\n"
  "}\n"
  "#define built_NEQ(T, BEGIN, END) \\\n"
  "  T *p = BEGIN(v1); \\\n"
  "  T *end = END(v1); \\\n"
  "  T *p2 = BEGIN(v2); \\\n"
  "  if (end - p != END(v2) - p2) return 1;\n"
  "static int built_neqI (Arri *v1, Arri *v2) {\n"
  "  built_NEQ(int64_t, tarr_beginI, tarr_endI);\n"
  "  while (p < end) if (*p++ != *p2++) return 1;\n"
  "  return 0;\n"
  "}\n"
  "static int built_neqF (Arrf *v1, Arrf *v2) {\n"
  "  built_NEQ(double, tarr_beginF, tarr_endF);\n"
  "  while (p < end) if (!math_eq(*p++, *p2++)) return 1;\n"
  "  return 0;\n"
  "}\n"
  "static int built_neqS (Arrs *v1, Arrs *v2) {\n"
  "  built_NEQ(char*, tarr_beginS, tarr_endS);\n"
  "  while (p < end) if (strcmp(*p++, *p2++)) return 1;\n"
  "  return 0;\n"
  "}\n"
  "static int built_neqD (Arrs *v1, Arrs *v2) {\n"
  "  built_NEQ(char*, tarr_beginS, tarr_endS);\n"
  "  while (p < end) {\n"
  "    char *k = *p++;\n"
  "    char *val = *p++;\n"
  "    char *val2 = dic_get_or_null(v2, k);\n"
  "    if (!val2 || strcmp(val, val2)) return 1;\n"
  "  }\n"
  "  return 0;\n"
  "}\n"
  "#undef built_NEQ\n"
  "static char *built_to_strb (int v) {\n"
  "  return v ? \"true\" : \"false\";\n"
  "}\n"
  "static char *built_to_stri (int64_t v) {\n"
  "  return math_itos(v);\n"
  "}\n"
  "static char *built_to_strf (double s) {\n"
  "  return math_ftos(s);\n"
  "}\n"
  "static char *built_to_strs (char *s) {\n"
  "  return str_new(s);\n"
  "}\n"
  "static char *built_to_stro (Obj *o) {\n"
  "  return str_f(\"Obj<%s>%ld\", o->type, (int64_t)o->value);\n"
  "}\n"
  "static char *built_to_strI (Arri *a) {\n"
  "  Arrs *r = tarr_new_s();\n"
  "  int64_t *p = tarr_beginI(a);\n"
  "  int64_t *end = tarr_endI(a);\n"
  "  while (p < end) tarr_pushS(r, math_itos(*p++));\n"
  "  char *rs = js_wa(r);\n"
  "  return rs;\n"
  "}\n"
  "static char *built_to_strF (Arrf *a) {\n"
  "  Arrs *r = tarr_new_s();\n"
  "  double *p = tarr_beginF(a);\n"
  "  double *end = tarr_endF(a);\n"
  "  while (p < end) tarr_pushS(r, math_ftos(*p++));\n"
  "  char *rs = js_wa(r);\n"
  "  return rs;\n"
  "}\n"
  "static char *built_to_strS (Arrs *a) {\n"
  "  Arrs *r = tarr_new_s();\n"
  "  char **p = tarr_beginS(a);\n"
  "  char **end = tarr_endS(a);\n"
  "  while (p < end) tarr_pushS(r, js_ws(*p++));\n"
  "  char *rs = js_wa(r);\n"
  "  return rs;\n"
  "}\n"
  "static char *built_to_strD (Arrs *m) {\n"
  "  Arrs *r = tarr_new_s();\n"
  "  char **p = tarr_beginS(m);\n"
  "  char **end = tarr_endS(m);\n"
  "  while (p < end) {\n"
  "    tarr_pushS(r, *p++);\n"
  "    tarr_pushS(r, js_ws(*p++));\n"
  "  }\n"
  "  char *rs = js_wo(r);\n"
  "  return rs;\n"
  "}\n"
  "static void built_trace(int is_full, char *position, char *exp) {\n"
  "  printf(\"%s \", position);\n"
  "  puts(exp);\n"
  "}\n"
  "\n"
"// b64.c ----------\n"
  "static const unsigned char decoding_table[256] = {\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,\n"
  "  52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,\n"
  "  64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,\n"
  "  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,\n"
  "  64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n"
  "  41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,\n"
  "  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64\n"
  "};\n"
  "static int mod_table[] = {0, 2, 1};\n"
  "static char *base64_encode(\n"
  "  unsigned char *data,\n"
  "  size_t input_length,\n"
  "  size_t *output_length\n"
  ") {\n"
  "  *output_length = 4 * ((input_length + 2) / 3);\n"
  "  char *encoded_data = ATOMIC(*output_length + 1);\n"
  "  for (int i = 0, j = 0; i < input_length;) {\n"
  "    uint32_t octet_a = i < input_length ? (unsigned char)data[i++] : 0;\n"
  "    uint32_t octet_b = i < input_length ? (unsigned char)data[i++] : 0;\n"
  "    uint32_t octet_c = i < input_length ? (unsigned char)data[i++] : 0;\n"
  "    uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;\n"
  "    encoded_data[j++] = b64_table[(triple >> 3 * 6) & 0x3F];\n"
  "    encoded_data[j++] = b64_table[(triple >> 2 * 6) & 0x3F];\n"
  "    encoded_data[j++] = b64_table[(triple >> 1 * 6) & 0x3F];\n"
  "    encoded_data[j++] = b64_table[(triple >> 0 * 6) & 0x3F];\n"
  "  }\n"
  "  for (int i = 0; i < mod_table[input_length % 3]; i++) {\n"
  "    encoded_data[*output_length - 1 - i] = '=';\n"
  "  }\n"
  "  *(encoded_data + *output_length) = 0;\n"
  "  return encoded_data;\n"
  "}\n"
  "// Only for positive input_length\n"
  "static Bytes *base64_decode(\n"
  "  const char *data,\n"
  "  size_t input_length,\n"
  "  size_t *output_length\n"
  ") {\n"
  "  if (input_length % 4 != 0)\n"
  "    texc_expect(\"b64.decode\",\n"
  "      \"Bad B64 string\", str_f(\"Length %ld\", input_length), \"Length % 4 != 0\"\n"
  "    );\n"
  "  *output_length = input_length / 4 * 3;\n"
  "  if (data[input_length - 1] == '=') (*output_length)--;\n"
  "  if (data[input_length - 2] == '=') (*output_length)--;\n"
  "  Bytes *bs = bytes_new(*output_length)->value;\n"
  "  unsigned char *decoded_data = bs->bs;\n"
  "  for (int i = 0, j = 0; i < input_length;) {\n"
  "    uint32_t sextet_a = data[i] == '='\n"
  "      ? 0 & i++\n"
  "      : decoding_table[(int)data[i++]];\n"
  "    uint32_t sextet_b = data[i] == '='\n"
  "      ? 0 & i++\n"
  "      : decoding_table[(int)data[i++]];\n"
  "    uint32_t sextet_c = data[i] == '='\n"
  "      ? 0 & i++\n"
  "      : decoding_table[(int)data[i++]];\n"
  "    uint32_t sextet_d = data[i] == '='\n"
  "      ? 0 & i++\n"
  "      : decoding_table[(int)data[i++]];\n"
  "    uint32_t triple = (sextet_a << 3 * 6) +\n"
  "      (sextet_b << 2 * 6) +\n"
  "      (sextet_c << 1 * 6) +\n"
  "      (sextet_d << 0 * 6);\n"
  "    if (j < *output_length) {\n"
  "      decoded_data[j++] = (triple >> 2 * 8) & 0xFF;\n"
  "    }\n"
  "    if (j < *output_length) {\n"
  "      decoded_data[j++] = (triple >> 1 * 8) & 0xFF;\n"
  "    }\n"
  "    if (j < *output_length) {\n"
  "      decoded_data[j++] = (triple >> 0 * 8) & 0xFF;\n"
  "    }\n"
  "  }\n"
  "  return bs;\n"
  "}\n"
  "static char *b64_decode(char *b64) {\n"
  "  Obj *obs = b64_decode_bytes(b64);\n"
  "  Bytes *bs = obs->value;\n"
  "  int64_t len = bs->length;\n"
  "  char *s = ATOMIC(len + 1);\n"
  "  memcpy(s, bs->bs, len);\n"
  "  *(s + len) = 0;\n"
  "  return s;\n"
  "}\n"
  "static Obj *b64_decode_bytes(char *b64) {\n"
  "  if (*b64) {\n"
  "    size_t len;\n"
  "    return obj_new(\"<bytes>\", base64_decode(b64, strlen(b64), &len));\n"
  "  } else {\n"
  "    return bytes_new(0);\n"
  "  }\n"
  "}\n"
  "static char *b64_encode(char *s) {\n"
  "  size_t len;\n"
  "  return base64_encode((unsigned char *)s, strlen(s), &len);\n"
  "}\n"
  "static char *b64_encode_bytes(Obj *obs) {\n"
  "  texc_check_type(\"b64.encode\", obs, \"<bytes>\");\n"
  "  Bytes *bs = obs->value;\n"
  "  size_t len;\n"
  "  return base64_encode(bs->bs, bs->length, &len);\n"
  "}\n"
  "\n"
"// buf.c ----------\n"
  "struct buf_Buf{\n"
  "  char *str;\n"
  "  int len;\n"
  "  int bf_size;\n"
  "};\n"
  "\n"
  "static Buf *buf_new () {\n"
  "  return buf_new_bf(151);\n"
  "}\n"
  "static Buf *buf_new_bf (int buffer_size) {\n"
  "  Buf *this = MALLOC(Buf);\n"
  "  this->bf_size = buffer_size - 1;\n"
  "  this->str = ATOMIC(buffer_size);\n"
  "  memset(this->str, 0, buffer_size);\n"
  "  this->len = 0;\n"
  "  return this;\n"
  "}\n"
  "static char *buf_str (Buf *this) {\n"
  "  return this->str;\n"
  "}\n"
  "static int buf_len (Buf *this) {\n"
  "  return this->len;\n"
  "}\n"
  "static void buf_add_buf (Buf *this, char *data, int length) {\n"
  "  int ixend = this->len + length;\n"
  "  if (this->bf_size < ixend) {\n"
  "      while (this->bf_size < ixend) this->bf_size += this->bf_size;\n"
  "      int memsize = this->bf_size + 1;\n"
  "      this->str = GC_REALLOC(this->str, memsize);\n"
  "      memset(this->str + this->len, 0, memsize - this->len);\n"
  "  }\n"
  "  memcpy(this->str + this->len, data, length);\n"
  "  this->len = ixend;\n"
  "}\n"
  "static void buf_add (Buf *this, char *data) {\n"
  "  buf_add_buf(this, data, strlen(data));\n"
  "}\n"
  "static void buf_cadd (Buf *this, char data) {\n"
  "  buf_add_buf(this, &data, 1);\n"
  "}\n"
  "static void buf_reset(Buf *this) {\n"
  "  memset(this->str, 0, this->len);\n"
  "  this->len = 0;\n"
  "}\n"
  "\n"
"// bytes.c ----------\n"
  "static Obj *bytes_add (Obj *othis, Obj *oother) {\n"
  "  texc_check_type(\"bytes.add\", othis, \"<bytes>\");\n"
  "  texc_check_type(\"bytes.add\", oother, \"<bytes>\");\n"
  "  Bytes *this = othis->value;\n"
  "  Bytes *other = oother->value;\n"
  "  int length = other->length;\n"
  "  if (length) {\n"
  "    int sum = this->length + length;\n"
  "    this->bs = GC_REALLOC(this->bs, sum);\n"
  "    memcpy(this->bs + this->length, other->bs, length);\n"
  "    this->length = sum;\n"
  "  }\n"
  "  return obj_new(\"<bytes>\", this);\n"
  "}\n"
  "static Obj *bytes_drop (Obj *othis, int64_t n) {\n"
  "  texc_check_type(\"bytes.drop\", othis, \"<bytes>\");\n"
  "  Bytes *this = othis->value;\n"
  "  int64_t sz = this->length;\n"
  "  if (n >= sz) return bytes_new(0);\n"
  "  if (n < 0) n = 0;\n"
  "  sz = sz - n;\n"
  "  Obj *onew = bytes_new(sz);\n"
  "  Bytes *new = onew->value;\n"
  "  memcpy(new->bs, this->bs + n, sz);\n"
  "  return onew;\n"
  "}\n"
  "static Obj *bytes_from_arr (Arri *a) {\n"
  "  int64_t *p = tarr_beginI(a);\n"
  "  int64_t *end = tarr_endI(a);\n"
  "  Obj *othis = bytes_new(end - p);\n"
  "  Bytes *this = othis->value;\n"
  "  unsigned char *bs = this->bs;\n"
  "  while (p < end) *bs++ = (unsigned char)*p++;\n"
  "  return othis;\n"
  "}\n"
  "static Obj *bytes_from_bytes(unsigned char *bs, int length) {\n"
  "  Bytes *this = MALLOC(Bytes);\n"
  "  this->bs = ATOMIC(length);\n"
  "  memcpy(this->bs, bs, length);\n"
  "  this->length = length;\n"
  "  return obj_new(\"<bytes>\", this);\n"
  "}\n"
  "static Obj *bytes_from_str (char *s) {\n"
  "  Obj *othis = bytes_new(strlen(s));\n"
  "  Bytes *this = othis->value;\n"
  "  unsigned char *bs = this->bs;\n"
  "  while (*s) *bs++ = (unsigned char)*s++;\n"
  "  return othis;\n"
  "}\n"
  "static int64_t bytes_get (Obj *othis, int64_t ix) {\n"
  "  texc_check_type(\"bytes.get\", othis, \"<bytes>\");\n"
  "  Bytes *this = othis->value;\n"
  "  texc_check_range(\"bytes.get\", 0, this->length - 1, ix);\n"
  "  return this->bs[ix];\n"
  "}\n"
  "static Obj *bytes_new (int64_t length) {\n"
  "  Bytes *this = MALLOC(Bytes);\n"
  "  this->bs = ATOMIC(length);\n"
  "  memset(this->bs, 0, length);\n"
  "  this->length = length;\n"
  "  return obj_new(\"<bytes>\", this);\n"
  "}\n"
  "static void bytes_set (Obj *othis, int64_t ix, int64_t v) {\n"
  "  texc_check_type(\"bytes.get\", othis, \"<bytes>\");\n"
  "  Bytes *this = othis->value;\n"
  "  texc_check_range(\"bytes.get\", 0, this->length - 1, ix);\n"
  "  this->bs[ix] = (unsigned char) v;\n"
  "}\n"
  "static int64_t bytes_size (Obj *othis) {\n"
  "  texc_check_type(\"bytes.get\", othis, \"<bytes>\");\n"
  "  Bytes *this = othis->value;\n"
  "  return this->length;\n"
  "}\n"
  "static Obj *bytes_take (Obj *othis, int64_t n) {\n"
  "  texc_check_type(\"bytes.take\", othis, \"<bytes>\");\n"
  "  Bytes *this = othis->value;\n"
  "  if (n <= 0) return bytes_new(0);\n"
  "  int64_t sz = this->length;\n"
  "  if (n > sz) n = sz;\n"
  "  Obj *onew = bytes_new(n);\n"
  "  Bytes *new = onew->value;\n"
  "  memcpy(new->bs, this->bs, n);\n"
  "  return onew;\n"
  "}\n"
  "static Arri *bytes_to_arr (Obj *othis) {\n"
  "  texc_check_type(\"bytes.toArr\", othis, \"<bytes>\");\n"
  "  Bytes *this = othis->value;\n"
  "  Arri *a = tarr_newi(0, this->length);\n"
  "  int64_t *p = tarr_beginI(a);\n"
  "  int64_t *end = tarr_endI(a);\n"
  "  unsigned char *bs = this->bs;\n"
  "  while (p < end) *p++ = *bs++;\n"
  "  return a;\n"
  "\n"
  "}\n"
  "static char *bytes_to_str (Obj *othis) {\n"
  "  texc_check_type(\"bytes.toStr\", othis, \"<bytes>\");\n"
  "  Bytes *this = othis->value;\n"
  "  Buf *b = buf_new_bf(this->length + 1);\n"
  "  unsigned char *p = this->bs;\n"
  "  unsigned char *end = this->bs + this->length;\n"
  "  while (p < end) buf_cadd(b, *p++);\n"
  "  return str_new(buf_str(b));\n"
  "}\n"
  "\n"
"// cryp.c ----------\n"
  "static char *cryp_genk (int lg) {\n"
  "  if (lg <= 0)\n"
  "    texc_expect(\"cryp.genK\",\n"
  "      \"Value out of range\", str_f(\"%d\", lg), \"Value < 0\");\n"
  "\n"
  "  char *r = ATOMIC(lg + 1);\n"
  "  char *p = r + lg;\n"
  "  *p-- = 0;\n"
  "  while (lg--) {\n"
  "    *p-- = *(b64_table + math_rndi(64));\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "static char *cryp_key (char *key, int lg) {\n"
  "  if (!*key)\n"
  "    texc_expect(\"cryp.key\", \"Wrong key\", \"\\\"\\\"\", \"Value != \\\"\\\"\");\n"
  "\n"
  "  char *k0 = str_f(\n"
  "    \"%scodified in irreversibleDeme is good, very good!\\n\\r8@@\", key);\n"
  "  char *b64 = b64_encode(k0);\n"
  "  Bytes *k = b64_decode_bytes(b64)->value;\n"
  "\n"
  "  unsigned char *ka = k->bs;\n"
  "  size_t lenk = k->length;\n"
  "  unsigned char sum = 0;\n"
  "  unsigned char *p = ka;\n"
  "  for (int i = 0; i < lenk; ++i) sum += *p++;\n"
  "\n"
  "  size_t lg2 = lg + lenk;\n"
  "  Bytes *rbs = bytes_new(lg2)->value;\n"
  "  unsigned char *ra = rbs->bs;\n"
  "  Bytes *rbs1 = bytes_new(lg2)->value;\n"
  "  unsigned char *ra1 = rbs1->bs;\n"
  "  Bytes *rbs2 = bytes_new(lg2)->value;\n"
  "  unsigned char *ra2 = rbs2->bs;\n"
  "\n"
  "  size_t ik = 0;\n"
  "  size_t v1, v2, v3, v4;\n"
  "  for (size_t i = 0; i < lg2; ++i) {\n"
  "    v1 = ka[ik];\n"
  "    v2 = v1 + ka[v1 % lenk];\n"
  "    v3 = v2 + ka[v2 % lenk];\n"
  "    v4 = v3 + ka[v3 % lenk];\n"
  "    sum = sum + i + v4;\n"
  "    ra1[i] = sum;\n"
  "    ra2[i] = sum;\n"
  "    ++ik;\n"
  "    if (ik == lenk) {\n"
  "      ik = 0;\n"
  "    }\n"
  "  }\n"
  "\n"
  "  for (size_t i = 0; i < lg2; ++i) {\n"
  "    v1 = ra2[i];\n"
  "    v2 = v1 + ra2[v1 % lg2];\n"
  "    v3 = v2 + ra2[v2 % lg2];\n"
  "    v4 = v3 + ra2[v3 % lg2];\n"
  "    sum = sum + v4;\n"
  "    ra2[i] = sum;\n"
  "    ra[i] = sum + ra1[i];\n"
  "  }\n"
  "\n"
  "  Obj *orbs = obj_new(\"<bytes>\", rbs);\n"
  "  return str_left(b64_encode_bytes(orbs), lg);\n"
  "}\n"
  "static char *cryp_encode (char *k, char *s) {\n"
  "  if (!*k)\n"
  "    texc_expect(\"cryp.encode\", \"Wrong key\", \"\\\"\\\"\", \"Value != \\\"\\\"\");\n"
  "\n"
  "  char *b64 = b64_encode(s);\n"
  "\n"
  "  size_t lg = strlen(b64);\n"
  "  char *k2 = cryp_key(k, lg);\n"
  "\n"
  "  Bytes *rbs = bytes_new(lg)->value;\n"
  "\n"
  "  unsigned char *prbs = rbs->bs;\n"
  "  unsigned char *pk2 = (unsigned char *)k2;\n"
  "  unsigned char *pb64 = (unsigned char *)b64;\n"
  "  for(int i = 0; i < lg; ++i) *prbs++ = (*pk2++) + (*pb64++);\n"
  "\n"
  "  Obj *orbs = obj_new(\"<bytes>\", rbs);\n"
  "  return b64_encode_bytes(orbs);\n"
  "}\n"
  "static char *cryp_decode (char *k, char *c) {\n"
  "  if (!*k)\n"
  "    texc_expect(\"cryp.decode\", \"Wrong key\", \"\\\"\\\"\", \"Value != \\\"\\\"\");\n"
  "\n"
  "  Bytes *bs = b64_decode_bytes(c)->value;\n"
  "\n"
  "  size_t lg = bs->length;\n"
  "  char *k2 = cryp_key(k, lg);\n"
  "\n"
  "  char *b64 = ATOMIC(lg + 1);\n"
  "\n"
  "  unsigned char *pbs = bs->bs;\n"
  "  unsigned char *pk2 = (unsigned char *)k2;\n"
  "  char *pb64 = b64;\n"
  "  for(int i = 0; i < lg; ++i) *pb64++ = *pbs++ - *pk2++;\n"
  "  *pb64 = 0;\n"
  "\n"
  "  return b64_decode(b64);\n"
  "}\n"
  "\n"
"// dic.c ----------\n"
  "static void dic_add(Arrs *this, char *key, char *value) {\n"
  "  int exists = 0;\n"
  "  char **p = tarr_beginS(this);\n"
  "  char **end = tarr_endS(this);\n"
  "  while (p < end)\n"
  "    if (!strcmp(*p++, key)) { exists = 1; break; }\n"
  "    else ++p;\n"
  "  if (exists)\n"
  "    texc_expect(\"dic.add\",\n"
  "      str_f(\"Fail adding the key '%s'\", key),\n"
  "      \"A new key\", \"Key is duplicate\"\n"
  "    );\n"
  "  tarr_pushS(this, key);\n"
  "  tarr_pushS(this, value);\n"
  "}\n"
  "static Arrs *dic_from_arr (Arrs *a) {\n"
  "  if (tarr_sizeS(a) % 2)\n"
  "    texc_throw(\"dic.fromArr\", str_f(\"Array in not a valid dictionary:\\n  %s\",\n"
  "      built_to_strS(a)));\n"
  "  Arrs *r = tarr_new_s();\n"
  "  char **p = tarr_beginS(a);\n"
  "  char **end = tarr_endS(a);\n"
  "  while (p < end) {\n"
  "    char *k = *p++;\n"
  "    char *v = *p++;\n"
  "    dic_put(r, k, v);\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "static Arrs *dic_get(Arrs *this, char *key) {\n"
  "  Arrs *r = tarr_new_s();\n"
  "  char **p = tarr_beginS(this);\n"
  "  char **end = tarr_endS(this);\n"
  "  while (p < end)\n"
  "    if (!strcmp(*p++, key)) { tarr_pushS(r, *p); return r; }\n"
  "    else ++p;\n"
  "  return r;\n"
  "}\n"
  "static char *dic_get_or_exc(Arrs *this, char *key) {\n"
  "  char **p = tarr_beginS(this);\n"
  "  char **end = tarr_endS(this);\n"
  "  while (p < end)\n"
  "    if (!strcmp(*p++, key)) { return *p; }\n"
  "    else ++p;\n"
  "\n"
  "  texc_throw(\"dic.get\", str_f(\"Key '%s' not found\", key));\n"
  "  return NULL; // Unreachable\n"
  "}\n"
  "static char *dic_get_or_null(Arrs *this, char *key) {\n"
  "  char **p = tarr_beginS(this);\n"
  "  char **end = tarr_endS(this);\n"
  "  while (p < end)\n"
  "    if (!strcmp(*p++, key)) { return *p; }\n"
  "    else ++p;\n"
  "  return NULL;\n"
  "}\n"
  "static int dic_has_key(Arrs *this, char *key) {\n"
  "  char **p = tarr_beginS(this);\n"
  "  char **end = tarr_endS(this);\n"
  "  while (p < end)\n"
  "    if (!strcmp(*p++, key)) { return 1; }\n"
  "    else ++p;\n"
  "  return 0;\n"
  "}\n"
  "static Arrs *dic_keys(Arrs *this) {\n"
  "  Arrs *r = tarr_new_s();\n"
  "  char **p = tarr_beginS(this);\n"
  "  char **end = tarr_endS(this);\n"
  "  while (p < end) { tarr_pushS(r, *p++); ++p; }\n"
  "  return r;\n"
  "}\n"
  "static Arrs *dic_new() {\n"
  "  return tarr_new_s();\n"
  "}\n"
  "static void dic_put(Arrs *this, char *key, char *value) {\n"
  "  char **p = tarr_beginS(this);\n"
  "  char **end = tarr_endS(this);\n"
  "  while (p < end)\n"
  "    if (!strcmp(*p++, key)) { *p = value; return; }\n"
  "    else ++p;\n"
  "  tarr_pushS(this, key);\n"
  "  tarr_pushS(this, value);\n"
  "}\n"
  "static void dic_remove(Arrs *this, char *key) {\n"
  "  char **source = tarr_beginS(this);\n"
  "  char **target = source;\n"
  "  char **end = tarr_endS(this);\n"
  "  while (source < end) {\n"
  "    if (!strcmp(*source, key)) { ++source; ++source; }\n"
  "    else {\n"
  "      if (source == target) { ++source; ++source; ++target; ++target; }\n"
  "      else { *target++ = *source++; *target++ = *source++; }\n"
  "    }\n"
  "  }\n"
  "  if (target < source) { tarr_popS(this); tarr_popS(this); }\n"
  "}\n"
  "static void dic_set(Arrs *this, char *key, char *value) {\n"
  "  char **p = tarr_beginS(this);\n"
  "  char **end = tarr_endS(this);\n"
  "  while (p < end)\n"
  "    if (!strcmp(*p++, key)) { *p = value; return; }\n"
  "    else ++p;\n"
  "  texc_expect(\"dic.set\",\n"
  "    str_f(\"Fail changing the value of key '%s'\", key),\n"
  "    \"Key already existing\", \"Key is not found\"\n"
  "  );\n"
  "}\n"
  "static int dic_size(Arrs *this) {\n"
  "  return tarr_sizeS(this) / 2;\n"
  "}\n"
  "static Arrs *dic_values(Arrs *this) {\n"
  "  Arrs *r = tarr_new_s();\n"
  "  char **p = tarr_beginS(this);\n"
  "  char **end = tarr_endS(this);\n"
  "  while (p < end) { ++p; tarr_pushS(r, *p++); }\n"
  "  return r;\n"
  "}\n"
  "\n"
"// file.c ----------\n"
  "typedef struct file_LckFile {\n"
  "  struct flock *lock;\n"
  "  FILE *f;\n"
  "} LckFile;\n"
  "static Obj *file_aopen (char *path) {\n"
  "  FILE *file = fopen(path, \"a\");\n"
  "  if (!file)\n"
  "    texc_throw(\"file.aopen\",\n"
  "      str_f(\"Fail opening '%s': %s\", path, strerror(errno))\n"
  "    );\n"
  "  Obj *r = file_lck_new(file);\n"
  "  LckFile *lf = r->value;\n"
  "  lf->lock->l_type = F_WRLCK;\n"
  "  fcntl (fileno(file), F_SETLKW, lf->lock);\n"
  "  return r;\n"
  "}\n"
  "static char *file_base (char *path) {\n"
  "  path = file_normalize(path);\n"
  "  int ix = str_last_cindex(path, '/');\n"
  "  if (ix != -1) return str_right(path, ix + 1);\n"
  "  return path;\n"
  "}\n"
  "static char *file_canonical (char *path) {\n"
  "  char *tmp = realpath(path, NULL);\n"
  "  if (!tmp)\n"
  "    texc_throw(\"file.canonical\", str_f(\"'%s' can not be canonicalized\", path));\n"
  "  char *r = str_new(tmp);\n"
  "  free(tmp);\n"
  "  return r;\n"
  "}\n"
  "static char *file_cat (Arrs *parts) {\n"
  "  if (tarr_sizeS(parts) == 0) tarr_pushS(parts, \"./\");\n"
  "  else if (!**tarr_beginS(parts)) *tarr_beginS(parts) = \".\"; // First entry == \"\"\n"
  "  return file_clean(tarr_join(parts, \"/\"));\n"
  "}\n"
  "static void file_cd (char *path) {\n"
  "  if (chdir(path)) {\n"
  "    texc_throw(\"file.cd\", str_f(\n"
  "      \"Fail changing the working directory to %s: %s\",\n"
  "      path, strerror(errno)\n"
  "    ));\n"
  "  }\n"
  "}\n"
  "static char *file_clean (char *path) {\n"
  "  char *s = str_trim(path);\n"
  "  if (!*s) return \"\";\n"
  "  Buf *bf = buf_new();\n"
  "  int isSlash = 0;\n"
  "  while (*s) {\n"
  "    char ch = *s++;\n"
  "    if (ch == '/') {\n"
  "      if (isSlash) continue;\n"
  "      isSlash = 1;\n"
  "      buf_cadd(bf, ch);\n"
  "      continue;\n"
  "    }\n"
  "    isSlash = 0;\n"
  "    buf_cadd(bf, ch);\n"
  "  }\n"
  "  s = buf_str(bf);\n"
  "  if (!s[1]) return s;\n"
  "  if (str_ends(s, \"/\")) s = str_left(s, -1);\n"
  "  Arrs *new = tarr_new_s();\n"
  "  Arrs *ps = str_csplit(s, '/');\n"
  "  char **p = tarr_beginS(ps);\n"
  "  char **end = tarr_endS(ps);\n"
  "  while (p < end) {\n"
  "    char *part = *p++;\n"
  "    if (!strcmp(part, \".\")) continue;\n"
  "    if (!strcmp(part, \"..\")) {\n"
  "      if (tarr_sizeS(new)) tarr_popS(new);\n"
  "      else texc_throw(\"file.clean\", str_f(\"Bad path for cleaning '%s'\", path));\n"
  "      continue;\n"
  "    }\n"
  "    tarr_pushS(new, part);\n"
  "  }\n"
  "  s = tarr_join(new, \"/\");\n"
  "  if (!*s && *path == '/')\n"
  "    texc_throw(\"file.clean\", str_f(\"Bad path for cleaning '%s'\", path));\n"
  "  return s;\n"
  "}\n"
  "static void file_close (Obj *file) {\n"
  "  texc_check_type(\"file.close\", file, \"<file>\");\n"
  "  LckFile *lck = file->value;\n"
  "  FILE *fl = lck->f;\n"
  "  struct flock *lock = lck->lock;\n"
  "  lock->l_type = F_UNLCK;\n"
  "  fcntl (fileno(fl), F_SETLK, &lock);\n"
  "  fclose(fl);\n"
  "}\n"
  "static void file_copy (char *source, char *target) {\n"
  "  void fcopy (char *source , char *file) {\n"
  "  if (!strcmp(source, target)) return;\n"
  "    FILE *f1;\n"
  "    FILE *f2;\n"
  "    char  buffer[32678];\n"
  "    size_t  n;\n"
  "    if ((f1 = fopen(source, \"rb\")) == 0)\n"
  "      texc_throw(\"file.copy\",\n"
  "        str_f(\"Fail openning '%s': %s\", source, strerror(errno))\n"
  "      );\n"
  "    if ((f2 = fopen(target, \"wb\")) == 0)\n"
  "      texc_throw(\"file.copy\",\n"
  "        str_f(\"Fail openning '%s': %s\", target, strerror(errno))\n"
  "      );\n"
  "    while ((n = fread(buffer, sizeof(char), sizeof(buffer), f1)) > 0) {\n"
  "      if (fwrite(buffer, sizeof(char), n, f2) != n)\n"
  "        texc_throw(\"file.copy\",\n"
  "          str_f(\"Fail writing '%s': %s\", target, strerror(errno))\n"
  "        );\n"
  "    }\n"
  "    fclose(f1);\n"
  "    fclose(f2);\n"
  "  }\n"
  "  if (file_is_directory(source)) {\n"
  "    if (!file_is_directory(target))\n"
  "      texc_throw(\"file.copy\", str_f(\"'%s' is not a directory\", target));\n"
  "    char *tdir = str_f(\"%s/%s\", target, file_base(source));\n"
  "    file_del(tdir);\n"
  "    file_mkdir(tdir);\n"
  "    Arrs *dir = file_dir(source);\n"
  "    char **p = tarr_beginS(dir);\n"
  "    char **end = tarr_endS(dir);\n"
  "    while (p < end) file_copy(str_f(\"%s/%s\", source, *p++), tdir);\n"
  "    return;\n"
  "  }\n"
  "  if (file_is_directory(target))\n"
  "    target = str_f(\"%s/%s\", target, file_base(source));\n"
  "  fcopy(source, target);\n"
  "}\n"
  "static void file_del (char *path) {\n"
  "  struct stat buf;\n"
  "  if (stat(path, &buf) && errno != ENOENT)\n"
  "      texc_throw(\"file.del\",\n"
  "        str_f(\"Fail deleting %s: %s\", path, strerror(errno))\n"
  "      );\n"
  "  if (S_ISDIR(buf.st_mode)) {\n"
  "    Arrs *names = file_dir(path);\n"
  "    char **p = tarr_beginS(names);\n"
  "    char **end = tarr_endS(names);\n"
  "    while (p < end)\n"
  "      file_del(str_f(\"%s/%s\", path, *p++));\n"
  "\n"
  "    if (rmdir(path) && errno != ENOENT)\n"
  "      texc_throw(\"file.del\",\n"
  "        str_f(\"Fail deleting %s: %s\", path, strerror(errno))\n"
  "      );\n"
  "  } else {\n"
  "    if (unlink(path) && errno != ENOENT)\n"
  "      texc_throw(\"file.del\",\n"
  "        str_f(\"Fail deleting %s: %s\", path, strerror(errno))\n"
  "      );\n"
  "  }\n"
  "}\n"
  "static Arrs *file_dir (char *path) {\n"
  "  DIR *d = opendir(path);\n"
  "  if (!d)\n"
  "    texc_throw(\"file.dir\",\n"
  "      str_f(\"Fail reading directory %s: %s\", path, strerror(errno))\n"
  "    );\n"
  "  Arrs *a = tarr_new_s();\n"
  "  struct dirent *res;\n"
  "  while ((res = readdir(d))) {\n"
  "    char *name = res->d_name;\n"
  "    if (!strcmp(name, \".\") || !strcmp(name, \"..\")) {\n"
  "      continue;\n"
  "    }\n"
  "    tarr_pushS(a, str_new(name));\n"
  "  }\n"
  "  closedir(d);\n"
  "  return a;\n"
  "}\n"
  "static int file_exists (char *path) {\n"
  "  struct stat buf;\n"
  "  if (stat(path, &buf)) {\n"
  "    if (errno == ENOENT) {\n"
  "      return FALSE;\n"
  "    }\n"
  "    texc_throw(\"file.exists\",\n"
  "      str_f(\"Fail reading %s: %s\", path, strerror(errno))\n"
  "    );\n"
  "  }\n"
  "  return TRUE;\n"
  "}\n"
  "static char *file_extension (char *path) {\n"
  "  path = file_base(path);\n"
  "  int ix = str_last_cindex(path, '.');\n"
  "  if (ix == -1) return \"\";\n"
  "  return str_right(path, ix);\n"
  "}\n"
  "int file_is_directory (char *path) {\n"
  "  struct stat buf;\n"
  "  if (stat(path, &buf)) {\n"
  "    if (errno == ENOENT) {\n"
  "      return FALSE;\n"
  "    }\n"
  "    texc_throw(\"file.isDirectory\",\n"
  "      str_f(\"Fail reading %s: %s\", path, strerror(errno))\n"
  "    );\n"
  "  }\n"
  "  if (S_ISDIR(buf.st_mode))\n"
  "    return TRUE;\n"
  "  return FALSE;\n"
  "}\n"
  "int file_is_link (char *path) {\n"
  "  struct stat buf;\n"
  "  if (lstat(path, &buf)) {\n"
  "    if (errno == ENOENT) {\n"
  "      return FALSE;\n"
  "    }\n"
  "    texc_throw(\"file.isLink\",\n"
  "      str_f(\"Fail reading %s: %s\", path, strerror(errno))\n"
  "    );\n"
  "  }\n"
  "  if (S_ISLNK(buf.st_mode))\n"
  "    return TRUE;\n"
  "  return FALSE;\n"
  "}\n"
  "int file_is_regular (char *path) {\n"
  "  struct stat buf;\n"
  "  if (stat(path, &buf)) {\n"
  "    if (errno == ENOENT) {\n"
  "      return FALSE;\n"
  "    }\n"
  "    texc_throw(\"file.isRegular\",\n"
  "      str_f(\"Fail reading %s: %s\", path, strerror(errno))\n"
  "    );\n"
  "  }\n"
  "  if (S_ISREG(buf.st_mode))\n"
  "    return TRUE;\n"
  "  return FALSE;\n"
  "}\n"
  "static Obj *file_lck_new(FILE *file) {\n"
  "  struct flock *lck = MALLOC(struct flock);\n"
  "  lck->l_whence = SEEK_SET;\n"
  "  lck->l_start = 0;\n"
  "  lck->l_len = 0;\n"
  "  LckFile *lf = MALLOC(LckFile);\n"
  "  lf->lock = lck;\n"
  "  lf->f = file;\n"
  "  return obj_new(\"<file>\", lf);\n"
  "}\n"
  "static void file_mkdir (char *path) {\n"
  "  if (!*path || (*path == '/' && !path[1])) return;\n"
  "  char *p;\n"
  "  if (*path != '/') {\n"
  "    char *cwd = file_wd();\n"
  "    p = str_f(\"%s/%s\", cwd, path);\n"
  "  } else {\n"
  "    p = path;\n"
  "  }\n"
  "  p = file_parent(p);\n"
  "  file_mkdir(p);\n"
  "  if (mkdir(path, 0755) && errno != EEXIST)\n"
  "    texc_throw(\"file.mkdir\",\n"
  "      str_f(\"Fail making directory %s: %s\" , path, strerror(errno))\n"
  "    );\n"
  "}\n"
  "static void file_mklink (char *path, char *link) {\n"
  "  if (symlink(path, link) == -1)\n"
  "    texc_throw(\"file.mkdir\",\n"
  "      str_f(\"Fail linking '%s' to '%s: %s\", link, path, strerror(errno))\n"
  "    );\n"
  "}\n"
  "static char *file_normalize(char *path) {\n"
  "  char *r = str_trim(path);\n"
  "  while (str_ends(r, \"/\")) r = str_left(r, -1);\n"
  "  return r;\n"
  "}\n"
  "static char *file_parent (char *path) {\n"
  "  char *s = file_normalize(path);\n"
  "  if (!*s)\n"
  "    texc_throw(\"file.parent\",\n"
  "      str_f(\"'%s' has not parent directory\", path)\n"
  "    );\n"
  "  int ix = str_last_cindex(s, '/');\n"
  "  if (ix == -1) return \"\";\n"
  "  if (ix == 0) return \"/\";\n"
  "  return str_left(s, ix);\n"
  "}\n"
  "static char *file_read(char *path) {\n"
  "  FILE *fl;\n"
  "  size_t len = 0;\n"
  "  struct flock lck = {\n"
  "    .l_whence = SEEK_SET,\n"
  "    .l_start = 0,\n"
  "    .l_len = 0,\n"
  "  };\n"
  "  fl = fopen(path, \"r\");\n"
  "  if (!fl)\n"
  "    texc_throw(\"file.read\",\n"
  "      str_f(\"Fail openning %s: %s\", path, strerror(errno))\n"
  "    );\n"
  "  lck.l_type = F_RDLCK;\n"
  "  fcntl (fileno(fl), F_SETLKW, &lck);\n"
  "  Buf *bf = buf_new();\n"
  "  char *line = NULL;\n"
  "  while (getline(&line, &len, fl) != -1) {\n"
  "    buf_add(bf, line);\n"
  "    free(line); // free ok\n"
  "    line = NULL;\n"
  "  }\n"
  "  free(line); // free ok\n"
  "  lck.l_type = F_UNLCK;\n"
  "  fcntl (fileno(fl), F_SETLK, &lck);\n"
  "  fclose(fl);\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "static Obj *file_read_bin (Obj *file, int64_t buf) {\n"
  "  texc_check_type(\"file.readBin\", file, \"<file>\");\n"
  "  LckFile *lf = file->value;\n"
  "  unsigned char bs[buf];\n"
  "  int len = (int)fread(bs, 1, buf, lf->f);\n"
  "  if (len == -1) {\n"
  "    file_close(file);\n"
  "    texc_throw(\"file.readBin\",\n"
  "      str_f(\"Fail file_read_bin_buf: %s\", strerror(errno))\n"
  "    );\n"
  "  }\n"
  "  if (len == 0) {\n"
  "    return bytes_new(0);\n"
  "  }\n"
  "  return bytes_from_bytes(bs, len);\n"
  "}\n"
  "static Arrs *file_read_line (Obj *file) {\n"
  "  texc_check_type(\"file.readBin\", file, \"<file>\");\n"
  "  LckFile *lf = file->value;\n"
  "  size_t len = 0;\n"
  "  errno = 0;\n"
  "  char *line= NULL;\n"
  "  if (getline(&line, &len, lf->f) != -1) {\n"
  "    char *r = str_new(line);\n"
  "    free(line); // free ok\n"
  "    while (str_ends(r, \"\\n\") || str_ends(r, \"\\r\")) r = str_left(r, -1);\n"
  "    return tarr_news(r, 1);\n"
  "  }\n"
  "  free(line); // free ok\n"
  "  if (errno) {\n"
  "    file_close(file);\n"
  "    texc_throw(\"file.readLine\",\n"
  "      str_f(\"Fail file_read_line: %s\", strerror(errno))\n"
  "    );\n"
  "  }\n"
  "  return tarr_new_s();\n"
  "}\n"
  "static void file_rename (char *old, char *new) {\n"
  "  if (rename(old, new) == -1)\n"
  "    texc_throw(\"file.readLine\",\n"
  "      str_f(\"Fail renaming '%s' to '%s: %s\", old, new, strerror(errno))\n"
  "    );\n"
  "}\n"
  "static Obj *file_ropen (char *path) {\n"
  "  FILE *file = fopen(path, \"r\");\n"
  "  if (!file)\n"
  "    texc_throw(\"file.ropen\",\n"
  "      str_f(\"Fail opening '%s': %s\", path, strerror(errno))\n"
  "    );\n"
  "  Obj *r = file_lck_new(file);\n"
  "  LckFile *lf = r->value;\n"
  "  lf->lock->l_type = F_RDLCK;\n"
  "  fcntl(fileno(file), F_SETLKW, lf->lock);\n"
  "  return r;\n"
  "}\n"
  "struct stat *file_info (char *path) {\n"
  "  struct stat *r = MALLOC(struct stat);\n"
  "  if (stat(path, r))\n"
  "    texc_throw(\"file.size | file.tm\",\n"
  "      str_f(\"Fail reading %s: %s\", path, strerror(errno))\n"
  "    );\n"
  "  return r;\n"
  "}\n"
  "static int64_t file_size (char *path) {\n"
  "  struct stat *i = file_info (path);\n"
  "  return i->st_size;\n"
  "}\n"
  "static int64_t file_tm (char *path){\n"
  "  struct stat *i = file_info (path);\n"
  "  return ((int64_t)i->st_mtime) * 1000;\n"
  "}\n"
  "static char *file_tmp (char *dir, char *prefix) {\n"
  "  if (!*dir) dir = \"/tmp\";\n"
  "  char *fpath = NULL;\n"
  "  for (;;) {\n"
  "    char *k = cryp_genk(16);\n"
  "    char *pid = str_f(\"%d\", (int)getpid());\n"
  "    char *v = str_left(cryp_encode(k, pid), 8);\n"
  "    fpath = str_f(\"%s/%s%s\", dir, prefix, str_creplace(v, '/', '-'));\n"
  "    if (!file_exists(fpath)) break;\n"
  "  }\n"
  "  return fpath;\n"
  "}\n"
  "static char *file_wd (void) {\n"
  "  char *d = getcwd(NULL, 0);\n"
  "  if (!d)\n"
  "    texc_throw(\"file.wd\",\n"
  "      str_f(\"Working directory can no be find: %s\", strerror(errno))\n"
  "    );\n"
  "  char *r = str_new(d);\n"
  "  free(d);  // free is ok\n"
  "  return r;\n"
  "}\n"
  "static Obj *file_wopen (char *path) {\n"
  "  FILE *file = fopen(path, \"w\");\n"
  "  if (!file)\n"
  "    texc_throw(\"file.wopen\",\n"
  "      str_f(\"Fail opening '%s': %s\", path, strerror(errno))\n"
  "    );\n"
  "  Obj *r = file_lck_new(file);\n"
  "  LckFile *lf = r->value;\n"
  "  lf->lock->l_type = F_WRLCK;\n"
  "  fcntl (fileno(file), F_SETLKW, lf->lock);\n"
  "  return r;\n"
  "}\n"
  "static void file_write (char *path, char *text) {\n"
  "  FILE *fl;\n"
  "  int error;\n"
  "  struct flock lck = {\n"
  "    .l_whence = SEEK_SET,\n"
  "    .l_start = 0,\n"
  "    .l_len = 0,\n"
  "  };\n"
  "  fl = fopen(path, \"w\");\n"
  "  if (!fl)\n"
  "    texc_throw(\"file.write\",\n"
  "      str_f(\"Fail openning %s: %s\", path, strerror(errno))\n"
  "    );\n"
  "  lck.l_type = F_WRLCK;\n"
  "  fcntl (fileno(fl), F_SETLKW, &lck);\n"
  "  error = fputs(text, fl);\n"
  "  lck.l_type = F_UNLCK;\n"
  "  fcntl (fileno(fl), F_SETLK, &lck);\n"
  "  if (error == EOF || error < 0) {\n"
  "    fclose(fl);\n"
  "    texc_throw(\"file.write\",\n"
  "      str_f(\"Fail writing '%s': %s\", path, strerror(error))\n"
  "    );\n"
  "  }\n"
  "  fclose(fl);\n"
  "}\n"
  "static void file_write_bin (Obj *file, Obj *data) {\n"
  "  texc_check_type(\"file.writeBin\", file, \"<file>\");\n"
  "  texc_check_type(\"file.writeBin\", data, \"<bytes>\");\n"
  "  LckFile *lf = file->value;\n"
  "  Bytes *bs = data->value;\n"
  "  if (fwrite(bs->bs, bs->length, 1, lf->f) == -1)\n"
  "    texc_throw(\"file.writeBin\",\n"
  "      str_f(\"Fail file_write_bin: %s\", strerror(errno))\n"
  "    );\n"
  "}\n"
  "static void file_write_text (Obj *file, char *text) {\n"
  "  texc_check_type(\"file.writeText\", file, \"<file>\");\n"
  "  LckFile *lf = file->value;\n"
  "  int error = fputs(text, lf->f);\n"
  "  if (error == EOF || error < 0) {\n"
  "    file_close(file);\n"
  "    texc_throw(\"file.writeText\",\n"
  "      str_f(\"Fail file_write_line: %s\", strerror(errno))\n"
  "    );\n"
  "  }\n"
  "}\n"
  "\n"
"// js.c ----------\n"
  "static void json_unicode(Buf *bf, char *hexdigits) {\n"
  "  char hexvalue (char ch) {\n"
  "    return (ch <= '9') ? ch - '0' : toupper(ch) - 'A' + 10;\n"
  "  }\n"
  "  unsigned int codepoint =\n"
  "    hexvalue(*hexdigits) * 4096 +\n"
  "    hexvalue(*(hexdigits + 1)) * 256 +\n"
  "    hexvalue(*(hexdigits + 2)) * 16 +\n"
  "    hexvalue(*(hexdigits + 3));\n"
  "  if (codepoint < 0x80) {\n"
  "    buf_cadd(bf, (codepoint>>0  & 0x7F) | 0x00);\n"
  "    return;\n"
  "  }\n"
  "  if (codepoint < 0x0800) {\n"
  "    buf_cadd(bf, (codepoint>>6  & 0x1F) | 0xC0);\n"
  "    buf_cadd(bf, (codepoint>>0  & 0x3F) | 0x80);\n"
  "    return;\n"
  "  }\n"
  "  buf_cadd(bf, (codepoint>>12 & 0x0F) | 0xE0);\n"
  "  buf_cadd(bf, (codepoint>>6  & 0x3F) | 0x80);\n"
  "  buf_cadd(bf, (codepoint>>0  & 0x3F) | 0x80);\n"
  "}\n"
  "static char *json_blanks(char *json) {\n"
  "  while (*json && ((unsigned char)*json) <= ' ') {\n"
  "    ++json;\n"
  "  }\n"
  "  return json;\n"
  "}\n"
  "static char *json_snull(char *json) {\n"
  "  return json_blanks(json + 4);\n"
  "}\n"
  "static char *json_sbool(char *json) {\n"
  "  if (*json == 't') {\n"
  "    return json_blanks(json + 4);\n"
  "  }\n"
  "  return json_blanks(json + 5);\n"
  "}\n"
  "static char *json_snumber(char *j) {\n"
  "  while (\n"
  "    *j && *j != '}' && *j != ']' && *j != ',' && ((unsigned char) *j) > ' '\n"
  "  ) {\n"
  "    ++j;\n"
  "  }\n"
  "  return json_blanks(j);\n"
  "}\n"
  "static char *json_sstring(char *j) {\n"
  "  ++j;\n"
  "  while (*j && *j != '\"') {\n"
  "    if (*j++ == '\\\\') {\n"
  "      if (*j) {\n"
  "        ++j;\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "  if (*j) {\n"
  "    ++j;\n"
  "  }\n"
  "  return json_blanks(j);\n"
  "}\n"
  "static char *json_selement(char *j);\n"
  "static char *json_sarray(char *j) {\n"
  "  ++j;\n"
  "  j = json_blanks(j);\n"
  "  while (*j && *j != ']') {\n"
  "    j = json_selement(j);\n"
  "    if (*j == ',') {\n"
  "      ++j;\n"
  "      j = json_blanks(j);\n"
  "    }\n"
  "  }\n"
  "  if (*j) {\n"
  "    ++j;\n"
  "  }\n"
  "  return json_blanks(j);\n"
  "}\n"
  "static char *json_sobject(char *j) {\n"
  "  ++j;\n"
  "  j = json_blanks(j);\n"
  "  while (*j && *j != '}') {\n"
  "    j = json_sstring(j);\n"
  "    ++j;\n"
  "    j = json_selement(j);\n"
  "    if (*j == ',') {\n"
  "      ++j;\n"
  "      j = json_blanks(j);\n"
  "    }\n"
  "  }\n"
  "  if (*j) {\n"
  "    ++j;\n"
  "  }\n"
  "  return json_blanks(j);\n"
  "}\n"
  "static char *json_selement(char *j) {\n"
  "  j = json_blanks(j);\n"
  "  switch (*j) {\n"
  "  case 'n': return json_snull(j);\n"
  "  case 't':\n"
  "  case 'f': return json_sbool(j);\n"
  "  case '\"': return json_sstring(j);\n"
  "  case '[': return json_sarray(j);\n"
  "  case '{': return json_sobject(j);\n"
  "  case '-': return json_snumber(j);\n"
  "  default :\n"
  "    if (*j >= '0' && *j <= '9') {\n"
  "      return json_snumber(j);\n"
  "    } else {\n"
  "      if (*j) {\n"
  "        ++j;\n"
  "      }\n"
  "      return j;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "static int json_rend(char *json) {\n"
  "  while (*json && ((unsigned char)*json) <= ' ') {\n"
  "    ++json;\n"
  "  }\n"
  "  return *json ? 0 : 1;\n"
  "}\n"
  "static char *json_error(char *json) {\n"
  "  Arrs *runes = str_to_runes(json);\n"
  "  return tarr_sizeS(runes) > 70\n"
  "    ? str_f(\"%s...\", tarr_join(tarr_takeS(runes, 67), \"\"))\n"
  "    : json\n"
  "  ;\n"
  "}\n"
  "static int js_is_null (char *json) {\n"
  "  char *j = json_blanks(json);\n"
  "  if (memcmp(j, \"null\", 4)) {\n"
  "    return 0;\n"
  "  }\n"
  "  return json_rend(j + 4);\n"
  "}\n"
  "\n"
  "static int js_rb (char *json) {\n"
  "  char *jsons = json_blanks(json);\n"
  "  int r;\n"
  "  char *j = jsons;\n"
  "  if (memcmp(j, \"true\", 4)) {\n"
  "    if (memcmp(j, \"false\", 5))\n"
  "      texc_expect(\"js.rb\",\n"
  "        \"Bad JSON string\", \"Boolean value\", json_error(json)\n"
  "      );\n"
  "    r = 0;\n"
  "    j += 5;\n"
  "  } else {\n"
  "    r = 1;\n"
  "    j += 4;\n"
  "  }\n"
  "  if (!json_rend(j))\n"
  "    texc_expect(\"js.rb\",\n"
  "      \"Bad JSON string\", \"Boolean value (spare characters)\", json_error(json)\n"
  "    );\n"
  "  return r;\n"
  "}\n"
  "static int64_t js_ri (char *json) {\n"
  "  char *jsons = json_blanks(json);\n"
  "  char *j = jsons;\n"
  "  if (*j != '-' && (*j < '0' || *j > '9'))\n"
  "    texc_expect(\"js.ri\",\n"
  "      \"Bad JSON string\", \"Long value\", json_error(json)\n"
  "    );\n"
  "  Buf *bf = buf_new();\n"
  "  while (\n"
  "    *j && *j != '}' && *j != ']' && *j != ',' && ((unsigned char)*j) > ' '\n"
  "  ) {\n"
  "    ++j;\n"
  "  }\n"
  "  buf_add_buf(bf, jsons, j - jsons);\n"
  "  char *n = buf_str(bf);\n"
  "  if (!json_rend(j))\n"
  "    texc_expect(\"js.ri\",\n"
  "      \"Bad JSON string\", \"Long value (spare characters)\", json_error(json)\n"
  "    );\n"
  "  char *tail;\n"
  "  errno = 0;\n"
  "  int64_t r = strtol(n, &tail, 10);\n"
  "  if (errno)\n"
  "    texc_throw(\"js.ri\",\n"
  "      str_f(\"Bad JSON string: Long overflow in %s\", json_error(json))\n"
  "    );\n"
  "  if (*tail)\n"
  "    texc_expect(\"js.ri\",\n"
  "      \"Bad JSON string\", \"Long value\", json_error(json)\n"
  "    );\n"
  "  return r;\n"
  "}\n"
  "static double js_rf (char *json) {\n"
  "  struct lconv *lc = localeconv();\n"
  "  char *jsons = json_blanks(json);\n"
  "  char *j = jsons;\n"
  "  if (*j != '-' && (*j < '0' || *j > '9'))\n"
  "    texc_expect(\"js.rf\",\n"
  "     \"Bad JSON string\", \"Float value\", json_error(json)\n"
  "    );\n"
  "  Buf *bf = buf_new();\n"
  "  while (\n"
  "    *j && *j != '}' && *j != ']' && *j != ',' && ((unsigned char)*j) > ' '\n"
  "  ) {\n"
  "    ++j;\n"
  "  }\n"
  "  buf_add_buf(bf, jsons, j - jsons);\n"
  "  char *n = buf_str(bf);\n"
  "  int ix = str_cindex(n, '.');\n"
  "  if (ix != -1) {\n"
  "    n[ix] = *lc->decimal_point;\n"
  "  }\n"
  "  if (!json_rend(j))\n"
  "    texc_expect(\"js.rf\",\n"
  "      \"Bad JSON string\", \"Float value (spare characters)\", json_error(json)\n"
  "    );\n"
  "  errno = 0;\n"
  "  char *tail;\n"
  "  double r = strtod(n, &tail);\n"
  "  if (errno)\n"
  "    texc_throw(\"js.rf\",\n"
  "      str_f(\"Bad JSON string: Float overflow in %s\", json_error(json))\n"
  "    );\n"
  "  if (*tail)\n"
  "    texc_expect(\"js.rf\",\n"
  "     \"Bad JSON string\", \"Float value\", json_error(json)\n"
  "    );\n"
  "  return r;\n"
  "}\n"
  "static char *js_rs (char *j) {\n"
  "  int is_hex (char ch) {\n"
  "    return (ch >= '0' && ch <= '9') ||\n"
  "      (ch >= 'a' && ch <= 'f') ||\n"
  "      (ch >= 'A' && ch <= 'F');\n"
  "  }\n"
  "  char *json = json_blanks(j);\n"
  "  if (*json != '\"')\n"
  "    texc_expect(\"js.rs\",\n"
  "      \"Bad JSON string\", \"String value (not begin with '\\\"')\", json_error(j)\n"
  "    );\n"
  "  ++json;\n"
  "  Buf *bf = buf_new();\n"
  "  while (*json && *json != '\"') {\n"
  "    if (*json == '\\\\') {\n"
  "      ++json;\n"
  "      switch (*json) {\n"
  "        case '\"' :\n"
  "        case '\\\\' :\n"
  "        case '/' :\n"
  "          buf_cadd(bf, *json);\n"
  "          break;\n"
  "        case 'b' :\n"
  "          buf_cadd(bf, '\\b');\n"
  "          break;\n"
  "        case 'f' :\n"
  "          buf_cadd(bf, '\\f');\n"
  "          break;\n"
  "        case 'n' :\n"
  "          buf_cadd(bf, '\\n');\n"
  "          break;\n"
  "        case 'r' :\n"
  "          buf_cadd(bf, '\\r');\n"
  "          break;\n"
  "        case 't' :\n"
  "          buf_cadd(bf, '\\t');\n"
  "          break;\n"
  "        case 'u' : {\n"
  "          ++json;\n"
  "          int c = 5;\n"
  "          while (--c) {\n"
  "            if (!is_hex(*json++))\n"
  "              texc_expect(\"js.rs\",\n"
  "                \"Bad JSON string\", \"String value (Bad unicode)\", json_error(j)\n"
  "              );\n"
  "          }\n"
  "          json_unicode(bf, json - 4);\n"
  "          continue;\n"
  "        }\n"
  "        default:\n"
  "          texc_expect(\"js.rs\",\n"
  "            \"Bad JSON string\", \"String value (Bad escape sequence)\", json_error(j)\n"
  "          );\n"
  "      }\n"
  "      ++json;\n"
  "    } else {\n"
  "      buf_cadd(bf, *json++);\n"
  "    }\n"
  "  }\n"
  "  if (!*json)\n"
  "    texc_expect(\"js.rs\",\n"
  "      \"Bad JSON string\", \"String value (not end with '\\\"')\", json_error(j)\n"
  "    );\n"
  "  if (!json_rend(json + 1))\n"
  "    texc_expect(\"js.rs\",\n"
  "      \"Bad JSON string\", \"String value (spare characters)\", json_error(j)\n"
  "    );\n"
  "  char *r = str_new(buf_str(bf));\n"
  "  return r;\n"
  "}\n"
  "static Arrs *js_ra (char *j) {\n"
  "  char *json = json_blanks(j);\n"
  "  if (*json != '[')\n"
  "    texc_expect(\"js.ra\",\n"
  "      \"Bad JSON string\", \"Array value (not begin with '[')\", json_error(j)\n"
  "    );\n"
  "  ++json;\n"
  "  Arrs *a = tarr_new_s();\n"
  "  while (*json && *json != ']') {\n"
  "    char *tmp = json;\n"
  "    json = json_selement(json);\n"
  "    Buf *bf = buf_new();\n"
  "    buf_add_buf(bf, tmp, json - tmp);\n"
  "    tarr_pushS(a, str_new(buf_str(bf)));\n"
  "    if (*json == ',') {\n"
  "      ++json;\n"
  "    } else if (*json && *json != ']')\n"
  "      texc_expect(\"js.ra\",\n"
  "        \"Bad JSON string\", \"Array value (comma missing)\", json_error(j)\n"
  "      );\n"
  "  }\n"
  "  if (!*json)\n"
  "    texc_expect(\"js.ra\",\n"
  "      \"Bad JSON string\", \"Array value (not end with ']')\", json_error(j)\n"
  "    );\n"
  "  if (!json_rend(json + 1))\n"
  "    texc_expect(\"js.ra\",\n"
  "      \"Bad JSON string\", \"Array value (spare characters)\", json_error(j)\n"
  "    );\n"
  "  return a;\n"
  "}\n"
  "\n"
  "static Arrs *js_ro (char *j) {\n"
  "  char *json = json_blanks(j);\n"
  "  if (*json != '{')\n"
  "    texc_expect(\"js.ro\",\n"
  "      \"Bad JSON string\", \"Object value (not begin with '{')\", json_error(j)\n"
  "    );\n"
  "  json = json_blanks(json + 1);\n"
  "  Arrs *m = tarr_new_s();\n"
  "  while (*json && *json != '}') {\n"
  "    if (*json != '\"')\n"
  "      texc_expect(\"js.ro\",\n"
  "        \"Bad JSON string\", \"Object value (bad key)\", json_error(j)\n"
  "      );\n"
  "    char *tmp = json;\n"
  "    json = json_sstring(json);\n"
  "    Buf *kbf = buf_new();\n"
  "    buf_add_buf(kbf, tmp, json - tmp);\n"
  "    if (*json != ':')\n"
  "      texc_expect(\"js.ro\",\n"
  "        \"Bad JSON string\", \"Object value (':' is missing)\", json_error(j)\n"
  "      );\n"
  "    ++json;\n"
  "    tmp = json;\n"
  "    json = json_selement(json);\n"
  "    Buf *vbf = buf_new();\n"
  "    buf_add_buf(vbf, tmp, json - tmp);\n"
  "    dic_put(m, js_rs(buf_str(kbf)), str_new(buf_str(vbf)));\n"
  "    if (*json == ',') {\n"
  "      json = json_blanks(json + 1);\n"
  "    } else if (*json && *json != '}')\n"
  "      texc_expect(\"js.ro\",\n"
  "        \"Bad JSON string\", \"Object value (comma missing)\", json_error(j)\n"
  "      );\n"
  "  }\n"
  "  if (!*json)\n"
  "    texc_expect(\"js.ro\",\n"
  "      \"Bad JSON string\", \"Object value (not end with '}')\", json_error(j)\n"
  "    );\n"
  "  if (!json_rend(json + 1))\n"
  "    texc_expect(\"js.ro\",\n"
  "      \"Bad JSON string\", \"Object value (spare characters)\", json_error(j)\n"
  "    );\n"
  "  return m;\n"
  "}\n"
  "static char *js_wb(int value) {\n"
  "  return str_new(value ? \"true\" : \"false\");\n"
  "}\n"
  "static char *js_wi(int64_t n) {\n"
  "  return str_f(\"%ld\", n);\n"
  "}\n"
  "static char *js_wf(double n) {\n"
  "  return math_ftos(n);\n"
  "}\n"
  "static char *js_wf2(double n, int64_t scale) {\n"
  "  return math_ftos2(n, scale);\n"
  "}\n"
  "static char *js_ws(char *s) {\n"
  "  Buf *bf = buf_new();\n"
  "  char tmp;\n"
  "  buf_cadd(bf, '\"');\n"
  "  while (*s) {\n"
  "    tmp = *s++;\n"
  "    switch (tmp) {\n"
  "    case '\"':\n"
  "      buf_add(bf, \"\\\\\\\"\");\n"
  "      break;\n"
  "    case '\\\\':\n"
  "      buf_add(bf, \"\\\\\\\\\");\n"
  "      break;\n"
  "    case '\\b':\n"
  "      buf_add(bf, \"\\\\b\");\n"
  "      break;\n"
  "    case '\\f':\n"
  "      buf_add(bf, \"\\\\f\");\n"
  "      break;\n"
  "    case '\\n':\n"
  "      buf_add(bf, \"\\\\n\");\n"
  "      break;\n"
  "    case '\\r':\n"
  "      buf_add(bf, \"\\\\r\");\n"
  "      break;\n"
  "    case '\\t':\n"
  "      buf_add(bf, \"\\\\t\");\n"
  "      break;\n"
  "    default:\n"
  "      buf_cadd(bf, tmp);\n"
  "    }\n"
  "  }\n"
  "  buf_cadd(bf, '\"');\n"
  "  char *r = str_new(buf_str(bf));\n"
  "  return r;\n"
  "}\n"
  "static char *js_wa(Arrs *a) {\n"
  "  Buf *bf = buf_new();\n"
  "  buf_cadd(bf, '[');\n"
  "  char **p = tarr_beginS(a);\n"
  "  char **end = tarr_endS(a);\n"
  "  if (p < end) {\n"
  "    buf_add(bf, *p++);\n"
  "    while (p < end) {\n"
  "      buf_cadd(bf, ',');\n"
  "      buf_add(bf, *p++);\n"
  "    }\n"
  "  }\n"
  "  buf_cadd(bf, ']');\n"
  "  char *r = str_new(buf_str(bf));\n"
  "  return r;\n"
  "}\n"
  "static char *js_wo(Arrs *m) {\n"
  "  Buf *bf = buf_new();\n"
  "  buf_cadd(bf, '{');\n"
  "  char **p = tarr_beginS(m);\n"
  "  char **end = tarr_endS(m);\n"
  "  if (p < end) {\n"
  "    buf_add(bf, js_ws(*p++));\n"
  "    buf_cadd(bf, ':');\n"
  "    buf_add(bf, *p++);\n"
  "    while (p < end) {\n"
  "      buf_cadd(bf, ',');\n"
  "      buf_add(bf, js_ws(*p++));\n"
  "      buf_cadd(bf, ':');\n"
  "      buf_add(bf, *p++);\n"
  "    }\n"
  "  }\n"
  "  buf_cadd(bf, '}');\n"
  "  char *r = str_new(buf_str(bf));\n"
  "  return r;\n"
  "}\n"
  "\n"
"// math.c ----------\n"
  "static double math_abs (double n) {\n"
  "  return n >= 0 ? n : -n;\n"
  "}\n"
  "static int math_digits (char *s) {\n"
  "  if (!*s) return 0;\n"
  "  char *ps = s;\n"
  "  char ch;\n"
  "  while ((ch = *ps++)) if (ch < '0' || ch > '9') return 0;\n"
  "  return 1;\n"
  "}\n"
  "static int math_eq (double n1, double n2) {\n"
  "  return math_eq_gap(n1, n2, 0.0000001);\n"
  "}\n"
  "static int math_eq_gap (double n1, double n2, double gap) {\n"
  "  gap = gap > 1 ? 1 : gap < 0.0000000001 ? 0.0000000001 : gap;\n"
  "  return n1 < n2 + gap && n1 > n2 - gap;\n"
  "}\n"
  "static Arrf *math_from_en (char *s) {\n"
  "  return math_stof(str_replace(s, \",\", \"\"));\n"
  "}\n"
  "static Arri *math_from_hex (char *s) {\n"
  "  return math_stoi_base(s, 16);\n"
  "}\n"
  "static Arrf *math_from_iso (char *s) {\n"
  "  return math_stof(str_replace(str_replace(s, \".\", \"\"), \",\", \".\"));\n"
  "}\n"
  "static char *math_ftos (double n) {\n"
  "  return math_ftos2(n, 9);\n"
  "}\n"
  "static char *math_ftos2 (double n, int scale) {\n"
  "  scale = scale < 0 ? 0 : scale > 9 ? 9 : scale;\n"
  "  char *tpl = str_f(\"%%.%df\", scale);\n"
  "  char *ns = str_f(tpl, n + (n >= 0 ? 0.000000000001 : -0.000000000001));\n"
  "  if (scale > 0) {\n"
  "    char *p = ns;\n"
  "    while (*p) {\n"
  "      if (*p == ',') *p++ = '.';\n"
  "      else ++p;\n"
  "    }\n"
  "    --p;\n"
  "    while (*p == '0') --p;\n"
  "    if (*p != '.') ++p;\n"
  "    ns = str_left(ns, p - ns);\n"
  "  }\n"
  "  if (!strcmp(ns, \"-0\")) ns = \"0\";\n"
  "  return ns;\n"
  "}\n"
  "static char *math_itos (int64_t n) {\n"
  "  return str_f(\"%ld\", n);\n"
  "}\n"
  "static double math_max (double n1, double n2) {\n"
  "  return n1 > n2 ? n1 : n2;\n"
  "}\n"
  "static double math_min (double n1, double n2) {\n"
  "  return n1 < n2 ? n1 : n2;\n"
  "}\n"
  "static double math_pow10 (int64_t ex) {\n"
  "  double r = 1;\n"
  "  double mul = ex > 0 ? 10 : 0.1;\n"
  "  ex = (ex >= 0 ? ex : -ex) + 1;\n"
  "  while(--ex) {\n"
  "    r *= mul;\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "static double math_rnd (void) {\n"
  "  return (double)rand() / (double)RAND_MAX;\n"
  "}\n"
  "static int64_t math_rndi (int64_t top) {\n"
  "  return (int)(math_rnd() * top);\n"
  "}\n"
  "static double math_round (double n, int64_t scale) {\n"
  "  n = n >= 0 ? n + 0.00000000001 : n - 0.00000000001;\n"
  "  switch (scale) {\n"
  "    case 0: return round(n);\n"
  "    case 1: return round (n * 10.0) / 10.0;\n"
  "    case 2: return round (n * 100.0) / 100.0;\n"
  "    case 3: return round (n * 1000.0) / 1000.0;\n"
  "    case 4: return round (n * 10000.0) / 10000.0;\n"
  "    case 5: return round (n * 100000.0) / 100000.0;\n"
  "    case 6: return round (n * 1000000.0) / 1000000.0;\n"
  "    case 7: return round (n * 10000000.0) / 10000000.0;\n"
  "    case 8: return round (n * 100000000.0) / 100000000.0;\n"
  "    case 9: return round (n * 1000000000.0) / 1000000000.0;\n"
  "    default: if (scale < 0) return round(n);\n"
  "             else return round (n * 1000000000.0) / 1000000000.0;\n"
  "  }\n"
  "}\n"
  "static Arrf *math_stof (char *s) {\n"
  "  s = str_trim(s);\n"
  "  if (!*s) return tarr_new_f();\n"
  "\n"
  "  struct lconv *lc = localeconv();\n"
  "  int ix = str_cindex(s, '.');\n"
  "  if (ix != -1) s[ix] = *lc->decimal_point;\n"
  "\n"
  "  char *tmp;\n"
  "  double r = strtod(s, &tmp);\n"
  "  if (*tmp) return tarr_new_f();\n"
  "  return tarr_newf(r, 1);\n"
  "}\n"
  "static Arri *math_stoi (char *s) {\n"
  "  math_stoi_base(s, 0);\n"
  "}\n"
  "static Arri *math_stoi_base (char *s, int base) {\n"
  "  s = str_trim(s);\n"
  "  if (!*s) return tarr_new_i();\n"
  "\n"
  "  char *tmp;\n"
  "  int64_t r = strtol(s, &tmp, base);\n"
  "  if (*tmp) return tarr_new_i();\n"
  "\n"
  "  return tarr_newi(r, 1);\n"
  "}\n"
  "\n"
"// obj.c ----------\n"
  "Obj *obj_new(char *type, void *value) {\n"
  "  Obj *this = MALLOC(Obj);\n"
  "  this->type = type;\n"
  "  this->value = value;\n"
  "  return this;\n"
  "}\n"
  "\n"
"// regex.c ----------\n"
  "typedef struct regex_RegexOffset {\n"
  "  int begin;\n"
  "  int end;\n"
  "} RegexOffset;\n"
  "static RegexOffset *regexOffset_new(int begin, int end) {\n"
  "  RegexOffset *this = MALLOC(RegexOffset);\n"
  "  this->begin = begin;\n"
  "  this->end = end;\n"
  "  return this;\n"
  "}\n"
  "static Arrs *regex_matches (char *s, char *rg) {\n"
  "  Arrs *r = tarr_new_s();\n"
  "\n"
  "  regex_t rex;\n"
  "  if (regcomp(&rex, rg, REG_EXTENDED))\n"
  "    texc_throw(\"regex.matches\", \"Regular expression can not be compiled\");\n"
  "  regmatch_t match;\n"
  "\n"
  "  int ix = 0;\n"
  "  for (;;) {\n"
  "    char *sub = str_right(s, ix);\n"
  "    char *offset = NULL;\n"
  "    int rs = regexec(&rex, sub, 1, &match, 0);\n"
  "    if (rs == REG_ESPACE)\n"
  "      texc_throw(\"regex.matches\", \"Regular expression out of memory\");\n"
  "\n"
  "    if (!rs) {\n"
  "      tarr_pushS(r, str_sub(s, ix, ix + match.rm_so));\n"
  "      int end = ix + match.rm_eo;\n"
  "      offset = str_sub(s, ix + match.rm_so, end);\n"
  "      ix = end;\n"
  "    }\n"
  "\n"
  "    if (offset) tarr_pushS(r, offset);\n"
  "    else { tarr_pushS(r, str_right(s, ix)); break; }\n"
  "  }\n"
  "\n"
  "  regfree(&rex);\n"
  "  return r;\n"
  "}\n"
  "static char *regex_replace (char *source, char *rg, char *repl) {\n"
  "  Arrs *ms = regex_matches(source, rg);\n"
  "  char **p = tarr_beginS(ms);\n"
  "  char **end = tarr_endS(ms);\n"
  "  Arrs *r = tarr_new_s();\n"
  "  for (;;) {\n"
  "    if (p >= end) break;\n"
  "    tarr_pushS(r, *p++);\n"
  "    if (p >= end) break;\n"
  "    tarr_pushS(r, repl);\n"
  "    ++p;\n"
  "  }\n"
  "  return tarr_join(r, \"\");\n"
  "}\n"
  "\n"
"// str.c ----------\n"
  "static int str_cindex (char *str, char ch) {\n"
  "  int c = 0;\n"
  "  char *p  = str;\n"
  "  while (*p) {\n"
  "    if (*p++ == ch) {\n"
  "      return c;\n"
  "    };\n"
  "    ++c;\n"
  "  }\n"
  "  return -1;\n"
  "}\n"
  "static int str_cindex_from (char *str, char ch, int from) {\n"
  "  if (from >= strlen(str)) {\n"
  "    return -1;\n"
  "  }\n"
  "  int c = from;\n"
  "  char *p  = str + from;\n"
  "  while (*p) {\n"
  "    if (*p++ == ch) {\n"
  "      return c;\n"
  "    };\n"
  "    ++c;\n"
  "  }\n"
  "  return -1;\n"
  "}\n"
  "static char *str_creplace (char *s, char old, char new) {\n"
  "  char *r = str_new(s);\n"
  "  char *p = r;\n"
  "  while (*p) {\n"
  "    if (*p == old)\n"
  "      *p = new;\n"
  "    ++p;\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "static Arrs *str_csplit (char *s, char sep) {\n"
  "  Arrs *r = tarr_new_s();\n"
  "  int i = str_cindex(s, sep);\n"
  "  while (i != -1) {\n"
  "    char *sub = ATOMIC(i + 1);\n"
  "    sub[i] = 0;\n"
  "    memcpy(sub, s, i);\n"
  "    tarr_pushS(r, sub);\n"
  "    s = s + i + 1;\n"
  "    i = str_cindex(s, sep);\n"
  "  }\n"
  "  tarr_pushS(r, str_new(s));\n"
  "  return r;\n"
  "}\n"
  "static int str_ends (char *str, char  *substr) {\n"
  "  int slen = strlen(str);\n"
  "  int sublen = strlen(substr);\n"
  "  return slen >= sublen && !memcmp(str + slen - sublen, substr, sublen);\n"
  "}\n"
  "static char *str_f (char *format, ...) {\n"
  "  va_list args;\n"
  "  va_start(args, format);\n"
  "  char *r = str_vf(format, args);\n"
  "  va_end(args);\n"
  "  return r;\n"
  "}\n"
  "static char *str_fmt (char *format, Arrs *values) {\n"
  "  int len = strlen(format);\n"
  "  int ix = 0;\n"
  "  int p = 0;\n"
  "  Buf *r = buf_new();\n"
  "  for (;;) {\n"
  "    int i = str_cindex_from(format, '%', p);\n"
  "    if (i == -1) break;\n"
  "    buf_add(r, str_sub(format, p, i));\n"
  "    ++i;\n"
  "    if (i == len)\n"
  "    texc_throw(\"str.fmt\", str_f(\"Bad '%' sequence at end in %s\", format));\n"
  "    char ch = format[i];\n"
  "    if (ch == '%') {\n"
  "      buf_cadd(r, ch);\n"
  "      p = i + 1;\n"
  "      continue;\n"
  "    }\n"
  "    if (ch == 's' || ch == 'v') {\n"
  "      if (tarr_sizeS(values) <= ix)\n"
  "        texc_throw(\"str.fmt\",\n"
  "          str_f(\"There are values missing in '%s'\", format)\n"
  "        );\n"
  "      switch (ch) {\n"
  "      case 's':\n"
  "      case 'v':\n"
  "        buf_add(r, tarr_getS(values, ix));\n"
  "        break;\n"
  "      default:\n"
  "        texc_throw(\"str.fmt\", str_f(\n"
  "          \"Bad '%' sequence in %s (only %%s and %%v are valid)\", format\n"
  "        ));\n"
  "      }\n"
  "      ++ix;\n"
  "      p = i + 1;\n"
  "      continue;\n"
  "    }\n"
  "    texc_throw(\"str.fmt\", str_f(\"Bad '%' sequence in %s\", format));\n"
  "  }\n"
  "  if (ix < tarr_sizeS(values))\n"
  "    texc_throw(\"str.fmt\",\n"
  "      str_f(\"There are too many values in %s\", built_to_strS(values))\n"
  "    );\n"
  "  buf_add(r, str_right(format, p));\n"
  "  return str_new(buf_str(r));\n"
  "}\n"
  "static char *str_from_escape (char *s) {\n"
  "  int len = strlen(s);\n"
  "  if (len < 2) {\n"
  "    return str_new(s);\n"
  "  }\n"
  "  ++s;\n"
  "  Buf *bf = buf_new();\n"
  "  while (*s) {\n"
  "    char ch = *s++;\n"
  "    if (ch != '\\\\') {\n"
  "      buf_cadd(bf, ch);\n"
  "    } else {\n"
  "      buf_cadd(bf, *s++);\n"
  "    }\n"
  "  }\n"
  "  return str_left(buf_str(bf), buf_len(bf) - 1);\n"
  "}\n"
  "static char *str_from_iso (char *s) {\n"
  "  Buf *bf = buf_new();\n"
  "  unsigned char ch = *s++;\n"
  "  while (ch) {\n"
  "    if(ch < 0x80) {\n"
  "      buf_cadd(bf, ch);\n"
  "    } else {\n"
  "      buf_cadd(bf, 0xc0 | (ch & 0xc0) >> 6);\n"
  "      buf_cadd(bf, 0x80 | (ch & 0x3f));\n"
  "    }\n"
  "    ch = *s++;\n"
  "  }\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "static char *str_from_unicode (unsigned *u) {\n"
  "  Buf *bf = buf_new();\n"
  "  while (*u) {\n"
  "    unsigned code_point = *u++;\n"
  "    if (code_point < 0x80) {\n"
  "      buf_cadd(bf, (unsigned char)code_point);\n"
  "    } else if (code_point <= 0x7FF) {\n"
  "      buf_cadd(bf, (unsigned char)(code_point >> 6) + 0xC0);\n"
  "      buf_cadd(bf, (unsigned char)(code_point & 0x3F) + 0x80);\n"
  "    } else if (code_point <= 0xFFFF) {\n"
  "      buf_cadd(bf, (unsigned char)(code_point >> 12) + 0xE0);\n"
  "      buf_cadd(bf, (unsigned char)((code_point >> 6) & 0x3F) + 0x80);\n"
  "      buf_cadd(bf, (unsigned char)(code_point & 0x3F) + 0x80);\n"
  "    } else if (code_point <= 0x10FFFF) {\n"
  "      buf_cadd(bf, (unsigned char)(code_point >> 18) + 0xF0);\n"
  "      buf_cadd(bf, (unsigned char)((code_point >> 12) & 0x3F) + 0x80);\n"
  "      buf_cadd(bf, (unsigned char)((code_point >> 6) & 0x3F) + 0x80);\n"
  "      buf_cadd(bf, (unsigned char)(code_point & 0x3F) + 0x80);\n"
  "    } else {\n"
  "      buf_add(bf, \"ï¿½\");\n"
  "    }\n"
  "  }\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "static char *str_from_utf16 (Arri *codepoints) {\n"
  "  int sz = tarr_sizeI(codepoints);\n"
  "  unsigned *u = ATOMIC(sz * sizeof(unsigned) + 1);\n"
  "  unsigned *p = u;\n"
  "  int64_t *begin = tarr_beginI(codepoints);\n"
  "  int64_t *end = tarr_endI(codepoints);\n"
  "  while(begin < end) {\n"
  "    *p++ = (unsigned) *begin++;\n"
  "  }\n"
  "  *p = 0;\n"
  "  return str_from_unicode(u);\n"
  "}\n"
  "static char *str_get (char *str, int64_t ix) {\n"
  "  texc_check_range(\"str_get\", 0, strlen(str) - 1, ix);\n"
  "  return str_new_c(str[ix]);\n"
  "}\n"
  "static int str_index (char *str, char *substr) {\n"
  "  if (!*substr) {\n"
  "    return 0;\n"
  "  }\n"
  "  int c = 0;\n"
  "  int limit = strlen(str) - strlen(substr);\n"
  "  char *p  = str;\n"
  "  for (;;) {\n"
  "    if (c > limit) {\n"
  "      break;\n"
  "    }\n"
  "    if (str_starts(p++, substr)) {\n"
  "      return c;\n"
  "    };\n"
  "    ++c;\n"
  "  }\n"
  "  return -1;\n"
  "}\n"
  "static int str_index_from (char *str, char *substr, int64_t from) {\n"
  "  if (from >= strlen(str)) {\n"
  "    return -1;\n"
  "  }\n"
  "  if (!*substr) {\n"
  "    return from;\n"
  "  }\n"
  "  int c = from;\n"
  "  int limit = strlen(str) - strlen(substr);\n"
  "  char *p  = str + from;\n"
  "  for (;;) {\n"
  "    if (c > limit) {\n"
  "      break;\n"
  "    }\n"
  "    if (str_starts(p++, substr)) {\n"
  "      return c;\n"
  "    };\n"
  "    ++c;\n"
  "  }\n"
  "  return -1;\n"
  "}\n"
  "static int str_last_cindex (char *str, char ch) {\n"
  "  int r = -1;\n"
  "  int c = 0;\n"
  "  char *p  = str;\n"
  "  while (*p) {\n"
  "    if (*p++ == ch) {\n"
  "      r = c;\n"
  "    };\n"
  "    ++c;\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "static int str_last_index (char *str, char *substr) {\n"
  "  int r = -1;\n"
  "  if (!*substr) {\n"
  "    return strlen(str);\n"
  "  }\n"
  "  int c = 0;\n"
  "  int limit = strlen(str) - strlen(substr);\n"
  "  char *p  = str;\n"
  "  while (*p) {\n"
  "    if (c > limit) {\n"
  "      break;\n"
  "    }\n"
  "    if (str_starts(p++, substr)) {\n"
  "      r = c;\n"
  "    };\n"
  "    ++c;\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "static char *str_left (char *str, int64_t end) {\n"
  "  return str_sub(str, 0, end);\n"
  "}\n"
  "static char *str_ltrim (char *str) {\n"
  "  unsigned char ch = *str;\n"
  "  while (ch && ch <= ' ') ch = *++str;\n"
  "  return str_new(str);\n"
  "}\n"
  "static char *str_new (char *s) {\n"
  "  char *r = ATOMIC(strlen(s) + 1);\n"
  "  strcpy(r, s);\n"
  "  return r;\n"
  "}\n"
  "static char *str_new_c (char ch) {\n"
  "  char *r = ATOMIC(2);\n"
  "  *r = ch;\n"
  "  r[1] = 0;\n"
  "  return r;\n"
  "}\n"
  "static char *str_replace(char *s, char *old, char *new) {\n"
  "  if (!*old) return str_new(s);\n"
  "\n"
  "  Buf *bf = buf_new();\n"
  "  int len = strlen(old);\n"
  "  int i = str_index(s, old);\n"
  "  while (i != -1) {\n"
  "    buf_add(bf, str_left(s, i));\n"
  "    buf_add(bf, new);\n"
  "    s = s + i + len;\n"
  "    i = str_index(s, old);\n"
  "  }\n"
  "  buf_add(bf, s);\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "static char *str_right (char *str, int64_t begin) {\n"
  "  return str_sub(str, begin, strlen(str));\n"
  "}\n"
  "static char *str_next_rune2(char *s) {\n"
  "  unsigned char b1, b2, b3, b4;\n"
  "  b1 = *s++;\n"
  "  if (b1) {\n"
  "    if (b1 < 0xC2) {\n"
  "      return str_f(\"%c\", b1);\n"
  "    } else if (b1 < 0xE0) {\n"
  "      b2 = *s++;\n"
  "      if ((b2 & 0xC0) != 0x80) {\n"
  "        return \"??\";\n"
  "      }\n"
  "      return str_f(\"%c%c\", b1, b2);\n"
  "    } else if (b1 < 0xF0) {\n"
  "      b2 = *s++;\n"
  "      if ((b2 & 0xC0) != 0x80 ||\n"
  "          (b1 == 0xE0 && b2 < 0xA0)\n"
  "      ) {\n"
  "        return \"??\";\n"
  "      }\n"
  "      b3 = *s++;\n"
  "      if ((b3 & 0xC0) != 0x80) {\n"
  "        return \"??\";\n"
  "      }\n"
  "      return str_f(\"%c%c%c\", b1, b2, b3);\n"
  "    } else if (b1 < 0xF5) {\n"
  "      b2 = *s++;\n"
  "      if (((b2 & 0xC0) != 0x80) ||\n"
  "          (b1 == 0xF0 && b2 < 0x90) ||\n"
  "          (b1 == 0xF4 && b2 >= 0x90)\n"
  "      ) {\n"
  "        return \"??\";\n"
  "      }\n"
  "      b3 = *s++;\n"
  "      if ((b3 & 0xC0) != 0x80) {\n"
  "        return \"??\";\n"
  "      }\n"
  "      b4 = *s++;\n"
  "      if ((b4 & 0xC0) != 0x80) {\n"
  "        return \"??\";\n"
  "      }\n"
  "      return str_f(\"%c%c%c%c\", b1, b2, b3, b4);\n"
  "    } else {\n"
  "      return \"??\";\n"
  "    }\n"
  "  }\n"
  "  return \"\";\n"
  "}\n"
  "static char *str_next_rune (char **rune, char *s) {\n"
  "  char *r = str_next_rune2(s);\n"
  "  if (r[0] == '?' && r[1] == '?') {\n"
  "    *rune = str_new(\"ï¿½\");\n"
  "    return s + 1;\n"
  "  }\n"
  "  *rune = r;\n"
  "  return s + strlen(r);\n"
  "}\n"
  "static char *str_rtrim (char *str) {\n"
  "  char *p = str + (strlen(str) - 1);\n"
  "  while (p >= str && ((unsigned char)*p) <= ' ') {\n"
  "    --p;\n"
  "  }\n"
  "  return str_left(str, (p - str) + 1);\n"
  "}\n"
  "static Arrs *str_split (char *s, char *sep) {\n"
  "  Arrs *r = tarr_new_s();\n"
  "  int len = strlen(sep);\n"
  "  if (!len) return str_to_runes(s);\n"
  "  int i = str_index(s, sep);\n"
  "  while (i != -1) {\n"
  "    char *sub = ATOMIC(i + 1);\n"
  "    sub[i] = 0;\n"
  "    memcpy(sub, s, i);\n"
  "    tarr_pushS(r, sub);\n"
  "    s = s + i + len;\n"
  "    i = str_index(s, sep);\n"
  "  }\n"
  "  tarr_pushS(r, str_new(s));\n"
  "  return r;\n"
  "}\n"
  "static Arrs *str_split_trim (char *s, char *sep) {\n"
  "  Arrs *r = str_split(s, sep);\n"
  "  char **p = tarr_beginS(r);\n"
  "  char **end = tarr_endS(r);\n"
  "  while (p < end) {\n"
  "    *p = str_trim(*p);\n"
  "    ++p;\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "static int str_starts (char *str, char  *substr) {\n"
  "  while (*substr)\n"
  "    if (*str++ != *substr++) return 0;\n"
  "  return 1;\n"
  "}\n"
  "static char *str_sub (char *str, int64_t begin, int64_t end) {\n"
  "  int l = strlen(str);\n"
  "  if (begin < 0) begin = l + begin;\n"
  "  if (begin >= l) return \"\";\n"
  "  if (begin < 0) begin = 0;\n"
  "\n"
  "  if (end < 0) end = l + end;\n"
  "  if (end > l) end = l;\n"
  "  if (end <= 0) return \"\";\n"
  "\n"
  "  int new_l = end - begin;\n"
  "  if (new_l < 0) return \"\";\n"
  "\n"
  "  char *r = ATOMIC(new_l + 1);\n"
  "  r[new_l] = 0;\n"
  "  memcpy(r, str + begin, new_l);\n"
  "  return r;\n"
  "}\n"
  "static char *str_to_escape (char *s) {\n"
  "  Buf *bf = buf_new();\n"
  "  buf_cadd(bf, '\"');\n"
  "  while (*s) {\n"
  "    char ch = *s++;\n"
  "    if (ch == '\"' || ch == '\\\\') {\n"
  "      buf_cadd(bf, '\\\\');\n"
  "    }\n"
  "    buf_cadd(bf, ch);\n"
  "  }\n"
  "  buf_cadd(bf, '\"');\n"
  "\n"
  "  return str_new(buf_str(bf));\n"
  "}\n"
  "static char *str_to_lower (char *s) {\n"
  "  unsigned *ws = str_to_unicode(s);\n"
  "  unsigned *p = ws;\n"
  "  while (*p) {\n"
  "    *p = (unsigned)towlower(*p);\n"
  "    ++p;\n"
  "  }\n"
  "  return str_from_unicode(ws);\n"
  "}\n"
  "static Arrs *str_to_runes (char *s) {\n"
  "  Arrs *r = tarr_new_s();\n"
  "  char *rune;\n"
  "  while (*s) {\n"
  "    s = str_next_rune(&rune, s);\n"
  "    tarr_pushS(r, rune);\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "static unsigned *str_to_unicode (char *s0) {\n"
  "  unsigned char *s = (unsigned char *)s0;\n"
  "  unsigned b1, b2, b3, b4;\n"
  "  int lg = tarr_sizeS(str_to_runes(s0)) + 1;\n"
  "  unsigned *r = ATOMIC(lg * sizeof(unsigned));\n"
  "  unsigned *pr = r;\n"
  "  while (*s) {\n"
  "    b1 = *s++;\n"
  "    if (b1 < 0x80) *pr++ = b1;\n"
  "    else if (b1 < 0xC2) *pr++ = 65533;\n"
  "    else if (b1 < 0xE0) {\n"
  "      b2 = *s++;\n"
  "      if ((b2 & 0xC0) != 0x80) *pr++ = 65533;\n"
  "      *pr++ = (b1 << 6) + b2 - 0x3080;\n"
  "    } else if (b1 < 0xF0) {\n"
  "      b2 = *s++;\n"
  "      if ((b2 & 0xC0) != 0x80) *pr++ = 65533;\n"
  "      if (b1 == 0xE0 && b2 < 0xA0) *pr++ = 65533;\n"
  "      b3 = *s++;\n"
  "      if ((b3 & 0xC0) != 0x80) *pr++ = 65533;\n"
  "      *pr++ = (b1 << 12) + (b2 << 6) + b3 - 0xE2080;\n"
  "    } else if (b1 < 0xF5) {\n"
  "      b2 = *s++;\n"
  "      if ((b2 & 0xC0) != 0x80) *pr++ = 65533;\n"
  "      if (b1 == 0xF0 && b2 < 0x90) *pr++ = 65533;\n"
  "      if (b1 == 0xF4 && b2 >= 0x90) *pr++ = 65533;\n"
  "      b3 = *s++;\n"
  "      if ((b3 & 0xC0) != 0x80) *pr++ = 65533;\n"
  "      b4 = *s++;\n"
  "      if ((b4 & 0xC0) != 0x80) *pr++ = 65533;\n"
  "      *pr++ = (b1 << 18) + (b2 << 12) + (b3 << 6) + b4 - 0x3C82080;\n"
  "    } else {\n"
  "      *pr++ = 65533;\n"
  "    }\n"
  "  }\n"
  "  *pr = 0;\n"
  "  return r;\n"
  "}\n"
  "static char *str_to_upper (char *s) {\n"
  "  unsigned *ws = str_to_unicode(s);\n"
  "  unsigned *p = ws;\n"
  "  while (*p) {\n"
  "    *p = (unsigned)towupper(*p);\n"
  "    ++p;\n"
  "  }\n"
  "  return str_from_unicode(ws);\n"
  "}\n"
  "static Arri *str_to_utf16 (char *s) {\n"
  "  unsigned *u = str_to_unicode(s);\n"
  "  Arri *r = tarr_new_i();\n"
  "  while (*u) tarr_pushI(r, *u++);\n"
  "  return r;\n"
  "}\n"
  "static char *str_trim (char *s) {\n"
  "  unsigned char ch = *s;\n"
  "  while (ch && ch <= ' ') ch = *++s;\n"
  "  return str_rtrim(s);\n"
  "}\n"
  "static char *str_vf(char *format, va_list args) {\n"
  "  char *tmp;\n"
  "  int len = vasprintf(&tmp, format, args);\n"
  "  if (len < 0)\n"
  "    texc_throw(\n"
  "      \"str.f/str.vf\", str_f(\"Wrong format in:\\n  %s'\", format)\n"
  "    );\n"
  "  char *msg = ATOMIC(len + 1);\n"
  "  strcpy(msg, tmp);\n"
  "  free(tmp);\n"
  "  return msg;\n"
  "}\n"
  "\n"
"// sys.c ----------\n"
  "static void sys_assert (int value, char *pos) {\n"
  "  if (!value) texc_throw_(str_f(\"Assert failed\\n  %s\", pos));\n"
  "}\n"
  "static Arrs *sys_cmd (char *c, Arrs *params) {\n"
  "  Arrs *pars2 = tarr_new_s();\n"
  "  char **p = tarr_beginS(params);\n"
  "  char **end = tarr_endS(params);\n"
  "  while (p < end) tarr_pushS(pars2, str_to_escape(*p++));\n"
  "  tarr_unshiftS(pars2, c);\n"
  "  char *command = tarr_join(pars2, \" \");\n"
  "  Arrs *r;;\n"
  "  char *ferr = file_tmp(\"/tmp\", \"dmC\");\n"
  "  char *cmd = str_f(\"%s 2>%s\", command, ferr);\n"
  "  FILE *fp = popen(cmd, \"r\");\n"
  "  if (!fp) {\n"
  "    file_del(ferr);\n"
  "    return tarr_new_froms((char*[]){\"\", str_f(\"NOEXEC: '%s'\", command)}, 2);\n"
  "  }\n"
  "  Buf *bf = buf_new();\n"
  "  char *line = NULL;\n"
  "  size_t len = 0;\n"
  "  while (getline(&line, &len, fp) != -1) {\n"
  "    buf_add(bf, line);\n"
  "    free(line);\n"
  "    line = NULL;\n"
  "  }\n"
  "  free(line);\n"
  "  pclose(fp);\n"
  "  char *err = file_exists(ferr) ? file_read(ferr) : \"\";\n"
  "  file_del(ferr);\n"
  "  return tarr_new_froms((char*[]){str_new(buf_str(bf)), err}, 2);\n"
  "}\n"
  "static Arrs *sys_environ(void) {\n"
  "  Arrs *r = dic_new();\n"
  "  char **penv = environ;\n"
  "  while (*penv) {\n"
  "    Arrs *parts = str_split_trim(*penv++, \"=\");\n"
  "    dic_put(r, tarr_getS(parts, 0), tarr_getS(parts, 1));\n"
  "  }\n"
  "  return r;\n"
  "}\n"
  "static char *sys_get_locale (void) { return setlocale (LC_ALL, 0); }\n"
  "static char *sys_home (void) { dic_get_or_exc(sys_environ(), \"HOME\"); }\n"
  "static void sys_printb (int v) { printf(\"%s\", (built_to_strb(v))); }\n"
  "static void sys_printi (int64_t v) { printf(\"%s\", (built_to_stri(v))); }\n"
  "static void sys_printf (double v) { printf(\"%s\", (built_to_strf(v))); }\n"
  "static void sys_prints (char *v) { printf(\"%s\", (built_to_strs(v))); }\n"
  "static void sys_printI (Arri *v) { printf(\"%s\", (built_to_strI(v))); }\n"
  "static void sys_printF (Arrf *v) { printf(\"%s\", (built_to_strF(v))); }\n"
  "static void sys_printS (Arrs *v) { printf(\"%s\", (built_to_strS(v))); }\n"
  "static void sys_printD (Arrs *v) { printf(\"%s\", (built_to_strD(v))); }\n"
  "static void sys_print_errorb (int v) { fprintf(stderr, \"%s\", (built_to_strb(v))); }\n"
  "static void sys_print_errori (int64_t v) { fprintf(stderr, \"%s\", (built_to_stri(v))); }\n"
  "static void sys_print_errorf (double v) { fprintf(stderr, \"%s\", (built_to_strf(v))); }\n"
  "static void sys_print_errors (char *v) { fprintf(stderr, \"%s\", (built_to_strs(v))); }\n"
  "static void sys_print_errorI (Arri *v) { fprintf(stderr, \"%s\", (built_to_strI(v))); }\n"
  "static void sys_print_errorF (Arrf *v) { fprintf(stderr, \"%s\", (built_to_strF(v))); }\n"
  "static void sys_print_errorS (Arrs *v) { fprintf(stderr, \"%s\", (built_to_strS(v))); }\n"
  "static void sys_print_errorD (Arrs *v) { fprintf(stderr, \"%s\", (built_to_strD(v))); }\n"
  "static void sys_printlnb (int v) { puts(built_to_strb(v)); }\n"
  "static void sys_printlni (int64_t v) { puts(built_to_stri(v)); }\n"
  "static void sys_printlnf (double v) { puts(built_to_strf(v)); }\n"
  "static void sys_printlns (char * v) { puts(built_to_strs(v)); }\n"
  "static void sys_printlnI (Arri* v) { puts(built_to_strI(v)); }\n"
  "static void sys_printlnF (Arrf* v) { puts(built_to_strF(v)); }\n"
  "static void sys_printlnS (Arrs* v) { puts(built_to_strS(v)); }\n"
  "static void sys_printlnD (Arrs* v) { puts(built_to_strD(v)); }\n"
  "static char *sys_read_line (void) {\n"
  "  char *s = malloc(150);\n"
  "  size_t n = 150;\n"
  "  if (getline(&s, &n, stdin) == -1) {\n"
  "    free(s); // correct\n"
  "    texc_throw(\"sys.readLine\", \"Fail reading on console\");\n"
  "  }\n"
  "  char *r = str_left(s, -1);\n"
  "  free(s);  // correct\n"
  "  return r;\n"
  "}\n"
  "static void sys_set_locale (char * lang) { setlocale (LC_ALL, lang); }\n"
  "#define sys_TEST(fneq, fstr) \\\n"
  "  if (fneq(v1, v2)) \\\n"
  "    texc_throw_(str_f( \\\n"
  "      \"Test failed\\n\" \\\n"
  "      \"  Expected: %s\\n\" \\\n"
  "      \"    Actual: %s\\n\" \\\n"
  "      \"  %s\", \\\n"
  "      fstr(v2), fstr(v1), pos \\\n"
  "    ));\n"
  "static void sys_sleep (int64_t millis) {\n"
  "  int64_t end = time_now() + millis;\n"
  "  struct timespec t;\n"
  "  struct timespec rem;\n"
  "  for (;;) {\n"
  "    t.tv_sec = millis / 1000;\n"
  "    t.tv_nsec = (millis % 1000) * 1000000;\n"
  "    if (nanosleep(&t, &rem)) {\n"
  "      millis = end - time_now();\n"
  "      if (millis <= 0) break;\n"
  "    } else {\n"
  "      break;\n"
  "    }\n"
  "  }\n"
  "}\n"
  "static void sys_testb (int v1, int v2, char *pos) {\n"
  "  sys_TEST(built_neqb, built_to_strb)\n"
  "}\n"
  "static void sys_testi (int64_t v1, int64_t v2, char *pos) {\n"
  "  sys_TEST(built_neqi, built_to_stri)\n"
  "}\n"
  "static void sys_testf (double v1, double v2, char *pos) {\n"
  "  sys_TEST(built_neqf, built_to_strf)\n"
  "}\n"
  "static void sys_tests (char *v1, char *v2, char *pos) {\n"
  "  sys_TEST(built_neqs, built_to_strs)\n"
  "}\n"
  "static void sys_testo (Obj *v1, Obj *v2, char *pos) {\n"
  "  sys_TEST(built_neqo, built_to_stro)\n"
  "}\n"
  "static void sys_testI (Arri *v1, Arri *v2, char *pos) {\n"
  "  sys_TEST(built_neqI, built_to_strI)\n"
  "}\n"
  "static void sys_testF (Arrf *v1, Arrf *v2, char *pos) {\n"
  "  sys_TEST(built_neqF, built_to_strF)\n"
  "}\n"
  "static void sys_testS (Arrs *v1, Arrs *v2, char *pos) {\n"
  "  sys_TEST(built_neqS, built_to_strS)\n"
  "}\n"
  "static void sys_testD (Arrs *v1, Arrs *v2, char *pos) {\n"
  "  sys_TEST(built_neqD, built_to_strD)\n"
  "}\n"
  "#undef sys_TEST\n"
  "static void sys_throw (char *fn, char *msg, char *pos) {\n"
  "  texc_throw_(str_f(\"%s\\n  %s\", msg, pos));\n"
  "}\n"
  "static void sys_used(void){}\n"
  "static char *sys_user (void) { dic_get_or_exc(sys_environ(), \"USER\"); }\n"
  "\n"
"// tarr.c ----------\n"
  "struct tarr_Arri {\n"
  "  int64_t *begin;\n"
  "  int64_t *end;\n"
  "  int64_t *bf;\n"
  "};\n"
  "struct tarr_Arrf {\n"
  "  double *begin;\n"
  "  double *end;\n"
  "  double *bf;\n"
  "};\n"
  "struct tarr_Arrs {\n"
  "  char **begin;\n"
  "  char **end;\n"
  "  char **bf;\n"
  "};\n"
  "struct tarr_Arr {\n"
  "  void **begin;\n"
  "  void **end;\n"
  "  void **bf;\n"
  "};\n"
  "\n"
  "static int64_t *tarr_beginI (Arri *this) { return this->begin; }\n"
  "static double *tarr_beginF (Arrf *this) { return this->begin; }\n"
  "static char **tarr_beginS (Arrs *this) { return this->begin; }\n"
  "#define tarr_CAT(Vtype) \\\n"
  "  int other_len = other->end - other->begin; \\\n"
  "  if (other_len) { \\\n"
  "    int this_len = this->end - this->begin; \\\n"
  "    int this_size = this->bf - this->begin; \\\n"
  "    if (this_len + other_len >= this_size){ \\\n"
  "      int new_size = this_size + other_len; \\\n"
  "      this->begin = GC_REALLOC(this->begin, new_size * sizeof(Vtype)); \\\n"
  "      this->end = this->begin + this_len; \\\n"
  "      this->bf = this->begin + new_size; \\\n"
  "    } \\\n"
  "    Vtype *s = other->begin; \\\n"
  "    Vtype *t = this->end; \\\n"
  "    while (s < other->end) *t++ = *s++; \\\n"
  "    this->end = t; \\\n"
  "  }\n"
  "static void tarr_catI (Arri *this, Arri *other) { tarr_CAT(int64_t) }\n"
  "static void tarr_catF (Arrf *this, Arrf *other) { tarr_CAT(double) }\n"
  "static void tarr_catS (Arrs *this, Arrs *other) { tarr_CAT(char*) }\n"
  "#undef tarr_CAT\n"
  "static void tarr_clearI (Arri *this) {\n"
  "  this->end = this->begin;\n"
  "}\n"
  "static void tarr_clearF (Arrf *this) {\n"
  "  this->end = this->begin;\n"
  "}\n"
  "static void tarr_clearS (Arrs *this) {\n"
  "  this->end = this->begin;\n"
  "}\n"
  "static Arri *tarr_concatI (Arri *this, Arri *other) {\n"
  "  Arri *r = tarr_copyI(this);\n"
  "  tarr_catI(r, other);\n"
  "  return r;\n"
  "}\n"
  "static Arrf *tarr_concatF (Arrf *this, Arrf *other) {\n"
  "  Arrf *r = tarr_copyF(this);\n"
  "  tarr_catF(r, other);\n"
  "  return r;\n"
  "}\n"
  "static Arrs *tarr_concatS (Arrs *this, Arrs *other) {\n"
  "  Arrs *r = tarr_copyS(this);\n"
  "  tarr_catS(r, other);\n"
  "  return r;\n"
  "}\n"
  "static int tarr_containsI (Arri *this, int64_t e) {\n"
  "  int64_t *p = this->begin; int64_t *end = this->end;\n"
  "  while (p < end) if (*p++ == e) return 1;\n"
  "  return 0;\n"
  "}\n"
  "static int tarr_containsF (Arrf *this, double e) {\n"
  "  double *p = this->begin; double *end = this->end;\n"
  "  while (p < end) if (math_eq(*p++, e)) return 1;\n"
  "  return 0;\n"
  "}\n"
  "static int tarr_containsS (Arrs *this, char *e) {\n"
  "  char **p = this->begin; char **end = this->end;\n"
  "  while (p < end) if (!strcmp(*p++, e)) return 1;\n"
  "  return 0;\n"
  "}\n"
  "#define tarr_COPY(Atype, Vtype, ALLOC_fn) \\\n"
  "  int size = this->end - this->begin; \\\n"
  "  int bf_size = this->bf - this->begin; \\\n"
  "  Atype *a = MALLOC(Atype); \\\n"
  "  a->begin = ALLOC_fn(sizeof(Vtype) * bf_size); \\\n"
  "  a->end = a->begin + size; \\\n"
  "  a->bf = a->begin + bf_size; \\\n"
  "  memcpy(a->begin, this->begin, sizeof(Vtype) * size); \\\n"
  "  return a;\n"
  "static Arri *tarr_copyI (Arri *this) { tarr_COPY(Arri, int64_t, ATOMIC) }\n"
  "static Arrf *tarr_copyF (Arrf *this) { tarr_COPY(Arrf, double, ATOMIC) }\n"
  "static Arrs *tarr_copyS (Arrs *this) { tarr_COPY(Arrs, char*, GC_MALLOC) }\n"
  "#undef tarr_COPY\n"
  "#define tarr_DROP(Atype, Vtype, ALLOC_fn) \\\n"
  "  int size = this->end - this->begin; \\\n"
  "  if (n < 0) n = 0; \\\n"
  "  else if (n > size) n = size; \\\n"
  "  int new_size = size - n; \\\n"
  "  Atype *r = MALLOC(Atype); \\\n"
  "  int bf_size = this->bf - this->begin; \\\n"
  "  r->begin = ALLOC_fn(sizeof(Vtype) * bf_size); \\\n"
  "  r->end = r->begin + new_size; \\\n"
  "  r->bf = r->begin + bf_size; \\\n"
  "  if (new_size > 0) memcpy(r->begin, this->begin + n, sizeof(Vtype) * new_size); \\\n"
  "  return r;\n"
  "static Arri *tarr_dropI (Arri *this, int64_t n) { tarr_DROP(Arri, int64_t, ATOMIC) }\n"
  "static Arrf *tarr_dropF (Arrf *this, int64_t n) { tarr_DROP(Arrf, double, ATOMIC) }\n"
  "static Arrs *tarr_dropS (Arrs *this, int64_t n) { tarr_DROP(Arrs, char*, GC_MALLOC) }\n"
  "#undef tarr_DROP\n"
  "#define tarr_DUPLICATES(Atype, Vtype, copy_fn, new_fn, clear_fn, eq_fn, push_fn) \\\n"
  "  Atype *old = copy_fn(this); \\\n"
  "  Atype *dup = new_fn(); \\\n"
  "  clear_fn(this); \\\n"
  "  Vtype *pold = old->begin; \\\n"
  "  Vtype *end_old = old->end; \\\n"
  "  while (pold < end_old) { \\\n"
  "    Vtype e = *pold++; \\\n"
  "    Vtype *pdup = dup->begin; \\\n"
  "    Vtype *end_dup = dup->end; \\\n"
  "    int is_dup = 0; \\\n"
  "    while (pdup < end_dup) \\\n"
  "      if (eq_fn(*pdup++, e)) { is_dup = 1; break; } \\\n"
  "    if (is_dup) continue; \\\n"
  "    Vtype *p = this->begin; \\\n"
  "    Vtype *end = this->end; \\\n"
  "    while (p < end) \\\n"
  "      if (eq_fn(*p++, e)) { is_dup = 1; break; } \\\n"
  "    if (is_dup) push_fn(dup, e); \\\n"
  "    else push_fn(this, e); \\\n"
  "  } \\\n"
  "  return dup;\n"
  "static Arri *tarr_duplicatesI (Arri *this) {\n"
  "  tarr_DUPLICATES(\n"
  "    Arri, int64_t, tarr_copyI, tarr_new_i, tarr_clearI, built_eqi, tarr_pushI\n"
  "  )\n"
  "}\n"
  "static Arrf *tarr_duplicatesF (Arrf *this) {\n"
  "  tarr_DUPLICATES(\n"
  "    Arrf, double, tarr_copyF, tarr_new_f, tarr_clearF, built_eqf, tarr_pushF\n"
  "  )\n"
  "}\n"
  "static Arrs *tarr_duplicatesS (Arrs *this) {\n"
  "  tarr_DUPLICATES(\n"
  "    Arrs, char*, tarr_copyS, tarr_new_s, tarr_clearS, built_eqs, tarr_pushS\n"
  "  )\n"
  "}\n"
  "#undef tarr_DUPLICATES\n"
  "static int64_t *tarr_endI (Arri *this) { return this->end; }\n"
  "static double *tarr_endF (Arrf *this) { return this->end; }\n"
  "static char **tarr_endS (Arrs *this) { return this->end; }\n"
  "static int tarr_empty (Arr *this) { return this->begin == this->end; }\n"
  "static int tarr_emptyI (Arri *this) { return this->begin == this->end; }\n"
  "static int tarr_emptyF (Arrf *this) { return this->begin == this->end; }\n"
  "static int tarr_emptyS (Arrs *this) { return this->begin == this->end; }\n"
  "static int64_t tarr_getI (Arri *this, int64_t ix) {\n"
  "  texc_check_range(\"arr.get\", 0, (this->end - this->begin) - 1, ix);\n"
  "  return *(this->begin + ix);\n"
  "}\n"
  "static double tarr_getF (Arrf *this, int64_t ix) {\n"
  "  texc_check_range(\"arr.get\", 0, (this->end - this->begin) - 1, ix);\n"
  "  return *(this->begin + ix);\n"
  "}\n"
  "static char *tarr_getS (Arrs *this, int64_t ix) {\n"
  "  texc_check_range(\"arr.get\", 0, (this->end - this->begin) - 1, ix);\n"
  "  return *(this->begin + ix);\n"
  "}\n"
  "static int64_t tarr_indexI (Arri *this, int64_t e) {\n"
  "  int64_t *p = this->begin; int64_t *end = this->end;\n"
  "  while (p < end) if (*p++ == e) return (p - this->begin) - 1;\n"
  "  return -1;\n"
  "}\n"
  "static int64_t tarr_indexF (Arrf *this, double e) {\n"
  "  double *p = this->begin; double *end = this->end;\n"
  "  while (p < end) if (math_eq(*p++, e)) return (p - this->begin) - 1;\n"
  "  return -1;\n"
  "}\n"
  "static int64_t tarr_indexS (Arrs *this, char *e) {\n"
  "  char **p = this->begin; char **end = this->end;\n"
  "  while (p < end) if (!strcmp(*p++, e)) return (p - this->begin) - 1;\n"
  "  return -1;\n"
  "}\n"
  "#define tarr_INSERT(Atype, Vtype, fn_push) \\\n"
  "  texc_check_range(\"arr.insert\", 0, this->end - this->begin, ix); \\\n"
  "  fn_push(this, e); \\\n"
  "  Vtype *p = this->end - 1; \\\n"
  "  Vtype *end = this->begin + ix; \\\n"
  "  while (p > end) { \\\n"
  "    *p = *(p - 1); \\\n"
  "    --p; \\\n"
  "  } \\\n"
  "  *end = e;\n"
  "static void tarr_insertI (Arri *this, int64_t ix, int64_t e) {\n"
  "  tarr_INSERT(Arri, int64_t, tarr_pushI);\n"
  "}\n"
  "static void tarr_insertF (Arrf *this, int64_t ix, double e) {\n"
  "  tarr_INSERT(Arrf, double, tarr_pushF);\n"
  "}\n"
  "static void tarr_insertS (Arrs *this, int64_t ix, char *e) {\n"
  "  tarr_INSERT(Arrs, char*, tarr_pushS);\n"
  "}\n"
  "#undef tarr_INSERT\n"
  "static void tarr_insert_arrayI (Arri *this, int64_t ix, Arri *other) {\n"
  "  tarr_insert_rangeI(this, ix, other, 0, tarr_sizeI(other));\n"
  "}\n"
  "static void tarr_insert_arrayF (Arrf *this, int64_t ix, Arrf *other) {\n"
  "  tarr_insert_rangeF(this, ix, other, 0, tarr_sizeF(other));\n"
  "}\n"
  "static void tarr_insert_arrayS (Arrs *this, int64_t ix, Arrs *other) {\n"
  "  tarr_insert_rangeS(this, ix, other, 0, tarr_sizeS(other));\n"
  "}\n"
  "#define tarr_INSERT_RANGE(Atype, Vtype, fn_drop, fn_size, fn_set_range, fn_set_array) \\\n"
  "  Atype *tmp = fn_drop(this, ix); \\\n"
  "  int64_t size = fn_size(this) + end - begin; \\\n"
  "  int64_t bf = size + 15; \\\n"
  "  this->begin = GC_REALLOC(this->begin, bf * sizeof(Vtype)); \\\n"
  "  this->end = this->begin + size; \\\n"
  "  this->bf = this->begin + bf; \\\n"
  "  fn_set_range(this, ix, other, begin, end); \\\n"
  "  fn_set_array(this, ix + end - begin, tmp);\n"
  "static void tarr_insert_rangeI (\n"
  "  Arri *this, int64_t ix, Arri *other, int64_t begin, int64_t end\n"
  ") {\n"
  "  tarr_INSERT_RANGE(\n"
  "    Arri, int64_t, tarr_dropI, tarr_sizeI, tarr_set_rangeI, tarr_set_arrayI\n"
  "  );\n"
  "}\n"
  "static void tarr_insert_rangeF (\n"
  "  Arrf *this, int64_t ix, Arrf *other, int64_t begin, int64_t end\n"
  ") {\n"
  "  tarr_INSERT_RANGE(\n"
  "    Arrf, double, tarr_dropF, tarr_sizeF, tarr_set_rangeF, tarr_set_arrayF\n"
  "  );\n"
  "}\n"
  "static void tarr_insert_rangeS (\n"
  "  Arrs *this, int64_t ix, Arrs *other, int64_t begin, int64_t end\n"
  ") {\n"
  "  tarr_INSERT_RANGE(\n"
  "    Arrs, char*, tarr_dropS, tarr_sizeS, tarr_set_rangeS, tarr_set_arrayS\n"
  "  );\n"
  "}\n"
  "#undef tarr_INSERT_RANGE\n"
  "static int64_t tarr_ix_correctI (Arri *this, int64_t n) {\n"
  "  return n < 0 ? (this->end - this->begin) + n : n;\n"
  "}\n"
  "static int64_t tarr_ix_correctF (Arrf *this, int64_t n) {\n"
  "  return n < 0 ? (this->end - this->begin) + n : n;\n"
  "}\n"
  "static int64_t tarr_ix_correctS (Arrs *this, int64_t n) {\n"
  "  return n < 0 ? (this->end - this->begin) + n : n;\n"
  "}\n"
  "static char *tarr_join (Arrs *this, char *sep) {\n"
  "  Buf *bf = buf_new();\n"
  "  int first = 1;\n"
  "  char **p = (char **)this->begin;\n"
  "  while (p < (char **)this->end) {\n"
  "    if (first) {\n"
  "      first = 0;\n"
  "    } else {\n"
  "      buf_add(bf, sep);\n"
  "    }\n"
  "    buf_add(bf, *p++);\n"
  "  }\n"
  "  char *r = str_new(buf_str(bf));\n"
  "  return r;\n"
  "}\n"
  "#define tarr_NEW(Atype, Vtype, ALLOC_fn) \\\n"
  "  Atype *this = MALLOC(Atype); \\\n"
  "  this->begin = ALLOC_fn(sizeof(Vtype) * 15); \\\n"
  "  this->end = this->begin; \\\n"
  "  this->bf = this->begin + 15; \\\n"
  "  return this;\n"
  "static Arr *tarr_new_ (void) { tarr_NEW(Arr, void*, GC_MALLOC) }\n"
  "static Arri *tarr_new_i (void) { tarr_NEW(Arri, int64_t, ATOMIC) }\n"
  "static Arrf *tarr_new_f (void) { tarr_NEW(Arrf, double, ATOMIC) }\n"
  "static Arrs *tarr_new_s (void) { tarr_NEW(Arrs, char*, GC_MALLOC) }\n"
  "#undef tarr_NEW\n"
  "#define tarr_NEW_FROM_C(Atype, Vtype, ALLOC_fn) \\\n"
  "  int bf_size = n < 15 ? 15 : n; \\\n"
  "  Atype *this = MALLOC(Atype); \\\n"
  "  this->begin = ALLOC_fn(sizeof(Vtype) * bf_size); \\\n"
  "  memcpy(this->begin, es, sizeof(Vtype) * n); \\\n"
  "  this->end = this->begin + n; \\\n"
  "  this->bf = this->begin + bf_size; \\\n"
  "  return this;\n"
  "static Arri *tarr_new_fromi (int64_t *es, int64_t n) {\n"
  "  tarr_NEW_FROM_C(Arri, int64_t, ATOMIC)\n"
  "}\n"
  "static Arrf *tarr_new_fromf (double *es, int64_t n) {\n"
  "  tarr_NEW_FROM_C(Arrf, double, ATOMIC)\n"
  "}\n"
  "static Arrs *tarr_new_froms (char **es, int64_t n) {\n"
  "  tarr_NEW_FROM_C(Arrs, char*, GC_MALLOC)\n"
  "}\n"
  "#undef tarr_NEW_FROM_C\n"
  "static Arri *tarr_newi (int64_t e, int64_t n) {\n"
  "  if (n < 0) n = 0;\n"
  "  int64_t *es = ATOMIC(sizeof(int64_t) * n);\n"
  "  int64_t *p = es;\n"
  "  int64_t *end = es + n;\n"
  "  while (p < end) *p++ = e;\n"
  "  return tarr_new_fromi(es, n);\n"
  "}\n"
  "static Arrf *tarr_newf (double e, int64_t n) {\n"
  "  if (n < 0) n = 0;\n"
  "  double *es = ATOMIC(sizeof(double) * n);\n"
  "  double *p = es;\n"
  "  double *end = es + n;\n"
  "  while (p < end) *p++ = e;\n"
  "  return tarr_new_fromf(es, n);\n"
  "}\n"
  "static Arrs *tarr_news (char *e, int64_t n) {\n"
  "  if (n < 0) n = 0;\n"
  "  char **es = ATOMIC(sizeof(char **) * n);\n"
  "  char **p = es;\n"
  "  char **end = es + n;\n"
  "  while (p < end) *p++ = e;\n"
  "  return tarr_new_froms(es, n);\n"
  "}\n"
  "#define tarr_PEEK \\\n"
  "  if (this->begin == this->end) texc_throw(\"arr.peek\", \"Array is empty\"); \\\n"
  "  return *(this->end - 1);\n"
  "static void *tarr_peek (Arr *this) { tarr_PEEK }\n"
  "static int64_t tarr_peekI (Arri *this)  { tarr_PEEK }\n"
  "static double tarr_peekF (Arrf *this)  { tarr_PEEK }\n"
  "static char *tarr_peekS (Arrs *this) { tarr_PEEK }\n"
  "#undef tarr_PEEK\n"
  "#define tarr_POP \\\n"
  "  if (this->begin == this->end) texc_throw(\"arr.pop\", \"Array is empty\"); \\\n"
  "  return *(--this->end);\n"
  "static void *tarr_pop (Arr *this) { tarr_POP }\n"
  "static int64_t tarr_popI (Arri *this) { tarr_POP }\n"
  "static double tarr_popF (Arrf *this) { tarr_POP }\n"
  "static char *tarr_popS (Arrs *this) { tarr_POP }\n"
  "#undef tarr_POP\n"
  "#define tarr_PUSH(Vtype) \\\n"
  "  if (this->end == this->bf) { \\\n"
  "    int size = this->bf - this->begin; \\\n"
  "    int new_size = size + size; \\\n"
  "    this->begin = GC_REALLOC(this->begin, new_size * sizeof(Vtype)); \\\n"
  "    this->end = this->begin + size; \\\n"
  "    this->bf = this->begin + new_size; \\\n"
  "  } \\\n"
  "  *this->end++ = e;\n"
  "static void tarr_push (Arr *this, void *e) { tarr_PUSH(void *); }\n"
  "static void tarr_pushI (Arri *this, int64_t e) { tarr_PUSH(int64_t); }\n"
  "static void tarr_pushF (Arrf *this, double e) { tarr_PUSH(double); }\n"
  "static void tarr_pushS (Arrs *this, char *e) { tarr_PUSH(char *); }\n"
  "#undef tarr_PUSH\n"
  "#define tarr_REMOVE(Atype, Vtype, copy_fn, clear_fn, cat_fn, take_fn, drop_fn) \\\n"
  "  texc_check_range(\"arr.remove\", 0, (this->end - this->begin) - 1, ix); \\\n"
  "  Vtype r = *(this->begin + ix); \\\n"
  "  Atype *tmp = copy_fn(this); \\\n"
  "  clear_fn(this); \\\n"
  "  cat_fn(this, take_fn(tmp, ix)); \\\n"
  "  cat_fn(this, drop_fn(tmp, ix + 1)); \\\n"
  "  return r;\n"
  "static int64_t tarr_removeI (Arri *this, int64_t ix) {\n"
  "  tarr_REMOVE(\n"
  "    Arri, int64_t, tarr_copyI, tarr_clearI, tarr_catI, tarr_takeI, tarr_dropI\n"
  "  )\n"
  "}\n"
  "static double tarr_removeF (Arrf *this, int64_t ix) {\n"
  "  tarr_REMOVE(\n"
  "    Arrf, double, tarr_copyF, tarr_clearF, tarr_catF, tarr_takeF, tarr_dropF\n"
  "  )\n"
  "}\n"
  "static char *tarr_removeS (Arrs *this, int64_t ix) {\n"
  "  tarr_REMOVE(\n"
  "    Arrs, char *, tarr_copyS, tarr_clearS, tarr_catS, tarr_takeS, tarr_dropS\n"
  "  )\n"
  "}\n"
  "#undef tarr_REMOVE\n"
  "#define tarr_REMOVE_RANGE(Atype, copy_fn, clear_fn, cat_fn, take_fn, drop_fn) \\\n"
  "  texc_check_range(\"arr.removeRange\", 0, (this->end - this->begin), end); \\\n"
  "  texc_check_range(\"arr.removeRange\", 0, end, begin); \\\n"
  "  Atype *r = drop_fn(take_fn(this, end), begin); \\\n"
  "  Atype *tmp = copy_fn(this); \\\n"
  "  clear_fn(this); \\\n"
  "  cat_fn(this, take_fn(tmp, begin)); \\\n"
  "  cat_fn(this, drop_fn(tmp, end)); \\\n"
  "  return r;\n"
  "static Arri *tarr_remove_rangeI (Arri *this, int64_t begin, int64_t end) {\n"
  "  tarr_REMOVE_RANGE(\n"
  "    Arri, tarr_copyI, tarr_clearI, tarr_catI, tarr_takeI, tarr_dropI\n"
  "  )\n"
  "}\n"
  "static Arrf *tarr_remove_rangeF (Arrf *this, int64_t begin, int64_t end) {\n"
  "  tarr_REMOVE_RANGE(\n"
  "    Arrf, tarr_copyF, tarr_clearF, tarr_catF, tarr_takeF, tarr_dropF\n"
  "  )\n"
  "}\n"
  "static Arrs *tarr_remove_rangeS (Arrs *this, int64_t begin, int64_t end) {\n"
  "  tarr_REMOVE_RANGE(\n"
  "    Arrs, tarr_copyS, tarr_clearS, tarr_catS, tarr_takeS, tarr_dropS\n"
  "  )\n"
  "}\n"
  "#undef tarr_REMOVE_RANGE\n"
  "static Arri *tarr_reverseI (Arri *this) {\n"
  "  Arri *r = tarr_copyI(this);\n"
  "  tarr_reverse_inI(r);\n"
  "  return r;\n"
  "}\n"
  "static Arrf *tarr_reverseF (Arrf *this) {\n"
  "  Arrf *r = tarr_copyF(this);\n"
  "  tarr_reverse_inF(r);\n"
  "  return r;\n"
  "}\n"
  "static Arrs *tarr_reverseS (Arrs *this) {\n"
  "  Arrs *r = tarr_copyS(this);\n"
  "  tarr_reverse_inS(r);\n"
  "  return r;\n"
  "}\n"
  "#define tarr_REVERSE_IN(Vtype) \\\n"
  "  Vtype *p = this->begin; \\\n"
  "  Vtype *end = this->end - 1; \\\n"
  "  int size2 = (this->end - this->begin) / 2; \\\n"
  "  Vtype tmp; \\\n"
  "  for (int i = 0; i < size2; ++i) { \\\n"
  "    tmp = *p; \\\n"
  "    *p++ = *end; \\\n"
  "    *end-- = tmp; \\\n"
  "  }\n"
  "static void tarr_reverse_inI (Arri *this) { tarr_REVERSE_IN(int64_t) }\n"
  "static void tarr_reverse_inF (Arrf *this) { tarr_REVERSE_IN(double) }\n"
  "static void tarr_reverse_inS (Arrs *this) { tarr_REVERSE_IN(char*) }\n"
  "#undef tarr_REVERSE_IN\n"
  "static void tarr_setI (Arri *this, int64_t ix, int64_t e) {\n"
  "  texc_check_range(\"arr.set\", 0, (this->end - this->begin) - 1, ix);\n"
  "  *(this->begin + ix) = e;\n"
  "}\n"
  "static void tarr_setF (Arrf *this, int64_t ix, double e) {\n"
  "  texc_check_range(\"arr.set\", 0, (this->end - this->begin) - 1, ix);\n"
  "  *(this->begin + ix) = e;\n"
  "}\n"
  "static void tarr_setS (Arrs *this, int64_t ix, char *e) {\n"
  "  texc_check_range(\"arr.set\", 0, (this->end - this->begin) - 1, ix);\n"
  "  *(this->begin + ix) = e;\n"
  "}\n"
  "static void tarr_set_arrayI (Arri *this, int64_t ix, Arri *other) {\n"
  "  tarr_set_rangeI(this, ix, other, 0, tarr_sizeI(other));\n"
  "}\n"
  "static void tarr_set_arrayF (Arrf *this, int64_t ix, Arrf *other) {\n"
  "  tarr_set_rangeF(this, ix, other, 0, tarr_sizeF(other));\n"
  "}\n"
  "static void tarr_set_arrayS (Arrs *this, int64_t ix, Arrs *other) {\n"
  "  tarr_set_rangeS(this, ix, other, 0, tarr_sizeS(other));\n"
  "}\n"
  "#define tarr_SET_RANGE(Vtype, fn_size) \\\n"
  "  if (end < begin) \\\n"
  "    texc_expect(\"arr.setRange\", \\\n"
  "      \"end < begin\", str_f(\"end == %d\", end), str_f(\"end >= %d\", begin) \\\n"
  "    ); \\\n"
  "  int size = end - begin; \\\n"
  "  if (!size) return; \\\n"
  "  texc_check_range(\"arr.setRange\", 0, fn_size(other) - size, begin); \\\n"
  "  texc_check_range(\"arr.setRange\", 0, fn_size(this) - size, ix); \\\n"
  "  Vtype *target = this->begin + ix; \\\n"
  "  Vtype *source = other->begin + begin; \\\n"
  "  memcpy(target, source, sizeof(void *) * size);\n"
  "static void tarr_set_rangeI (\n"
  "  Arri *this, int64_t ix, Arri *other, int64_t begin, int64_t end\n"
  ") { tarr_SET_RANGE(int64_t, tarr_sizeI) }\n"
  "static void tarr_set_rangeF (\n"
  "  Arrf *this, int64_t ix, Arrf *other, int64_t begin, int64_t end\n"
  ") { tarr_SET_RANGE(double, tarr_sizeF) }\n"
  "static void tarr_set_rangeS (\n"
  "  Arrs *this, int64_t ix, Arrs *other, int64_t begin, int64_t end\n"
  ")  { tarr_SET_RANGE(char*, tarr_sizeS) }\n"
  "#undef tarr_SET_RANGE\n"
  "static int64_t tarr_shiftI (Arri *this) {\n"
  "  if (this->begin == this->end) texc_throw(\"arr.shift\", \"Array is empty\");\n"
  "  return tarr_removeI(this, 0);\n"
  "}\n"
  "static double tarr_shiftF (Arrf *this) {\n"
  "  if (this->begin == this->end) texc_throw(\"arr.shift\", \"Array is empty\");\n"
  "  return tarr_removeF(this, 0);\n"
  "}\n"
  "static char *tarr_shiftS (Arrs *this) {\n"
  "  if (this->begin == this->end) texc_throw(\"arr.shift\", \"Array is empty\");\n"
  "  return tarr_removeS(this, 0);\n"
  "}\n"
  "#define tarr_SHUFFLE(Vtype) \\\n"
  "  int rnd_i (int max) { \\\n"
  "    return (int)(((double)rand() / (double)RAND_MAX) * max); \\\n"
  "  } \\\n"
  "  Vtype *begin = this->begin; \\\n"
  "  int size = this->end - begin; \\\n"
  "  Vtype *p = this->end - 1; \\\n"
  "  Vtype *pix; \\\n"
  "  Vtype tmp; \\\n"
  "  while (p > begin) { \\\n"
  "    pix = begin + rnd_i(size--); \\\n"
  "    tmp = *p; \\\n"
  "    *p-- = *pix; \\\n"
  "    *pix = tmp; \\\n"
  "  }\n"
  "static void tarr_shuffleI (Arri *this) { tarr_SHUFFLE(int64_t) }\n"
  "static void tarr_shuffleF (Arrf *this) { tarr_SHUFFLE(double) }\n"
  "static void tarr_shuffleS (Arrs *this) { tarr_SHUFFLE(char*) }\n"
  "#undef tarr_SHUFFLE\n"
  "\n"
  "static int tarr_sizeI (Arri *this) { return this->end - this->begin; }\n"
  "static int tarr_sizeF (Arrf *this) { return this->end - this->begin; }\n"
  "static int tarr_sizeS (Arrs *this) { return this->end - this->begin; }\n"
  "\n"
  "#define tarr_SORT(Atype, Vtype, less_fn, take_fn, drop_fn, sort_fn) \\\n"
  "  int sz = this->end - this->begin; \\\n"
  "  if (sz < 2) return; \\\n"
  "  if (sz == 2) { \\\n"
  "    if (less_fn(this->begin[1], this->begin[0])) { \\\n"
  "      Vtype tmp = this->begin[0]; \\\n"
  "      this->begin[0] = this->begin[1]; \\\n"
  "      this->begin[1] = tmp; \\\n"
  "    } \\\n"
  "    return; \\\n"
  "  } \\\n"
  "  if (sz < 17) { \\\n"
  "    Vtype *p = this->begin; \\\n"
  "    Vtype *end = (this->end - 1); \\\n"
  "    while (p < end) { \\\n"
  "      Vtype *q = p + 1; \\\n"
  "      Vtype *qend = (this->end); \\\n"
  "      while (q < qend) { \\\n"
  "        if (less_fn(*q, *p)) { \\\n"
  "          Vtype tmp = *p; \\\n"
  "          *p = *q; \\\n"
  "          *q = tmp; \\\n"
  "        } \\\n"
  "        ++q; \\\n"
  "      } \\\n"
  "      ++p; \\\n"
  "    } \\\n"
  "    return; \\\n"
  "  } \\\n"
  "  int ix = sz / 2; \\\n"
  "  Atype *left = take_fn(this, ix); \\\n"
  "  sort_fn(left); \\\n"
  "  Atype *right = drop_fn(this, ix); \\\n"
  "  sort_fn(right); \\\n"
  "  Vtype *pl = left->begin; \\\n"
  "  Vtype *endl = left->end; \\\n"
  "  Vtype *pr = right->begin; \\\n"
  "  Vtype *endr = right->end; \\\n"
  "  Vtype *p = this->begin; \\\n"
  "  while (pl < endl && pr < endr) { \\\n"
  "    if (less_fn(*pl, *pr)) *p++ = *pl++; \\\n"
  "    else *p++ = *pr++; \\\n"
  "  } \\\n"
  "  while (pl < endl) *p++ = *pl++; \\\n"
  "  while (pr < endr) *p++ = *pr++;\n"
  "static void tarr_sortIa (Arri *this) {\n"
  "  int less (int64_t e1, int64_t e2) { return e1 < e2; }\n"
  "  tarr_SORT(Arri, int64_t, less, tarr_takeI, tarr_dropI, tarr_sortIa)\n"
  "}\n"
  "static void tarr_sortId (Arri *this) {\n"
  "  int less (int64_t e1, int64_t e2) { return e1 > e2; }\n"
  "  tarr_SORT(Arri, int64_t, less, tarr_takeI, tarr_dropI, tarr_sortId)\n"
  "}\n"
  "static void tarr_sortI (Arri *this, int is_ascendant) {\n"
  "  if (is_ascendant) tarr_sortIa(this);\n"
  "  else tarr_sortId(this);\n"
  "}\n"
  "static void tarr_sortFa(Arrf *this) {\n"
  "  int less (double e1, double e2) { return e1 < e2; }\n"
  "  tarr_SORT(Arrf, double, less, tarr_takeF, tarr_dropF, tarr_sortFa)\n"
  "}\n"
  "static void tarr_sortFd(Arrf *this) {\n"
  "  int less (double e1, double e2) { return e1 > e2; }\n"
  "  tarr_SORT(Arrf, double, less, tarr_takeF, tarr_dropF, tarr_sortFd)\n"
  "}\n"
  "static void tarr_sortF (Arrf *this, int is_ascendant) {\n"
  "  if (is_ascendant) tarr_sortFa(this);\n"
  "  else tarr_sortFd(this);\n"
  "}\n"
  "static void tarr_sortSa (Arrs *this) {\n"
  "  int less (char * e1, char * e2) { return strcmp(e1, e2) < 0; }\n"
  "  tarr_SORT(Arrs, char*, less, tarr_takeS, tarr_dropS, tarr_sortSa)\n"
  "}\n"
  "static void tarr_sortSd (Arrs *this) {\n"
  "  int less (char * e1, char * e2) { return strcmp(e1, e2) > 0; }\n"
  "  tarr_SORT(Arrs, char*, less, tarr_takeS, tarr_dropS, tarr_sortSd)\n"
  "}\n"
  "static void tarr_sortS (Arrs *this, int is_ascendant) {\n"
  "  if (is_ascendant) tarr_sortSa(this);\n"
  "  else tarr_sortSd(this);\n"
  "}\n"
  "#undef tarr_SORT\n"
  "#define tarr_TAKE(Atype, Vtype, ALLOC_fn) \\\n"
  "  int size = this->end - this->begin; \\\n"
  "  if (n < 0) n = 0; \\\n"
  "  else if (n > size) n = size; \\\n"
  "  Atype *r = MALLOC(Atype); \\\n"
  "  int bf_size = this->bf - this->begin; \\\n"
  "  r->begin = ALLOC_fn(sizeof(Vtype) * bf_size); \\\n"
  "  r->end = r->begin + n; \\\n"
  "  r->bf = r->begin + bf_size; \\\n"
  "  if (n > 0) memcpy(r->begin, this->begin, sizeof(Vtype) * n); \\\n"
  "  return r;\n"
  "static Arri *tarr_takeI (Arri *this, int64_t n) { tarr_TAKE(Arri, int64_t, ATOMIC) }\n"
  "static Arrf *tarr_takeF (Arrf *this, int64_t n) { tarr_TAKE(Arrf, double, ATOMIC) }\n"
  "static Arrs *tarr_takeS (Arrs *this, int64_t n) { tarr_TAKE(Arrs, char*, GC_MALLOC) }\n"
  "#undef tarr_TAKE\n"
  "static void tarr_unshiftI (Arri *this, int64_t e) {\n"
  "  return tarr_insertI(this, 0, e);\n"
  "}\n"
  "static void tarr_unshiftF (Arrf *this, double e) {\n"
  "  return tarr_insertF(this, 0, e);\n"
  "}\n"
  "static void tarr_unshiftS (Arrs *this, char *e) {\n"
  "  return tarr_insertS(this, 0, e);\n"
  "}\n"
  "\n"
"// texc.c ----------\n"
  "static void texc_add(jmp_buf *jump) {\n"
  "  built_exc_fns('+', jump);\n"
  "}\n"
  "static void texc_remove() {\n"
  "  built_exc_fns('-', NULL);\n"
  "}\n"
  "static char *texc_get() {\n"
  "  char *msg;\n"
  "  built_exc_fns('<', &msg);\n"
  "  return msg;\n"
  "}\n"
  "static void texc_throw_(char *message) {\n"
  "  built_exc_fns(':', message);\n"
  "}\n"
  "static void texc_throw(char *function, char *message) {\n"
  "  texc_throw_(str_f(\n"
  "    \"Typed exception in %s:\\n%s\", function, message\n"
  "  ));\n"
  "}\n"
  "static void texc_expect (\n"
  "  char *function, char *message, char *expected, char *actual\n"
  ") {\n"
  "  texc_throw(function, str_f(\n"
  "    \"%s\\nExpected: %s\\n  Actual: %s\",\n"
  "    message, expected, actual\n"
  "  ));\n"
  "}\n"
  "// [begin, end]\n"
  "static void texc_check_range (char *function, int begin, int end, int index) {\n"
  "  if (index < begin || index > end) {\n"
  "    texc_throw(function, str_f(\n"
  "      \"Index out of range: %d < %d or %d > %d\",\n"
  "      index, begin, index, end\n"
  "    ));\n"
  "  }\n"
  "}\n"
  "static void texc_check_type (char *function, Obj *o, char *type) {\n"
  "  if (strcmp(o->type, type))\n"
  "    texc_expect(function, \"Bad object type\", type, o->type);\n"
  "}\n"
  "\n"
"// time.c ----------\n"
  "static char *_time_fmt (int64_t tm, char *template) {\n"
  "  char *s, *rs;\n"
  "  time_t tthis = (time_t)(tm / 1000);\n"
  "  struct tm *t = localtime(&tthis);\n"
  "  int size = 126;\n"
  "  while (1) {\n"
  "    rs = (char *)calloc(size, 1); // calloc ok\n"
  "    if (strftime (rs, size, template, t)) {\n"
  "      s = str_new(rs);\n"
  "      free(rs); // free ok\n"
  "      break;\n"
  "    }\n"
  "    free(rs); // free ok\n"
  "    size += size;\n"
  "  }\n"
  "  return s;\n"
  "}\n"
  "static int64_t time_add_days (int64_t this, int64_t days) {\n"
  "  return this + days * 86400000;\n"
  "}\n"
  "static int64_t time_day (int64_t this) {\n"
  "  time_t t = time_to_time(this);\n"
  "  return localtime(&t)->tm_mday;\n"
  "}\n"
  "static int time_day_light_correction (int day, int month, int year) {\n"
  "  struct tm t;\n"
  "  memset(&t, 0, sizeof(struct tm));\n"
  "  t.tm_year = year - 1900;\n"
  "  t.tm_mon = month;\n"
  "  t.tm_mday = day;\n"
  "  t.tm_hour = 12;\n"
  "  time_t t2 = mktime(&t);\n"
  "  int h = localtime(&t2)->tm_hour;\n"
  "  return 12 - h;\n"
  "}\n"
  "static int64_t time_df_day (int64_t this, int64_t other) {\n"
  "  return (this / 86400000) - (other / 86400000);\n"
  "}\n"
  "static int time_eq_day (int64_t this, int64_t other) {\n"
  "  return time_df_day(this, other) ? 0 : 1;\n"
  "}\n"
  "static char *time_fmt (int64_t this, char *template) {\n"
  "  int len = strlen(template);\n"
  "  int p = 0;\n"
  "  Buf *r = buf_new();\n"
  "  for (;;) {\n"
  "    int i = str_cindex_from(template, '%', p);\n"
  "    if (i == -1) break;\n"
  "    buf_add(r, str_sub(template, p, i));\n"
  "    ++i;\n"
  "    if (i == len)\n"
  "      texc_throw(\"time.fmt\", str_f(\"Bad '%' sequence at end in %s\", template));\n"
  "    char ch = template[i];\n"
  "    if (ch == '%') {\n"
  "      buf_cadd(r, ch);\n"
  "      p = i + 1;\n"
  "      continue;\n"
  "    }\n"
  "    if (\n"
  "      ch == 'd' || ch == 'D' || ch == 'm' || ch == 'M' || ch == 'y' ||\n"
  "      ch == 'Y' || ch == 't' || ch == 'T'\n"
  "    ) {\n"
  "      switch (ch) {\n"
  "        case 'd' :\n"
  "          buf_add(r, str_ltrim(_time_fmt(this, \"%e\")));\n"
  "          break;\n"
  "        case 'D':\n"
  "          buf_add(r, _time_fmt(this, \"%d\"));\n"
  "          break;\n"
  "        case 'm': {\n"
  "          char *v = _time_fmt(this, \"%m\");\n"
  "          if (*v == '0') v = v + 1;\n"
  "          buf_add(r, v);\n"
  "          break;\n"
  "          }\n"
  "        case 'M':\n"
  "          buf_add(r, _time_fmt(this, \"%m\"));\n"
  "          break;\n"
  "        case 'y':\n"
  "          buf_add(r, _time_fmt(this, \"%y\"));\n"
  "          break;\n"
  "        case 'Y':\n"
  "          buf_add(r, _time_fmt(this, \"%Y\"));\n"
  "          break;\n"
  "        case 't':\n"
  "          buf_add(r, _time_fmt(this, \"%T\"));\n"
  "          break;\n"
  "        default: { // 'T'\n"
  "          char *millis = str_f(\"%ld\", this % 1000);\n"
  "          buf_add(r, str_f(\"%s.%s\", _time_fmt(this, \"%T\"), millis));\n"
  "        }\n"
  "      }\n"
  "      p = i + 1;\n"
  "      continue;\n"
  "    }\n"
  "    texc_throw(\"time.fmt\", str_f(\"Bad '%' sequence in %s\", template));\n"
  "  }\n"
  "  buf_add(r, str_right(template, p));\n"
  "  return str_new(buf_str(r));\n"
  "}\n"
  "static Arri *time_from_clock (int64_t this, char *tms) {\n"
  "  int to_time_number (char *n, int max) {\n"
  "    if (strlen(n) != 2) return -1;\n"
  "    Arri *nnOp = math_stoi(n);\n"
  "    if (!nnOp) return -1;\n"
  "    int64_t nn = *tarr_beginI(nnOp);\n"
  "    if (nn >= max) return -1;\n"
  "    return nn;\n"
  "  }\n"
  "  Arrs *ps = str_csplit(tms, ':');\n"
  "  if (tarr_sizeS(ps) == 3) {\n"
  "    int h = to_time_number(tarr_getS(ps, 0), 24);\n"
  "    if (h != 1) {\n"
  "      int m = to_time_number(tarr_getS(ps, 1), 60);\n"
  "      if (m != -1) {\n"
  "        int s = to_time_number(tarr_getS(ps, 2), 60);\n"
  "        if (s != -1) {\n"
  "          int64_t r = time_new_time(\n"
  "            time_day(this), time_month(this), time_year(this),\n"
  "            h, m, s\n"
  "          );\n"
  "          return tarr_newi(r, 1);\n"
  "        }\n"
  "      }\n"
  "    }\n"
  "  }\n"
  "  return tarr_new_i();\n"
  "}\n"
  "static Arri *time_from_en (char *date, char *sep) {\n"
  "  return time_from_iso_en_aux(0, date, *sep);\n"
  "}\n"
  "static Arri *time_from_iso (char *date, char *sep) {\n"
  "  return time_from_iso_en_aux(1, date, *sep);\n"
  "}\n"
  "static Arri *time_from_iso_en_aux (int is_iso, char *date, char sep) {\n"
  "  Arrs *parts = str_csplit(date, sep);\n"
  "  if (tarr_sizeS(parts) == 3) {\n"
  "    char *d = tarr_getS(parts, (is_iso) ? 0 : 1);\n"
  "    char *m = tarr_getS(parts, (is_iso) ? 1 : 0);\n"
  "    char *y = tarr_getS(parts, 2);\n"
  "\n"
  "    if (strlen(d) == 1) d = str_f(\"%s%s\", \"0\", d);\n"
  "    if (strlen(m) == 1) m = str_f(\"%s%s\", \"0\", m);\n"
  "    if (strlen(y) == 2) y = str_f(\"%s%s\", \"20\", y);\n"
  "\n"
  "    if (strlen(d) == 2 && strlen(m) == 2 && strlen(y) == 4)\n"
  "      return time_from_str(str_f(\"%s%s%s\", y, m, d));\n"
  "  }\n"
  "  return tarr_new_i();\n"
  "}\n"
  "static Arri *time_from_str(char *date) {\n"
  "  if (strlen(date) != 8 && !math_digits(date)) return tarr_new_i();\n"
  "  char tpl[5];\n"
  "  memset (tpl, 0, 5);\n"
  "  memcpy(tpl, date + 6, 2);\n"
  "  int d = atoi(tpl);\n"
  "  memcpy(tpl, date + 4, 2);\n"
  "  int m = atoi(tpl);\n"
  "  memcpy(tpl, date, 4);\n"
  "  int y = atoi(tpl);\n"
  "  return tarr_newi(time_new(d, m, y), 1);\n"
  "}\n"
  "static int64_t time_from_time (time_t tm) {\n"
  "  return (int64_t)tm * 1000;\n"
  "}\n"
  "static int64_t time_hour (int64_t this) {\n"
  "  time_t t = time_to_time(this);\n"
  "  return localtime(&t)->tm_hour;\n"
  "}\n"
  "static int64_t time_millisecond (int64_t this) {\n"
  "  return this % 1000;\n"
  "}\n"
  "static int64_t time_minute (int64_t this) {\n"
  "  time_t t = time_to_time(this);\n"
  "  return localtime(&t)->tm_min;\n"
  "}\n"
  "static int64_t time_month (int64_t this) {\n"
  "  time_t t = time_to_time(this);\n"
  "  return localtime(&t)->tm_mon + 1;\n"
  "}\n"
  "static int64_t time_new (int day, int month, int year) {\n"
  "  struct tm t;\n"
  "  memset(&t, 0, sizeof(struct tm));\n"
  "  t.tm_year = year - 1900;\n"
  "  t.tm_mon = month - 1;\n"
  "  t.tm_mday = day;\n"
  "  t.tm_hour = 12 + time_day_light_correction(day, month, year);\n"
  "\n"
  "  return time_from_time((time_t) mktime(&t));\n"
  "}\n"
  "static int64_t time_new_time (\n"
  "  int day, int month, int year, int hour, int minute, int second\n"
  ") {\n"
  "  struct tm t;\n"
  "  memset(&t, 0, sizeof(struct tm));\n"
  "  t.tm_year = year - 1900;\n"
  "  t.tm_mon = month - 1;\n"
  "  t.tm_mday = day;\n"
  "  t.tm_hour = hour + time_day_light_correction(day, month, year);\n"
  "  t.tm_min = minute;\n"
  "  t.tm_sec = second;\n"
  "\n"
  "  return time_from_time((time_t) mktime(&t));\n"
  "}\n"
  "static int64_t time_now(void) {\n"
  "  struct timeval tm;\n"
  "  gettimeofday(&tm, NULL);\n"
  "  return tm.tv_sec * 1000 + tm.tv_usec / 1000;\n"
  "}\n"
  "static int64_t time_second (int64_t this) {\n"
  "  time_t t = time_to_time(this);\n"
  "  return localtime(&t)->tm_sec;\n"
  "}\n"
  "static char *time_to_en (int64_t this) {\n"
  "  return _time_fmt(this, \"%m-%d-%Y\");\n"
  "}\n"
  "static char *time_to_iso (int64_t this) {\n"
  "  return _time_fmt(this, \"%d/%m/%Y\");\n"
  "}\n"
  "static char *time_to_str (int64_t this) {\n"
  "  return _time_fmt(this, \"%Y%m%d\");\n"
  "}\n"
  "static time_t time_to_time (int64_t this) {\n"
  "  return (time_t)(this / 1000);\n"
  "}\n"
  "static int64_t time_weekday (int64_t this) {\n"
  "  time_t t = time_to_time(this);\n"
  "  return localtime(&t)->tm_wday;\n"
  "}\n"
  "static int64_t time_year (int64_t this) {\n"
  "  time_t t = time_to_time(this);\n"
  "  return localtime(&t)->tm_year + 1900;\n"
  "}\n"
  "static int64_t time_year_day (int64_t this) {\n"
  "  time_t t = time_to_time(this);\n"
  "  return localtime(&t)->tm_yday + 1;\n"
  "}\n"
  "\n"
"// ttype.c ----------\n"
  "\n"
"// tval.c ----------\n"
  "union tval_Tval {\n"
  "  int b;\n"
  "  int64_t i;\n"
  "  double f;\n"
  "  char *s;\n"
  "  Arri *I;\n"
  "  Arrf *F;\n"
  "  Arrs *S;\n"
  "};\n"
  "\n"
  "\n"
;

#endif
