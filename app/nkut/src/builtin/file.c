// Copyright 21-Jun-2025 ºDeme
// GNU General Public License - V3 <http://www.gnu.org/licenses/>

char *file_bget (void) {return
  "// Copyright 22-Jun-2024 ºDeme\n"
  "// GNU General Public License - V3 <http://www.gnu.org/licenses/>\n"
  "\n"
  "import * as sys from './sys.js';\n"
  "import * as bytes from './bytes.js';\n"
  "import * as cryp from './cryp.js';\n"
  "import {\n"
  "  closeSync, copyFileSync, createReadStream, existsSync, lstatSync,\n"
  "  mkdirSync, openSync, readdirSync, readFileSync, readSync, realpathSync,\n"
  "  renameSync, rmSync, statSync, symlinkSync, writeFileSync, writeSync\n"
  "} from \"fs\";\n"
  "import { once } from 'events';\n"
  "import { createInterface } from 'readline';\n"
  "import { open } from \"fs/promises\";\n"
  "import { pid, cwd, chdir } from \"process\";\n"
  "\n"
  "// \\s -> s\n"
  "function normalize(p) {\n"
  "  let r = p.trim();\n"
  "  while (r.endsWith(\"/\")) r = r.substring(0, r.lenght - 1);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "// \\s -> <file>\n"
  "export function aopen (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return openSync(p, \"a\");\n"
  "}\n"
  "\n"
  "// \\s -> s\n"
  "export function base (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  const r = normalize(p);\n"
  "  const ix = r.lastIndexOf('/');\n"
  "  if (ix !== -1) return r.substring(ix + 1);\n"
  "  return r;\n"
  "}\n"
  "\n"
  "// \\s -> s\n"
  "export function canonical (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return realpathSync(p);\n"
  "}\n"
  "\n"
  "// \\[s.] -> s\n"
  "export function cat (a) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  if (a.length === 0) a.push(\"./\");\n"
  "  else if (a[0] === \"\") a[0] = \".\";\n"
  "  return clean(a.join(\"/\"));\n"
  "}\n"
  "\n"
  "// \\s -> ()\n"
  "export function cd (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  chdir(p);\n"
  "}\n"
  "\n"
  "// \\s -> s\n"
  "export function clean (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  let s = p.trim();\n"
  "  if (s === \"\") return \"\";\n"
  "  let bf = [];\n"
  "  let isSlash = false;\n"
  "  for (let i = 0; i < s.length; ++i) {\n"
  "    const ch = s.charAt(i);\n"
  "    if (ch === \"/\") {\n"
  "      if (isSlash) continue;\n"
  "      isSlash = true;\n"
  "      bf.push(ch);\n"
  "      continue;\n"
  "    }\n"
  "    isSlash = false;\n"
  "    bf.push(ch);\n"
  "  }\n"
  "  s = bf.join(\"\");\n"
  "  if (s.length === 1) return s;\n"
  "  if (s.endsWith(\"/\")) s = s.substring(0, s.length - 1);\n"
  "\n"
  "  bf = [];\n"
  "  const parts = s.split(\"/\");\n"
  "  for (let i = 0; i < parts.length; ++i) {\n"
  "    const part = parts[i];\n"
  "    if (part === \".\") continue;\n"
  "    if (part === \"..\") {\n"
  "      if (bf.length > 0) bf.pop();\n"
  "      else throw new Error(\"Bad path for cleaning '\" + p + \"'\");\n"
  "      continue;\n"
  "    }\n"
  "    bf.push(part);\n"
  "  }\n"
  "  s = bf.join(\"/\");\n"
  "  if (s === \"\" && p[0] === \"/\")\n"
  "    throw new Error(\"Bad path for cleaning '\" + p + \"'\");\n"
  "\n"
  "  return s;\n"
  "}\n"
  "\n"
  "// \\<file> -> ()\n"
  "export function close (f) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  closeSync(f);\n"
  "}\n"
  "\n"
  "// \\s, s -> ()\n"
  "export function copy (source, target) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  if (isDirectory(source)) {\n"
  "    if (!isDirectory(target))\n"
  "      throw new Error(\"'\" + target + \"' is not a directory\");\n"
  "\n"
  "    const tdir = cat([target, base(source)]);\n"
  "    del(tdir);\n"
  "    mkdir(tdir);\n"
  "    const files = dir(source);\n"
  "    for (let i = 0; i < files.length; ++i) {\n"
  "      const fname = files[i];\n"
  "      copy(cat([source, fname]), tdir);\n"
  "    }\n"
  "    return;\n"
  "  }\n"
  "  if (isDirectory(target))\n"
  "    target = cat([target, base(source)]);\n"
  "\n"
  "  copyFileSync(source, target);\n"
  "}\n"
  "\n"
  "// \\s -> ()\n"
  "export function del (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  rmSync(p, { recursive: true, force: true });\n"
  "}\n"
  "\n"
  "// \\s -> [s.]\n"
  "export function dir (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return readdirSync(p);\n"
  "}\n"
  "\n"
  "// \\s -> b\n"
  "export function exists (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return existsSync(p);\n"
  "}\n"
  "\n"
  "// \\s -> s\n"
  "export function extension (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  const r = base(p);\n"
  "  const ix = r.lastIndexOf(\".\");\n"
  "  if (ix === -1) return \"\";\n"
  "  return r.substring(ix);\n"
  "}\n"
  "\n"
  "// \\s -> b\n"
  "export function isDirectory (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return exists(p) && statSync(p).isDirectory();\n"
  "}\n"
  "\n"
  "// \\s -> b\n"
  "export function isLink (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return exists(p) && lstatSync(p).isSymbolicLink();\n"
  "}\n"
  "\n"
  "// \\s -> b\n"
  "export function isRegular (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return exists(p) && statSync(p).isFile();\n"
  "}\n"
  "\n"
  "// \\s -> ()\n"
  "export function mkdir (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  mkdirSync(p, { recursive: true });\n"
  "}\n"
  "\n"
  "// \\s, s -> ()\n"
  "export function mklink (p, lk) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  symlinkSync(p, lk);\n"
  "}\n"
  "\n"
  "// \\s -> s\n"
  "export function parent (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  const r = normalize(p);\n"
  "  if (r === \"\") throw new Error(\"'\" + p + \"' has not parent directory\");\n"
  "  const ix = r.lastIndexOf(\"/\");\n"
  "  if (ix === -1) return \"\";\n"
  "  if (ix === 0) return \"/\";\n"
  "  return r.substring(0, ix);\n"
  "}\n"
  "\n"
  "// \\s -> s\n"
  "export function read (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return readFileSync(p, { encoding: \"utf8\" });\n"
  "}\n"
  "\n"
  "// \\<file>, n -> <bytes>\n"
  "export function readBin (f, bufLen) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  const bf = bytes.mk(bufLen);\n"
  "  const n = readSync(f, bf, 0, bufLen, null);\n"
  "  return n < bufLen ? bytes.take(bf, n) : bf;\n"
  "}\n"
  "\n"
  "// \\s, \\s -> () -> ()\n"
  "export async function readLines (p, fn) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  sys.$fparams(fn, 1);\n"
  "\n"
  "  const rl = createInterface({\n"
  "    input: createReadStream(p)\n"
  "  });\n"
  "\n"
  "  rl.on('line', (line) => {\n"
  "    fn(line);\n"
  "  });\n"
  "\n"
  "  await once(rl, 'close');\n"
  "}\n"
  "\n"
  "// \\[s.], \\[([s]|[]).] -> () -> ()\n"
  "export async function readLines2 (ps, fn) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  sys.$fparams(fn, 1);\n"
  "\n"
  "  const lineBfs = ps.map(() => []);\n"
  "  const closes = ps.map(() => false);\n"
  "\n"
  "  function control (nstream, isClose, line) {\n"
  "    if (isClose) {\n"
  "      closes[nstream] = true;\n"
  "      return;\n"
  "    }\n"
  "    lineBfs[nstream].push(line);\n"
  "    let ok = true;\n"
  "    for (let i = 0; i < lineBfs.length; ++i)\n"
  "      if (lineBfs[i].length === 0 && !closes[nstream]) ok = false;\n"
  "\n"
  "    if (ok) {\n"
  "      const pars = [];\n"
  "      for (let i = 0; i < lineBfs.length; ++i) {\n"
  "        const lb = lineBfs[i];\n"
  "        if (lb.length !== 0)  pars.push([lb.shift()]);\n"
  "        else pars.push([]);\n"
  "      }\n"
  "      fn(pars);\n"
  "    }\n"
  "  }\n"
  "\n"
  "  const rls = [];\n"
  "  for (let i = 0; i < ps.length; ++i) {\n"
  "    const rl = createInterface({\n"
  "      input: createReadStream(ps[i])\n"
  "    });\n"
  "\n"
  "    rl.on('line', (line) => control(i, false, line));\n"
  "    rl.on('close', () => control(i, true, \"\"));\n"
  "\n"
  "    rls.push(rl);\n"
  "  }\n"
  "\n"
  "  for (let i = 0; i < rls.length; ++i)\n"
  "    await once(rls[i], 'close');\n"
  "}\n"
  "\n"
  "// \\s, s -> ()\n"
  "export function rename (oldPath, newPath) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  renameSync(oldPath, newPath);\n"
  "}\n"
  "\n"
  "// \\s -> <file>\n"
  "export function ropen (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return openSync(p, \"r\");\n"
  "}\n"
  "\n"
  "// \\s -> n\n"
  "export function size (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return statSync(p).size;\n"
  "}\n"
  "\n"
  "// \\s -> n\n"
  "export function tm (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return statSync(p).mtime;\n"
  "}\n"
  "\n"
  "// \\s, s -> s\n"
  "export function tmp (dir, fpath) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  if (dir == \"\") dir = \"/tmp\";\n"
  "  let rpath = \"\";\n"
  "  while (true) {\n"
  "    const k = cryp.genK(16);\n"
  "    const v = cryp.encode(k, \"\" + pid).substring(0, 8);\n"
  "    rpath = cat([dir, fpath + v.replaceAll(\"/\", \"-\")]);\n"
  "    if (!exists(fpath)) break;\n"
  "  }\n"
  "  return rpath;\n"
  "}\n"
  "\n"
  "// \\ -> s\n"
  "export function wd () {\n"
  "  sys.$params(arguments.length, 0);\n"
  "  return cwd();\n"
  "}\n"
  "\n"
  "// \\s -> <file>\n"
  "export function wopen (p) {\n"
  "  sys.$params(arguments.length, 1);\n"
  "  return openSync(p, \"w\");\n"
  "}\n"
  "\n"
  "// \\s, s -> ()\n"
  "export function write (p, text) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  writeFileSync(p, text);\n"
  "}\n"
  "\n"
  "// \\<file>, <bytes> -> ()\n"
  "export function writeBin (f, data) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  writeSync(f, data);\n"
  "}\n"
  "\n"
  "// \\<file>, s -> ()\n"
  "export function writeText (f, text) {\n"
  "  sys.$params(arguments.length, 2);\n"
  "  writeSync(f, text);\n"
  "}\n"
  "\n"
  "\n"
;}
